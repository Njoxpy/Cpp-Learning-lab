{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"C++ Learning Lab","text":"<p>Welcome to the C++ Learning Lab repository!</p> <p>This repository is specifically designed to support university students in Tanzania who want to learn and gain experience in C++ programming. The primary focus is providing resources, materials, and tutorials in both English and Swahili languages to enhance accessibility for learners.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>The Tutorials directory contains step-by-step tutorials for beginners to understand the fundamentals of the C++ language.</li> <li>The Examples directory includes practical code examples that demonstrate various concepts, features, and best practices in C++.</li> <li>The Projects directory offers hands-on projects to apply and reinforce your C++ skills.</li> <li>The Resources directory provides supplementary materials, cheat sheets, and recommended readings to deepen your understanding of C++.</li> </ul>"},{"location":"#how-to-contribute","title":"How to Contribute","text":"<p>Visit Contributing.md</p>"},{"location":"#license","title":"License","text":"<p>This repository is licensed under the GNU GENERAL PUBLIC LICENSE.Feel free to use, modify, and distribute the code and resources within this repository, while respecting the license terms.</p>"},{"location":"#contact","title":"Contact","text":"<p>If you have any questions, suggestions, or encounter any issues, please feel free to reach me via twitter</p> <p>Happy learning and happy coding!</p>"},{"location":"CONTRIBUTING/","title":"Contributing to cpp learning lab","text":"<p>Thank you for considering contributing to cpp learning lab! Your contributions help make this project better for everyone. Before you start, please make sure you have the following:</p> <ol> <li>Markdown Lint Extension: Ensure you have the Markdown Lint extension by David Anson installed in your development environment. This extension helps maintain consistent and clean Markdown formatting.</li> <li> <p>Extension link: Markdown Lint by David Anson</p> </li> <li> <p>Markdown Preview: Use <code>ctrl+shift+v</code> to preview your Markdown before pushing. Previewing your changes ensures they render correctly before submission. This shortcut is for Visual Studio Code, adjust accordingly if using a different editor.</p> </li> <li> <p>Markdown Syntax Knowledge: Familiarize yourself with basic Markdown syntax. Having a good understanding of Markdown will help in creating clear and well-formatted contributions.</p> </li> <li> <p>If you need a refresher, here's a handy guide: Markdown Guide</p> </li> <li> <p>Branch Naming Convention: When creating a new branch for your contribution, follow this naming convention:</p> </li> <li><code>feature/your-feature-name</code> for new features or enhancements</li> <li><code>bugfix/issue-number</code> for bug fixes</li> <li> <p><code>docs/your-documentation</code> for documentation updates</p> </li> <li> <p>Commit Messages: Please use clear and descriptive commit messages. This helps maintain a clean and informative commit history.</p> </li> <li> <p>For example: \"Add new feature: FeatureName\" or \"Fix issue #123: Description of the fix\".</p> </li> <li> <p>Pull Request Guidelines:</p> </li> <li>Before opening a pull request, ensure your code adheres to our project's coding standards.</li> <li>Describe the purpose of your pull request clearly and concisely.</li> <li> <p>Reference any related issues by using <code>Fixes #issue-number</code> if your PR fixes a reported issue.</p> </li> <li> <p>Code Review:</p> </li> <li>Be open to feedback and be willing to make changes to your code based on code review comments.</li> <li> <p>Respect the feedback provided by other contributors and maintain a positive and collaborative atmosphere.</p> </li> <li> <p>Have Fun!:</p> </li> <li>Lastly, have fun learning and contributing! We appreciate your time and effort in making cpp learning lab a great resource for the community.</li> </ol>"},{"location":"basics/Data%20Type/data_types/","title":"Data types","text":"<ul> <li>Data types</li> <li>Introduction</li> <li>Types of data types<ul> <li>Primitive data types</li> <li>Derived data types</li> <li>User defined data types</li> </ul> </li> <li>Advantages</li> <li>Disavantage</li> <li>Best Practices</li> </ul>"},{"location":"basics/Data%20Type/data_types/#introduction","title":"Introduction","text":"<ul> <li>Data types hutumika kuamua ukubwa na aina ya data inayoweza kutunzwa</li> <li>Variables na arrays ni makontena katika programu yetu ambayo hutunza data mbalimbali. Sasa, kulingana na datatype uliyotumia operating system ya kompyuta ina tenga nafasi inayoweza kuhifadhi hiyo data.</li> <li> <p>kwa mfano tuangalie hii programu:</p> <p><code>cpp  int age = 13;</code></p> </li> <li> <p>Hapa, variable <code>age</code> ni ya data type <code>int</code> . Hii inamaanisha kwamba variable yetu inaweza kuhifadhi integer yenye byte 2 au 4</p> </li> </ul>"},{"location":"basics/Data%20Type/data_types/#types-of-data-types","title":"Types of data types","text":""},{"location":"basics/Data%20Type/data_types/#primitive-data-types","title":"Primitive data types","text":"<ol> <li>Primitive Data types: Hizi ni data types ambazo zinaweza kutumika moja kwa moja kudeclare variables. Primitive data types kwenye C++ ni:<ul> <li>Integer</li> <li>Character</li> <li>Boolean</li> <li>Floating point(float)</li> <li>Double floating point (double)</li> <li>Void</li> </ul> </li> </ol>"},{"location":"basics/Data%20Type/data_types/#derived-data-types","title":"Derived data types","text":"<p>2.Derived Data types: Hizi ni datatypes ambazo zimeundwa kutokea kwa primitive data types. Nazo ni;     - Function     - Array     - Pointer     - Reference</p>"},{"location":"basics/Data%20Type/data_types/#user-defined-data-types","title":"User defined data types","text":"<p>3.User defined data types: Hizi ni datatypes ambazo hutengenezwa na programmer mwenyewe. Hizi user defined datatypes kwenye C++ ni;     - Class     - Structure     - Union     - Enumeration     - Typedef defined Datatype</p>"},{"location":"basics/Data%20Type/data_types/#datatype-modifier","title":"Datatype Modifier","text":"<p>Datatype modifier hutumika pamoja na primitive data types kumodify urefu wa data ambayo datatype husika inaweza kuhifadhi. Data type modifier kwenye C++ ni;</p> <ul> <li>Signed</li> <li>Unsigned</li> <li>Short</li> <li>Long</li> </ul> <p>Jedwali hapa chini linaonyesha range ya ukubwa wa primitive data types na ukubwa wa modified primitive data types:</p> Data Type Size(byte) Range short int 2 -32,768 mpaka 32,767 unsigned short int 2 0 mpaka 65,535 unsigned int 4 0 mpaka 4,294,967,295 int 4 -2,147,483,648 mpaka 2,147,483,647 long int 4 -2,147,483,648 mpaka 2,147,483,647 unsigned long int 4 0 mpaka 4,294,967,295 long long int 8 -(2^63) mpaka (2^63)-1 unsigned long long int 8 0 mpaka 18,446,744,073,709,551,615 signed char 1 -128 mpaka 127 unsiged char 1 0 mpaka 255 float 4 -3.4x10^38 to 3.4x10^38 double 8 -1.7x10^308 mpaka 1.7x10^308 long double 12 -1.1x10^4932 mpaka 1.1x10^4932 wchar_t 2 or 4 1 wide character <pre><code>Note:\nThamani za range zilizopo katika jedwali hapo juu zinatofautiana na aina ya compiler. Kwenye  mfano hapo juu tumetumia GCC 32 bit\n</code></pre> <p>Ukitaka kupata size ya data type tofauti kwenye computer yako tumia programu hii:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n   cout &lt;&lt; \"Size of char : \" &lt;&lt; sizeof(char) &lt;&lt; endl;\n   cout &lt;&lt; \"Size of int : \" &lt;&lt; sizeof(int) &lt;&lt; endl;\n   cout &lt;&lt; \"Size of short int : \" &lt;&lt; sizeof(short int) &lt;&lt; endl;\n   cout &lt;&lt; \"Size of long int : \" &lt;&lt; sizeof(long int) &lt;&lt; endl;\n   cout &lt;&lt; \"Size of float : \" &lt;&lt; sizeof(float) &lt;&lt; endl;\n   cout &lt;&lt; \"Size of double : \" &lt;&lt; sizeof(double) &lt;&lt; endl;\n   cout &lt;&lt; \"Size of wchar_t : \" &lt;&lt; sizeof(wchar_t) &lt;&lt; endl;\n\n   return 0;\n}\n</code></pre>"},{"location":"basics/Data%20Type/data_types/#typedef-declarations","title":"typedef Declarations","text":"<p>typedef hutumika kuyapa majina mapya data types. ifuatayo ni sintaksia rahisi kufafanua aina mpya ya data type kwa kutumia typedef</p> <pre><code>typedef type newname;\n</code></pre> <p>kwa mfano, programu ifuatayo inaiambia compiler kuwa saa ni jina jingine la int;</p> <pre><code>typedef int saa;\n</code></pre> <p>hivyo, declaration ifuatayo ni sahii na inatengeneza integer iitwayo urefu;</p> <pre><code>saa urefu;\n</code></pre>"},{"location":"basics/Data%20Type/data_types/#advantages","title":"Advantages","text":"<ol> <li>Data types zinatupa njia ya kupanga data ndani ya programu yetu, hivyo hutusaidia kuelewa na kutunza program yetu kwa urahisi.</li> <li>kila data type ina range ya thamani inayoweza kutunza, hivyo hutupatia udhibiti sahihi juu ya data gani inaweza kutunzwa.</li> <li>Data types zinapunguza makosa ndani ya program kwa kuweka sheria kali juu ya jinsi data zinaweza kutumika.</li> <li>C++ ina aina mbalimbali za datatypes, hivyo humuwezesha developer kuchagua datatype inayoofa matumizi yake.</li> </ol>"},{"location":"basics/Data%20Type/data_types/#disadvantage","title":"Disadvantage","text":"<ol> <li>Matumizi yasiyo sahihi ya data type huleta makosa ndani ya programu.</li> <li>Data types kama long doubles or char arrays huchukua nafasi kubwa, hivyo zikitumika sana zinatumia hifadhi kubwa na hupunguza uwezo wa compiler</li> </ol>"},{"location":"basics/Data%20Type/data_types/#best-practices","title":"Best Practices","text":""},{"location":"basics/arrays/arrays/","title":"Arrays","text":"<ul> <li>Arrays</li> <li>Introduction</li> <li>Declaration</li> <li>Initialization</li> <li>Accessing Elements</li> <li>Multidimensional Arrays</li> <li>Relationship Between Arrays and Pointers</li> <li>Array Size and sizeof Operator</li> <li>Array Manipulation Functions</li> <li>Common Mistakes People Make When Working With Arrays</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"basics/arrays/arrays/#introduction","title":"Introduction","text":"<ul> <li> <p>Arrays ni aina ya data ambayo inatumika kuhifadhi kundi(list) la data za aina moja tu,Mfano maksi za wanafunzi, majina ya wanafunzi.Maksi za wanafunzi zote zinaweza kuwa integers tu, majina ya wanafunzi yanakuwa katika strings tu.Tunaweza kuandika programu ambayo itawezesha wanafunzi wetu waweze kuingiza marks zao za somo la <code>introduction to C++</code> basi itabidi tutumie array ambayo itahifadhi maksi za wanafunzi wote katika darasa letu basi hapa arrays itatumika, pia kupitia marks hizo za wanafuzni tunaweza tukapata wastani wa wanafunzi wote.</p> </li> <li> <p>Kama tutatumia variables badala ya array msimbo(code) wetu utakuwa hivi,kwamba kila maksi ya mwanafunzi itakuwa na variable yake!</p> </li> </ul> <pre><code>    int mwanafunzi1 = 10;\n    int mwanafunzi2 = 45;\n    int mwanafunzi3 = 68;\n    int mwanafunzi4 = 90;\n</code></pre> <ul> <li>Kama tungetumia variable basi tungetumia muda mrefu tuweze kufanya declaration ya variables zetu ila kutokana na uwepo wa arrays tunarahishisha kazi.</li> <li>Basi tukitumia array itakuwa rahisi zaidi</li> </ul> <p><code>cpp     int Maksi_za_wanafunzi[4] = {10, 45, 68, 90};</code></p>"},{"location":"basics/arrays/arrays/#declaration","title":"Declaration","text":"<pre><code>Sintaksia:\n\nType_Name Array_Name[Declared_Size];\n</code></pre> <ul> <li> <p>Katika <code>C++</code> ili tuweze kufanya declaration ya array,tunataka kutengeneza array ya maksi za wanafunzi wanne ambao wana marksi tofauti.</p> </li> <li> <p>Since array inakuwa na data ambazo zote ni sawa kwa members wote hivyo marks zetu tunataka ziwe katika <code>int</code> integer, anza na int keyword ikifuatiwa na jina la array yako na square brackets <code>[]</code> square brackets ndio inatambulisha kwenye interpreter yetu kwa hi ni array.Kwamba hizo ni arrays na ndani ya hayo mabano huwa ni idadi ya maksi ambazo unataka ziwe ndani ya array yako, kwa upande wetu idadi ya marks ni za wanafunzi wanne hivyo ndani ya hiyo square bracket kutakuwa na 4,hii inamaanisha kwamba kuna member wanne katika array.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    int maksi[4];\n    return 0;\n}\n</code></pre>"},{"location":"basics/arrays/arrays/#initialization","title":"Initialization","text":"<ul> <li>Baada ya kufanya declaration ya thamani(value) zako katika array kinachofuata ni kuzipa thamani(value) ambapo kila mwanafunzi anakuwa na marks zake ambazo zinahifadhiwa ndani ya arrays kama array member baada ya kufanya declaration kisha tumia assignment operator ya = ikifuatiwa na braces na ndani ya braces ndio utaweka maksi za wanafuzni hao wanne!</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int maksi_za_wanafunzi[4] = {10, 45, 68, 90};\n    return 0;\n}\n</code></pre>"},{"location":"basics/arrays/arrays/#accessing-elements","title":"Accessing Elements","text":"<ul> <li>Kupata access ya value ya member wa array tunatumia <code>indexing</code>, array ziko katika zero index kwamba ili kuweza kupata acess ya thamani ya mwanafunzi wa kwanza katika array tutaanza katika index ya zero ni kama tunahesabu kuanzia sifuri. Mfano wa array yetu <code>int maksi_za_wanafunzi[4] = {10, 45, 68, 90};</code> ila kuweza kupata thamani(value) ya mwanafunzi wa kwanza katika array yetu,tutaanza na jina la array ikiufatiwa na square brackets na ndani ya square bracket tuta specify sehemu ambapo hiyo value yetu ipo ila kumbuka kwamba array ni zero indexed.</li> </ul> <pre><code>    int maksi_za_wanafunzi[4] = {10, 45, 68, 90};\n    // kupata thamani ya member wa kwanza yaani 10 katika array\n    cout &lt;&lt; maksi_za_wanafunzi[0] &lt;&lt; endl;\n    // output: 10\n\n    // kupata thamani ya member wa pili katika array\n    cout &lt;&lt; maksi_za_wanafunzi[1] &lt;&lt; endl;\n    // output: 45 \n</code></pre> <ul> <li>Kama utajaribu kupata access ya member wa array ila index itakuwa kubwa kuliko idadi ya member wa array yako haitawezekana ila kuna baadhi ya interpreter zitakupa garbage value pia value ambayo ni garbage inatofautiatana kutokana na IDE hivyo usishangae kuona mbona majibu tofauti.Angalia mfano:</li> </ul> <pre><code>    int maksi_za_wanafunzi[4] = {10, 45, 68, 90};\n    cout &lt;&lt; maksi_za_wanafunzi[5];\n    // output: 611\n</code></pre> <ul> <li>Ili kupata member(element) ya mwisho katika array yako utachukua (urefu)length wa array kisha utatoa na moja.</li> </ul> <pre><code>\n</code></pre>"},{"location":"basics/arrays/arrays/#multidimensional-arrays","title":"Multidimensional Arrays","text":"<ul> <li>Multidimensional Arrays ni zile arrays ambazo ndani ya array kuna arrays,mfano:</li> </ul>"},{"location":"basics/arrays/arrays/#relationship-between-arrays-and-pointers","title":"Relationship Between Arrays and Pointers","text":"<ul> <li>Pitia hapa</li> </ul>"},{"location":"basics/arrays/arrays/#array-size-and-sizeof-operator","title":"Array Size and sizeof Operator","text":""},{"location":"basics/arrays/arrays/#array-manipulation-functions","title":"Array Manipulation Functions","text":""},{"location":"basics/arrays/arrays/#common-mistakes-people-make-when-working-with-arrays","title":"Common Mistakes People Make When Working With Arrays","text":"<ul> <li>Too many initilizers, moja katika kosa watu wanafanya ni kuandika arrays ihifahi kiasi fulani cha data ila members wa array wanazidi idadi ya arrays ambazo zinakuwa stored.</li> </ul> <pre><code>int marks[4] = {10, 34, 5, 6,67};\ncout &lt;&lt; marks;\n// output: error: too many initializers for 'int [4]'\n</code></pre> <ul> <li>Kufanya allocation ya space kwa ajili ya array,ila member waliopo ndani ya array yako ni wachache ukifananisha na namna ambavyo array yako imekuwa declared.</li> </ul> <pre><code>    int maksi_za_wanafunzi[4] = {10, 45, 68};\n</code></pre> <ul> <li>Kufanya allocation ya array yako bila kufanya declaration ya idadi yako ya member wa array ambao wanakuepo,hii inapelekea interpreter kufanya allocation ya space kwa ajili ya computer yako ila space inayotumika ni chache.</li> </ul> <pre><code>    int maksi_za_wanafunzi[] = {10, 45, 68};\n</code></pre> <ul> <li>Kufanya declaration ya array yako ila unaacha tu bila kufanya kitu chochote ambapo interpreter inafanya allocation ya space kwenye memory ila hio space haitumiki kufanyia chochote.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int maksi_za_wanafunzi[] = {10, 45, 68};\n    return 0;\n}\n\n// output\n/*\n warning: unused variable 'maksi_za_wanafunzi' [-Wunused-variable]\n    7 |     int maksi_za_wanafunzi[] = {10, 45, 68};\n*/\n</code></pre>"},{"location":"basics/arrays/arrays/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Use Standard Library Containers: Pale ambapo inawezekana pendelea kutumia standard library conatiners, kama vector, string juu ya raw arrays.Zipo na safety checks, dynamic resizing na pia kiujumla zipo flexible.</p> </li> <li> <p>Initialize Arrays: Fanya initialization ya arrays zako pale ambapo unafanya declaration.Hii inasaidia kupunguza kujaribu kupata access ya memory ambayo sio initialized kwenye memory.</p> </li> <li> <p>Use Range-Based For Loops: Unapofanya iteration kwenye arrays tumia range based loops zipo safe na pia zio clean na readable ukifananisha na traditional loops.</p> </li> <li> <p>Use std::array for Fixed-Size Arrays:Kama unajua kwamba size ya array haitabadilika wakati wa kufanya compilation pendelea kutumia standard arrays.</p> </li> <li> <p>Check Bounds: Angalia muda wa kufanya access ya elements zako. Kama umejaribu kupata access ya element kwenye program itakuwa shida kwenye kufanya debugging.</p> </li> </ul>"},{"location":"basics/arrays/arrays/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li>The indexes of an array always start with 0 and end with the integer that is one less than the size of the array.</li> <li>The most common programming error made when using arrays is attempting to reference a nonexistent array index.</li> </ul> <p>\u2b06\ufe0f Rudi Juu</p>"},{"location":"basics/decision-making/decision_making/","title":"Decision Making","text":"<ul> <li>Introduction</li> <li>Operators</li> <li>Comparison Operators</li> <li>Logical Operators</li> <li>if Statement</li> <li>if-else Statement</li> <li>Nested if Statements</li> <li>Conditional Operator</li> <li>Increment And Decrement Operator</li> <li>switch Statement</li> <li>Common Mistakes</li> </ul>"},{"location":"basics/decision-making/decision_making/#introduction","title":"Introduction","text":"<ul> <li> <p>Katika sehemu hii tutajfunza namna ya kuandika program ambazo zitatuwezesha kuweza kufanya maamuzi.</p> </li> <li> <p>Karibu katika section hii ya Decision making, hii section ndio tutandika program ambazo zitafanya maamuzi. Decision making statement inatumika kuangalia kama statement ni kweli au sio kweli.Mfano tunaweza kutengeneza program yetu ya kumwezesha mpiga kura kuangalia kama mtu anayepiga kula yupo chini ya miaka 18 au ni zaidi ya miaka 18,katika situation kama hii ndio tunatumia if statement kuangalia kama statement yetu kweli au sikweli,kama ni kweli ina maana mpiga kura ana miaka kuanzia 18 na kuendelea ila kama sio kweli mpiga kura miaka yake ni chini ya 18.</p> </li> <li> <p>Ili tuweze kuandika hiyo program inabidi tujue miaka ya mpiga kura na ili kufanya comparison,tutatumia comparison operator.Ila ni muhimu kujua aina za operator ambazo zipo kwenye C++.</p> </li> </ul>"},{"location":"basics/decision-making/decision_making/#operators","title":"Operators","text":""},{"location":"basics/decision-making/decision_making/#comparison-operators","title":"Comparison Operators","text":"<ul> <li> <p>Comparison Operators: Tunatumia comparison operators kufanya comparison ya thamani(value) mbili au zaidi ya mbili katika programu yetu. Comparison operators zipo za aina nne katika <code>C++</code> kuna , greater than operator(&gt;), less than (&lt;), greater or equal (&gt;=) , less or equal (&lt;=), equality operator (==),na not equal(!=) sio sawa.Hizo ndio operators zinatumika katika kufanya comparison ya thamani(value)<code>C++</code>.</p> </li> <li> <p>Tunaweza tukatumia comparison operator kuangalia je ipi namba ni kubwa zaidi ya nyingine.Pia ili kujua vizuri kuhusu conditional operators katika C++ ni muhimu pia kujua namna ya kutumia comparison operator katika C++,kwa mfano tunaandika program ya kutuwezesha kuangalia miaka ya mpira kura ni kubwa au zaidi ya 18. Mfano wa jinsi ya kutumia comparison operators katika C++</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int x = 10;\n    bool result = x != 20;\n    cout &lt;&lt; boolalpha &lt;&lt; result;\n    return 0;\n    // Output: 20\n}\n</code></pre> <p>Kwenye mfano hapo ju,declaration ya variable x imefanyika na kisha tuaangalia kwa je variable x ambayo ni kumi ni sio sawa na 20,tukiangalia kwamba 10 sio sawa na 20 hivyo jibu ni kweli.</p> <ul> <li>Katika C++ jibu la default kwenye upande wa true au false huwa linakuwa 1 kama ni kweli au sifuri kama sio kweli,mfano</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int age = 19;\n    cout &lt;&lt; (age &gt;= 18);\n    return 0;\n}\n// Output: 1\n</code></pre> <p>Kwahiyo ili tuweze kufanya formatting ya thamani(value) tunatumia <code>boolalpha</code> kama kwenye mfano wa pale juu kabisa.</p> <p>C++ ni case sensitive kwamba a sio sawa na A,Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    char first = 'a';\n    char second = 'A';\n\n    bool result = first == second;\n    cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl;\n    // output: false\n    return 0;\n}\n</code></pre>"},{"location":"basics/decision-making/decision_making/#logical-operators","title":"Logical Operators","text":"<ul> <li> <p>Tunatumia Logical Operations ili kuweza kucompare two or more boolean expression au condition, logical operators kuna <code>&amp;&amp;</code> <code>||</code> na <code>!</code></p> </li> <li> <p>Kitendakazi &amp;&amp;(Logical AND),kinaangalia upande wote(kushoto na kulia) kama condition ni kweli ndio utafanya execution ya code inahusiana na condition hiyo ila kama vigezo havitakidhi hiyo code haitakuwa executed.</p> </li> <li> <p>Logical OR,inaanglia upande mmmoja tu inaweza ikawa upande wa kushoto au kulia basi kama upnade mmoja umekizi vigezo basi code yako husika itakuwa executed.</p> </li> <li> <p>Logical NOT,inakanusha statement katika C++ kama jibu ni kweli basi itabadili kuwa sikweli na kama ni kweli tabadili kuwa sikweli.</p> </li> </ul>"},{"location":"basics/decision-making/decision_making/#order-of-logical-operators","title":"Order Of Logical Operators","text":"<ul> <li>Kam ambavyo tulisoma mwanzoni kama kwenye mathematical expression huwa kunakuwa na operator precedence kwamba / na * zinapewa kipaumbele sana ukifananisha na - na + hii tunaita operator precedence katika C++ na pia hata lugha nyingine wanatumia jina hili hili,basi katika logical operators pia kuna operators precdence kwamba, precedence yao ipo kwenye mpangilio hhu <code>!</code> <code>&amp;&amp;</code> <code>||</code> (zmepangwa kwamba ya kwanza ina priority kubwa), ila uwepo wa mabano unaweza ukabdili operator precedence za hizo logical operators katika programing.Mfano</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    bool a = true;\n    bool b = false;\n\n    bool result = b &amp;&amp; !a;\n    cout &lt;&lt; boolalpha &lt;&lt; result;\n    // result: false\n    return 0;\n}\n</code></pre> <p>Kwenye expression yetu hapo juu itaanza kuwa evaluated upande wa kulia kwanza kwa sababu ya uwepo wa NOT operator kwa sababu ina high precedence ukifananisha na &amp;&amp;, hivyo a itakanushwa na kuwa false kisha itakuwa evaluated kama upande wa kushoto ni sawa na upande wa kulia ambapo kwenye program yetu upande wa kushoto na kulia kote n false hivyo expression yetu itakuwa evaluated kuwa false.</p> <pre><code>int x = 10;\nint y = 20;\n\nif(x &gt; y){\n    cout &lt;&lt; \"X ni kubwa kuliko y\";\n}\nelse{\n    cout &lt;&lt; \"Y ni kubwa kuliko X\";\n}\n</code></pre>"},{"location":"basics/decision-making/decision_making/#if-statement","title":"if Statement","text":"<ul> <li> <p>Tunatumia if statement ili kuweza kucontrol logic ya program yetu.</p> </li> <li> <p>If satement ni condition ya kwanza ambayo inatumika kuangalia kama statement ni kweli ndio itatoa majibu ya kitu kilichopo nadni ya block ya code yako ya <code>if statement</code></p> </li> <li> <p>Mfano tunatengeneza program yetu ya kuangalia kama mpiga kura amefikisha miaka 18 au bado na kama miaka yake ni chini ya miaka 18 tutamwambia kwamba hauruhusiwi kupiga kura.</p> </li> <li> <p>Hapo tutaanza kwanza kufanya declaration ya variable kwa ajili ya kuhifadhi miaka ya mtuamiaji kisha tutaumia if statement tutaanza na if keyword ikifuatiwa na mabano na ndani ya mabano ndio tunaweka vigezo vyetu(condition) kwa mtumiaji wetu baada ya hapo tutafuata na mabano singasinga {} ndani ya mabana yetu hayo ndio tutaandika code ya kuwa executed endapo kama mpiga kura amekizi hivyo vigezo.Kumbuka kama tuatumia comparison operator ili kuweza kuangalia kama thamani(value) ni kubwa au sawa na!</p> </li> </ul> <p>Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int miaka = 12;\n\n    if (miaka &lt; 18)\n    {\n        cout &lt;&lt; \"Hauruhusiwi kupiga kura\";\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>Katika mfano hapo juu mpiga kula wetu ana miaka chini ya 18 hivyo program yetu itamwambia kwamba haruhusiwi kupiga kura ila kama miaka yake ni zaidi ya 18 basi ataruhusiwa kupiga kula ila hakuna statement ambayo inahusiana na kama mpiga kura ana miaka zaidi ya 18 basi katika situation kama hii hapa ndio tunatumia else condition katika program yetu, fuatilia kipande cha chini.</li> </ul>"},{"location":"basics/decision-making/decision_making/#else-statement","title":"Else Statement","text":"<ul> <li>Endapo mpiga kura ana miaka 18 tunataka tumwambie kwamba unaruhusiwa kupiga kura basi program yetu itakuwa kama hivi.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int miaka = 20;\n\n    if (miaka &lt; 18)\n    {\n        cout &lt;&lt; \"Hauruhusiwi kupiga kura\";\n    }\n    else\n    {\n        cout &lt;&lt; \"Ruksa kupiga kura\";\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>Katika program hapo ju tumeangalia kwamba je mtumiaji wetu miaka yake ni ambayo ni 20 ni 20 je ni less than 18 hapana basi program kwenye upande wa if italukwa na kuenda kwenye upande wa ambao ni kweli na code yetu itakayo kuwa executed itakuwa <code>Ruksa kupiga kura</code>.</li> </ul>"},{"location":"basics/decision-making/decision_making/#if-else-statement","title":"if-else Statement","text":""},{"location":"basics/decision-making/decision_making/#nested-if-statements","title":"Nested if Statements","text":"<ul> <li>Nested if statement inatumika katika C++ pale ambapo unataka kuangalia multiple condition na kufanya action mbalimbali kutokana na condition.Au tunaweza tukasema kwamba ndani ya if condition kuna if conditions zingine,Mfano: Tunatengeneza program ndogo kuangalia kama mpiga kuna wetu ana miaka zaidi ya 18 au chini ya 18 ila sehemu ambayo mtumiaji wetu atatuambia kama yeye ni zaidi ya miaka 18 tutataka ndani ya hiyo if statement tuangalia kama ni mwanamke au mwanaume.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int umri;\n    char jinsia;\n\n    cout &lt;&lt; \"Ingiza umri wako: \";\n    cin &gt;&gt; umri;\n    cout &lt;&lt; \"Ingiza jinsia yako (M/F): \";\n    cin &gt;&gt; jinsia;\n\n    if (umri &gt;= 18) {\n        if (jinsia == 'M') {\n            cout &lt;&lt; \"Wewe ni mtu mzima mwanamume.\";\n        } else if (jinsia == 'F') {\n            cout &lt;&lt; \"Wewe ni mtu mzima mwanamke.\";\n        } else {\n            cout &lt;&lt; \"Uingizaji jinsia sio sahihi.\";\n        }\n    } else {\n        cout &lt;&lt; \"Bado hujawa mtu mzima.\";\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"basics/decision-making/decision_making/#conditional-operator","title":"Conditional Operator","text":"<ul> <li> <p>In C++, the ternary operator, also known as the conditional operator, is a special operator that takes three operands: a condition followed by a question mark (?), an expression to be evaluated if the condition is true, and a second expression to be evaluated if the condition is false, separated by a colon (:).</p> </li> <li> <p>Katika C++, conditional opeator ni swa na ternary operator, ni operator maalum ambayo inachukua vipengele vitatu(three operands): hali(condition) ikifuatiwa na alama ya swali (?), kielezo cha kutathminiwa ikiwa hali(condition) ni kweli, na kielezo cha pili cha kutathminiwa ikiwa hali(condition) ni uwongo, vimekatwa na mabano ya kufunga (:)</p> </li> </ul> <p>Syntaksia yake</p> <pre><code>condition ? expression_if_true : expression_if_false;\n</code></pre> <p>Namna inavyofanya kazi:</p> <p>Condition inakuwa evaluated kwanza . Kama condition ni kweli, basi expression kabla ya colon inakuwa evaluated na thamani(value) yake ndio inakuwa matokeo ya expression yote.</p> <ul> <li>Kama condition inakuwa sikweli, expression baada ya colon iankuwa evaluated na thamani(value) yake ndio inakuwa matokeo ya expression yote.</li> </ul> <p>Mfano 1:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 10;\n    int y = 20;\n\n    int max = (x &gt; y) ? x : y;\n\n    cout &lt;&lt; \"Thamani kubwa zaidi ni: \" &lt;&lt; max &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Mfano 2:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int age = 12;\n\n    string jibu = (age &lt; 18) ? \"Mkubwa\" : \"Mdogo\";\n    cout &lt;&lt; jibu;\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    int age = 20;\n\n    string result = (age &lt; 18) ? \"Not allowed to vote\" : \"Elligible\";\n    cout &lt;&lt; result;\n    return 0;\n}\n</code></pre> <p>Katika mfano huu, kama x ni kubwa kuliko y, basi sharti (x &gt; y) litakuwa kweli (true), na hivyo thamani ya x itakuwa thamani kubwa zaidi. Lakini, kama x si kubwa kuliko y, basi sharti litakuwa si kweli (false), na hivyo thamani ya y itakuwa thamani kubwa zaidi. Natumaini hii imeeleweka.</p>"},{"location":"basics/decision-making/decision_making/#increment-and-decrement-operator","title":"Increment And Decrement Operator","text":"<ul> <li>Increment operator in operator ambayo inaongeza thamani(value) ya variable kwa moja na decrement operator ni ile ambayo inapunguza thamani(value) ya variable kwa moja. Mfano wa increment operator thamani(value) ya miaka imeongezwa kwa moja.</li> </ul> <pre><code>    int miaka = 20;\n    miaka++;\n    cout &lt;&lt; miaka &lt;&lt; endl; // output: 21\n</code></pre> <p>Mfano wa decrement operator thamani(value) ya miaka impunguzwa kwa moja.</p> <pre><code>    int miaka = 20;\n    miaka--;\n    cout &lt;&lt; miaka &lt;&lt; endl; // output: 19\n</code></pre> <p>Increment operator ni operator kama zilivyo operator nyingine katika programming ila kuna utofauti wao kidogo, ni muhimu kujua kwamba kuna post increment yaani baada na kabla(prefix increment), kwenye post increment increment operator inakuwa baada ya kuandika program yako mfano <code>miaka++</code> ila kwenye upande wa prefix increment variable yako inaongezewa kabla ya kufanya operesheni yoyote ile kwenye program yako, Mfano: <code>++miaka</code>.</p> <ul> <li>Post increment, post increment inaweza kutumika katika kufanya mahesabu kwa sababu ni sawa na kama zilivyo operesheni nyingine katika C++ ila kuna utofauti na kutokuelewaka kuhusu matumizi ya post na pre-increment navyofanya operesheni zako katika programming.Mfano kuhusu post increment inavyofanya kazi katika programming wakati wa kufanya operesheni.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int miaka = 20;\n    int jibu = 2 * miaka++;\n    cout &lt;&lt; \"Jibu baada ya kufanya post increment: \" &lt;&lt; jibu &lt;&lt; endl; // 40\n    cout &lt;&lt; miaka; // 21\n    return 0;\n}\n</code></pre> <p>Kwa kupitia mfano hapo, post increment inachofanya baada ya jibu kuwa declared na kuwa assigned kwamba 2 kuzidisha na miaka++, katika C++ miaka++ imekuwa na post increment yaani thamani(value) ya miaka ambayo ni 20 imekuwa imeongezwa moja baada ya ila katika C++ inachukua thamani(value) ya variable yako kabla ya kufanya incremenation kwa sababu increment imekuja baada ya ++ sign yaani baada na pia ipo kwenye RHS(Upande wa kulia)right handside, hivyo program inakuwa sawa na kuandika hivi.</p> <pre><code>    int jibu = 2 * miaka;\n</code></pre> <p>na kwa upande wa miaka thamani(value) yake imekuwa 21 kwa sababu ya incremenetion inasound kama ni kitu cha ajabu ila ipo kama ilivyo ndio hivyo.Kumbuka hii ni increment na pia decrement ipo hivyo hivyo kwenye upande wa post increment na decrement katika C++.</p> <ul> <li>Ebu tuangalie je kwa upande wa prefix increment inafanya kazi vipi? Kwenye upande wa prefix increment thamani(value) ya variable yako inakuwa incremented kabla ya kufanya operesheni na pia kwenye decrement vivyo hivyo kwamba thamani(value) inakuwa decrement kabla ya kufanya operesheni.</li> </ul> <pre><code>    int miaka = 20;\n    int jibu = 2 * ++miaka;\n    cout &lt;&lt; \"Jibu baada ya kufanya pre increment: \" &lt;&lt; jibu &lt;&lt; endl; // 42\n    cout &lt;&lt; miaka;                                                    // 21\n</code></pre> <ul> <li>Kupitia mfano huu hapo juu kwamba thamani(value) ya variable yetu inakuwa incerement kabla ya kufanya opereseheni na kupelekea ++miaka kuwa 21 ambapo imekuwa evalauted kabla ya kuzidisha na mbili baada ya hapo inakuwa 2  kuzidishwa na 21 kwa sababu ya post increment. Mfano kwa upande wa prefix decrement.</li> </ul> <pre><code>    int miaka = 20;\n    int jibu = 2 * --miaka;\n    cout &lt;&lt; \"Jibu baada ya kufanya pre decrement: \" &lt;&lt; jibu &lt;&lt; endl; // 38\n    cout &lt;&lt; miaka;                                                   // 19\n</code></pre> <p>Kitu chochote unachofanya kwenye decrement operator unaweza ukafanya pia kwenye increment opeartor ila utofauti wao ni kwamba moja inaongeza thamani(value) ya variable kwa moja na nyingine inapunguza thamani(value) ya variable kwa 1.</p>"},{"location":"basics/decision-making/decision_making/#switch-statement","title":"Switch Statement","text":""},{"location":"basics/decision-making/decision_making/#common-mistakes","title":"Common Mistakes","text":"<ul> <li>Kutumia assignment operator kufanya comparison za thamani(value)s katika program yako. Mfano:</li> </ul> <pre><code>int x = 10;\nint y = 20;\n\n// check if the satement is tru or false in our program\nif(x = y){\n    cout &lt;&lt; \"They are equal\";\n}\n</code></pre> <p>Kwa hiyo instead ya kutumia assignemnt oprator kufanya comparion ya thamani(value)s tumia comparison operator.</p> <p>\u2b06\ufe0f Return to Top</p>"},{"location":"basics/functions/functions/","title":"Functions","text":"<ul> <li>Introduction</li> <li>Function Declaration</li> <li>Function Types</li> <li>Function Definition</li> <li>Function Call</li> <li>Function Parameters</li> <li>Default Parameters</li> <li>Multiple Parameters</li> <li>Function Arguments</li> <li>Pass By Value Vs Pass By Reference</li> <li>Local And Global Variables</li> <li>Declaring Functions</li> <li>Organizing Functions In Files</li> <li>Return Values</li> <li>Function Overloading</li> <li>Inline Functions</li> <li>Recursive Functions</li> <li>Function Pointers</li> <li>Lambda Expressions</li> <li>Errors</li> <li>Best Practices for Functions</li> </ul>"},{"location":"basics/functions/functions/#introduction","title":"Introduction","text":"<ul> <li>Functions zinakuwezesha kuweza kugawanyisha programu yako(code zako) katika vipande amabvyo ni rahisi kumaintain na kuwezesha code zako kuwa readable maintainable na hata kuwa reusable yaani zinaktumika tena katika programu zingine.</li> </ul>"},{"location":"basics/functions/functions/#function-declaration","title":"Function Declaration","text":"<ul> <li>Function declaration: Inaspecify jina la function yako, return type, parameters kama zitakuepo kutokana na uwepo wa function inatoa taarifa kwa compiler yako kwanza kuna function na kuna aina nyingi za function katika <code>C++</code>, Ili kuweza kutengeneza function yako utaanza na return type kisha ikifuatiwa na jina la function yako kisha mabano na ndani ya mabano yako kutakuwa na paremeters baaada ya hapo itafuatiwa na mabano singasinga na nadni ya mabano hayo ndio function body kwamba vitu vyote ambavyo unataka function yako ifanye ndio vitakuwa ndani ya function yako hiyo.</li> </ul>"},{"location":"basics/functions/functions/#function-types","title":"Function Types","text":"<ul> <li> <p>Hi ni moja kati ya section muhimu sana katika <code>C++</code> ila bado kuwa machanhanyiko mkubwa sana hapa ni muhimu kujua je kuna ian ngapi za function katika program yako na kwa namna gani zinafanya kazi</p> </li> <li> <p>Void functions: Ni function ambazo hazi rudishi thamani(value).Zinatumika kuandika program ambazo hazirudishi jibu(result), au tunaweza tukasema ni function ambazo return type yake ni void yaani tupu hairudishi kitu chochote. Mfano</p> </li> </ul> <pre><code>void greet() {\n    std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;\n}\n</code></pre> <p>2.Functions with Parameters:Ni aina za function ambazo zinachukua parameters ambazo zitatumika kufanya kazi(operation) ndani ya program yako. Mfano: Tunaweza tukawa na function yetu inaitwa kujumlisha ambayo inachukua parameters mbili ambazo ni namba ya kwaza(a) na namba ya mbili(b). Kama function sio void ina maana kwamba itarudisha value fulani kwenye program yako hivyo unaweza ukawa na function ambayo inarudisha data type fulani mfano wake ni return type int, return type float , return type bool na hata pia double.</p> <pre><code>int jumlisha(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>3.Functions with Return Value:: Function zenye return value, ni aina ya function ambzo zinarudisha jibu katika program yako baada ya kufanya kazi fulani ya programu yako. Mfano</p> <pre><code>int square(int num) {\n    return num * num;\n}\n</code></pre> <p>4.Recursive Functions:: Ni aina za function ambazo znajiita zenyewe either katika directly way au indirectly way Mfano:</p> <pre><code>int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n</code></pre>"},{"location":"basics/functions/functions/#function-definition","title":"Function Definition","text":"<ul> <li>Function definition(ufafanuzi wa kazi.): Inacontain namna jinsi ya kufanya function na function body ina nini ndani yake na inafanyaje kazi,ambapo kuna statements ndani yake na hizo statement zipo ndani ya curly braces {}</li> </ul> <pre><code>#include &lt;iostream&gt;\n\n// Function declaration\nint addNumbers(int a, int b);\n\nint main() {\n    // Input numbers\n    int num1, num2;\n    std::cout &lt;&lt; \"Enter the first number: \";\n    std::cin &gt;&gt; num1;\n    std::cout &lt;&lt; \"Enter the second number: \";\n    std::cin &gt;&gt; num2;\n\n    // Function call\n    int sum = addNumbers(num1, num2);\n\n    // Display the result\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    return 0;\n}\n\n// Function definition\nint addNumbers(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"basics/functions/functions/#function-call","title":"Function Call","text":"<ul> <li>Function call: Ili uweze kurun function, unahitaji kuita(call) kwa kutumia jina la function yako ikifiuatiwa na mabano (). Kma function itakuwa na parameters , unawezka na arguments (actual values) ndani ya mabano(parantheses).</li> </ul> <pre><code>// sintaksia\nfunction_name(argument1, argument2, ..., argumentN);\n</code></pre> <p>argument ni vitu ambavyo function yako inachukua inaweza ikawa ni int au string ila kumbuka kuangalia return type ya jina la function yako ni ipi ila kama funciton yako haina argument yoyote unaweza kuacha empty. Mfano wa function ambayo inatumika kufanya jumlisha(addition)</p> <pre><code>#include &lt;iostream&gt;\nint add(int x, int y) {\n    return x + y;\n}\n// ili kuweza kuita function yako utaanza na jina la function ikifuatiwa na arguments ambazo zinahitajika katika function yako\nint main(){\n    int a = 5, b = 7;\n    int sum = add(a, b);\n    return 0;\n}\n</code></pre> <p>Hapa a na b ni integer mbili ambazo zinakuwa (zinapitishwa) passed kama argument kwenye function yetu ya <code>add</code> na function hiyo ndio inarudisha jibu la a na b ambalo linakuwa limehifadhiwa(stored) ndani ya sum variable. Kumbuka kwamba aina na idadi ya arguments ambazo function zinachukua ianbidi ziwe sawa number za argument ambazo zinapitishwa mda wa kuitwa function, kinyume na hapo italeta <code>error</code></p>"},{"location":"basics/functions/functions/#function-parameters","title":"Function Parameters","text":"<ul> <li>Information can be passed to functions as a parameter. Parameters act as variables inside the function.</li> <li>Taarifa amabzo zinaweza kuwa ppased kwenye function kama parameter.Paremeter zina act kama variables ndani ya function.</li> <li>Parameters zinakuwa specified baada ya function name ndani ya parenthesis.Unaweza ukaweka parametres nyingi uanzotaka kwenye function yako anaweza add kiasi cha function parameters ambazo unataka kwenye program yako.   sintaksia</li> </ul> <pre><code>void functionName(parameter1, parameter2, parameter3) {\n  // code to be executed\n}\n</code></pre>"},{"location":"basics/functions/functions/#default-parameters","title":"Default Parameters","text":"<ul> <li>Unaweza pia ukawa na function ambayo ina deafult parameter,parameter yenye default value tunatumia equal sign = Mfano hapo chini kuanfunction yenye default parametesr tukianza na message variable ambayo ni string default value yake ni <code>\"Hello\"</code> na <code>repeatCount</code> yake ni 1 by default.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\n// Function with default parameters\nvoid printMessage(string message = \"Hello, World!\", int repeatCount = 1) {\n    for (int i = 0; i &lt; repeatCount; ++i) {\n        cout &lt;&lt; message &lt;&lt; endl;\n    }\n}\n\nint main() {\n    // Calling the function without providing parameters (default values will be used)\n    printMessage(); // Output: Hello, World!\n\n    // Calling the function with custom values\n    printMessage(\"Custom Message\", 3);\n    // Output:\n    // Custom Message\n    // Custom Message\n    // Custom Message\n\n    return 0;\n}\n</code></pre> <p>Kumbuka kwamba pale ambapo function yako itakuwa na default parameters unaweza call function yako pila klupassaargument zako ila ukicall function yako na kupass arguments nyingine zile deafult arguments zitakuwa overwritten aktika program yako.</p>"},{"location":"basics/functions/functions/#multiple-parameters","title":"Multiple Parameters","text":"<ul> <li>Ndani ya functin unaweza uakaweka function nyingi kiasi ambacho wewe unataka katika program yako   NOTE Idadi ya parameters ianbidi iwe sawa na idadi ya aguments ambazo zimekuwa passed kwenye function na pia ziwe katiaka order.</li> </ul>"},{"location":"basics/functions/functions/#function-arguments","title":"Function Arguments","text":"<ul> <li>Katika C++, function arguiments ni values au variables ambazo znakuwa passed kwenye function pale unavyoitwa (call).Hizi arguments zinatoa input kwenda kwenye function, kuwezesha function kufanya computation za operesheni zake kutokana va values.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\n// Function declaration with parameters (arguments)\nvoid printSum(int a, int b);\n\nint main() {\n    int x = 5, y = 7;\n\n    // Function call with arguments\n    printSum(x, y);\n\n    return 0;\n}\n\n// Function definition with parameters (arguments)\nvoid printSum(int a, int b) {\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; a + b &lt;&lt; std::endl;\n}\n</code></pre> <ul> <li>Katika mfano huu , function ya printSum inachukua integer parameters ambazo ni mbili (int a na int b).Pale ambapo function iatitwa katika main fucntion ikiwa na arguments za x na y, itatoa jibu la sum ya value mbili.</li> </ul>"},{"location":"basics/functions/functions/#local-and-global-variables","title":"Local And Global Variables","text":"<p>Local Variable</p> <ul> <li>Pale ambapo unafanya declaration ya variable yotyote kwenye program yako inaweza ikawa local kama unaweza kupata access ndani ya hiyo variable tu ambayo ipo.Mfano:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int number = 100;\n    return 0;\n}\n</code></pre> <p>Kupitia mfano hapo juu unaweza ukapata acess ya integer number kwenye scope tu ambayo integer yako ipo na hiyo variable ikiwa ni loca; variables eneo ambalo variable yako ipo kwenye program yako ndio tunaita <code>local scope</code>.Integer number ipo kwenye main function tu nje ya hapo haitapata value yako,Mfano tunataka kuapata value ya number nje ya main function:</p> <pre><code>## Global Variable\n</code></pre> <ul> <li>Global variable ni ile variable yako ambayo unaweza pata access yake ukiwa sehemu yoyote kwenye program yako pia ni variable ambayo inakuwa declared nje ya function yoyote au class.Global variables zina global scope, maana kwamba unaweza pata access ya ukiwa sehemu yoyote ya program yako,pamoja na siurce files kama zinakuwa declared.</li> </ul> <p>Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Global variable declaration\nint globalVar = 10;\n\nint main() {\n    // Accessing globalVar inside the main function\n    cout &lt;&lt; \"Value of globalVar inside main: \" &lt;&lt; globalVar &lt;&lt; endl;\n\n    // Modifying globalVar\n    globalVar = 20;\n\n    // Accessing globalVar after modification\n    cout &lt;&lt; \"Value of globalVar after modification: \" &lt;&lt; globalVar &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Katika mfano huu, <code>globalVar</code> imekuwa declared nje ya function yoyote,ambacho imefanya imekuwa global variable.Inaweza kuwa accessed na kuwa modfied pia ndani tya main function bila tatizo lolote.</p>"},{"location":"basics/functions/functions/#declaring-functions","title":"Declaring Functions","text":"<ul> <li>Declaring function i moja kati ya case nzuri sana inayotmika kwenye upande wa local and global variables,Mfano Vipi endapo tutafanya declaration ya function yetu baada ya main function:</li> </ul> <pre><code>// working with functions\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    greetUser();\n    return 0;\n}\n\nvoid greetUser()\n{\n    cout &lt;&lt; \"Welcome\";\n}\n</code></pre> <p>Output tunayopata ni hii</p> <pre><code>error: 'greetUser' was not declared in this scope\n    9 |     greetUser();\n      |     ^~~~~~~~~\n</code></pre> <p>Tumepata compilation function kwamba function yetu haipo visible kwa main function kwa hiyo solution yake ni kwamba always fanya declaration ya function kabla ya main function.Solution zipo mbili ya kwanza ni kufanya declaration ya <code>greetUser()</code> function kabla ya main function na kutokana na hii ni sawa na kuambia compiler kwamba kuna function fulani ipo katika program yangu ila declaratio yake ipo hapa juu,Mfano:</p> <pre><code>// working with functions\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// declare your function,make sure to terminate\n// function declaration(function prototype)\nvoid greetUser();\n\nint main()\n{\n    greetUser();\n    return 0;\n}\n\n// function definition\nvoid greetUser()\n{\n    cout &lt;&lt; \"Welcome\";\n}\n</code></pre> <p>Solution ya pili unafanya normal declaration ya function kwamba function yako yote inakuwa ndani nje ya main function.</p> <pre><code>// working with functions\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid greetUser()\n{\n    cout &lt;&lt; \"Welcome\";\n}\n\nint main()\n{\n    greetUser();\n    return 0;\n}\n</code></pre> <p>Function declaration ni sawa na function prototype.</p>"},{"location":"basics/functions/functions/#organizing-functions-in-files","title":"Organizing Functions In Files","text":"<ul> <li> <p>Jinsi project yako inazidi kuwa kubwa inabidi uweze kufanya organization ya projects zako katika files kwa ajili ya function zako, pia ni namna ya kufwata good practices na clean code procedures.</p> </li> <li> <p>Project inavyokuwa code inakuwa na line of code nyingi hivyo ili uweze kupangilia project zako ziweze kukaa vizuri tutatumia files,kwamba functions nyingi katika project yako zinakuwa katika files.Kwanini Files?</p> <ol> <li>Files zinakuwa ndogo na rahisi kuweza kufanya mabadiliko.</li> <li>Reusability.Kama tuna function fulani katika file jingine hivyo tnaweza kutumia tena hilo file kwenye project nyingine.Kutokana na uwezo wa kutenganisha file kuwa na header file na source file(implentation file),header files zinasaidia code resusability.Unaweza ukawa na zaidi ya moja header file kutumia declaration.</li> </ol> </li> </ul> <p>Ili kuweza kufanya organization ya file zako, create folder na ndani ya hilo folder tengeneza files mbili moja kwa ajili ya header files (function declaration) na file lingine kwa ajili ya implementation(implementation file) ndani ya implementation file kunakuwa na function definition.Jina la folder lako hakikisha nalipa descriptive name, <code>utility</code></p> <pre><code>mkdir utils\n\n\ntouch greet.cpp\n</code></pre> <p>Kumbuka kwa <code>greet.cpp</code> ni file kwa ajili ya actual implementation ya function yako yaani function definition, katika <code>main.cpp</code> kulikuwa na ile function definition hivyo nenda cut ile function kisha ilete kwenye <code>greet.cpp</code>.</p> <pre><code>void greetUser()\n{\n    cout &lt;&lt; \"Welcome\";\n}\n</code></pre> <p>Hakikisha unaweka header files <code>#include &lt;iostream&gt;</code> na pia usisahau <code>using namespace std;</code></p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid greetUser()\n{\n    cout &lt;&lt; \"Welcome\";\n}\n</code></pre> <p>Tengeneza header file kwa ajili ya function declaration, hili file huwa linakuwa na extension ya <code>.hpp</code> au <code>.h</code></p> <pre><code>touch greet.hpp\n</code></pre> <p>Baada ya file kuwa created strcture yako ya folder la utils inabidi liwe hivi </p> <p>Kwenye file la greet.hpp ndio tunaweka function declaration.</p> <pre><code>void greetUser();\n</code></pre> <p>Baada ya hapo inabidi file lako la function declaration liwe included ndani ya main.cpp file hivyo,tumia #include directive ila kwasababu tuna target header file ambalo lipo kwenye project yetu tutatumia \" \" double quotes kufanya reference ya file ambalo lipo kwenye hii project</p> <pre><code>#include &lt;iostream&gt;\n#include \"utils/greet.hpp\"\n\nusing namespace std;\n\nint main()\n{\n    greetUser();\n    return 0;\n}\n</code></pre> <p>Kwenye file letu lipo vizuri ila kuna tatizo kidogo endapo tukitumia header file katika sehemu mbalimbali tutapata built problems,hivyo kuapata solution ya hilo tatizo inabidi baadhi ya header files ziwe include kwenye header file.Kwa kutumia ifndef(if not defined) kupitia ifndef tunadefine new library ambayo ni UTILS na ndani ya hiyo utils tunatengeneza constant inaitwa greet.</p> <pre><code>#ifndef UTILS_GREET\n</code></pre> <p>Baada ya hapo kama folder halijawa defined inabidi tufanye definition kwa kutumia preprocessor keyword ambayo ni define na hapao tunadefine library inaitwa utils ikiwa na constants inaitwa greet.</p> <pre><code>#define UTILS_GREET\n</code></pre> <p>Mwishoni mwa file letu tutaweka directive ambayo inaashilia kwamba file ndio mwisho.</p> <pre><code>#endif\n</code></pre> <p>Kijumla file letu inabidi liwe hivi.</p> <pre><code>#ifndef UTILS_GREET\n#define UTILS_GREET\n\nvoid greetUser();\n\n#endif\n</code></pre> <p>Najua umewahi kuona <code>#indef</code>, <code>#define</code> na <code>#endif</code> lines,Hizo line zinaitwa <code>header guards</code> au <code>include guards</code>. Zinazuia file ambazo zina same header file ili zisiweze kuwa included mara nyingi katika same translation unit,ambapo inaweza kupelekea errors.</p>"},{"location":"basics/functions/functions/#return-values","title":"Return Values","text":""},{"location":"basics/functions/functions/#function-overloading","title":"Function Overloading","text":""},{"location":"basics/functions/functions/#inline-functions","title":"Inline Functions","text":""},{"location":"basics/functions/functions/#recursive-functions","title":"Recursive Functions","text":""},{"location":"basics/functions/functions/#function-pointers","title":"Function Pointers","text":""},{"location":"basics/functions/functions/#lambda-expressions","title":"Lambda Expressions","text":""},{"location":"basics/functions/functions/#best-practices-for-functions","title":"Best Practices for Functions","text":""},{"location":"basics/functions/functions/#pass-by-value-vs-pass-by-reference","title":"Pass By Value Vs Pass By Reference","text":""},{"location":"basics/functions/functions/#errors","title":"Errors","text":"<ol> <li>Missing or Incorrect Function Prototypes:</li> </ol> <p>Not declaring or providing incorrect function prototypes before using a function in the code can lead to compilation errors. Make sure to declare functions before calling them, or use header files to provide prototypes.</p> <pre><code>// Missing function prototype\nint addNumbers(int a, int b);\n\nint main() {\n    int result = addNumbers(3, 4);\n    return 0;\n}\n\nint addNumbers(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>2.Not Returning Values:</p> <ul> <li>For functions with a non-void return type, forgetting to return a value or not returning the correct type of value can result in unexpected behavior.</li> </ul> <pre><code>int addNumbers(int a, int b) {\n    // Missing return statement\n    // return a + b;\n}\n</code></pre> <p>3.Ignoring Function Parameters:</p> <ul> <li>Ignoring or misusing function parameters can lead to logical errors in the program.</li> </ul> <pre><code>int addNumbers(int a, int b) {\n    // Using the wrong parameter\n    return a + 5;\n}\n</code></pre> <p>\u2b06\ufe0f Return to Top</p>"},{"location":"basics/hello_world/hello_world/","title":"Hello World","text":"<ul> <li>Introduction to C++</li> <li>IDEs</li> <li>First C++ Program</li> <li>Compiling and Running C Program</li> <li>Introduction to Format Specifiers</li> <li>Basic I/O Using Format Specifiers</li> <li>Integer Format Specifiers</li> <li>Floating-Point Format Specifiers</li> <li>Character and String Format Specifiers</li> <li>Width and Precision Specifiers</li> <li>Manipulators</li> <li>User-Defined Types</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"basics/hello_world/hello_world/#introduction","title":"Introduction","text":"<p>Karibu katika ulimwengu wa C++, kufanya safari yako ya coding kuwa laini na nyepesi, ngoja tuangalie baadhi ya IDE zinatumika kwa ajili ya C++, kuna IDE za free za pia kuna IDE za bure hivyo nimuhimu kuchagua IDE inayo endana na uwezo wako.</p>"},{"location":"basics/hello_world/hello_world/#1-visual-studio-code","title":"1. Visual Studio Code","text":"<p>Visual Studio Code ni mazingira nyepesi, huru, yenye nguvu kwa ajili ya kuandika namna ya C++. Inatoa anuwai ya nyongeza kwa ajili ya utendaji ulioimarishwa, ikifanya iwe chaguo la kubadilika kwa wabunifu wa C++.</p> <p>Usakinishaji(Download):</p> <ol> <li>Sakinisha Visual Studio Code kutoka hapa.</li> <li>Sakinisha nyongeza ya C/C++ kutoka kwenye mtazamo wa Nyongeza (<code>Ctrl + Shift + X</code>).</li> </ol>"},{"location":"basics/hello_world/hello_world/#2-codeblocks","title":"2. Code::Blocks","text":"<p>Code::Blocks ni IDE huru na huru yenye kiolesura cha mtumiaji kirafiki. Inasaidia makompaila mengi na inatoa mazingira yanayoweza kubadilishwa kwa ajili ya maendeleo.</p> <p>Usakinishaji(Download):</p> <ol> <li>Pakua na sakinisha Code::Blocks kutoka hapa.</li> <li>Fuata maagizo ya usakinishaji yaliyotolewa kwenye tovuti.</li> </ol>"},{"location":"basics/hello_world/hello_world/#3-clion","title":"3. CLion","text":"<p>CLion kutoka kwa JetBrains ni IDE yenye nguvu iliyoundwa kwa ajili ya maendeleo ya C++. Inatoa kukamilisha kiotomatiki, urambazaji, na zana zilizojengwa kwa ajili ya majaribio na ufuatiliaji.</p> <p>Usakinishaji(Download):</p> <ol> <li>Pakua na sakinisha CLion kutoka hapa.</li> <li>Fuata maagizo ya usakinishaji kulingana na mfumo wako wa uendeshaji.</li> </ol>"},{"location":"basics/hello_world/hello_world/#4-eclipse-ide-kwa-cc","title":"4. Eclipse IDE kwa C/C++","text":"<p>Eclipse IDE ni jukwaa linalotumiwa sana lenye toleo maalum kwa ajili ya maendeleo ya C/C++. Inatoa seti tajiri ya vipengele na inasaidia nyongeza mbalimbali kwa ajili ya utendaji wa ziada.</p> <p>Usakinishaji:</p> <ol> <li>Pakua na sakinisha Eclipse IDE kwa C/C++ kutoka hapa.</li> <li>Fuata maagizo ya usakinishaji kulingana na mfumo wako wa uendeshaji.</li> </ol>"},{"location":"basics/hello_world/hello_world/#basic-c","title":"Basic C++","text":"<ul> <li> <p>Katika program yetu entry point ya program yet ni katika <code>int main()</code> ili uweze kufanya operation ya program yetu katika C++ main ni jina la function na hiyo function inabidi iwe na uwezo wa kurus=disha kitu mabayo ndio tunaita return type hivyo return type yetu inabidi iwe ni <code>int</code> yaani integer hivyo ni mubhimu kuzingation hicho na endpo utaacha hicho utapata error katika program yako, na pia kti kingine muhimu kuzinagtia ni namna main ilivyo main function inabidi iwe katika lowercase characters endapo hizo zitakuwa katika uppercase inaleta error ya sintaksia pia kwa sababu katika ugha yetu pendwa ya C++ ni case sensitive kwamba ukandika <code>Main</code> hivi na <code>main</code> ni vitu viwili tofauti kabisa katika program yetu.</p> </li> <li> <p>Kama umetoka katika upande wa lugha ya C bsi hata itakuwa rahisi zaidi na pia hata kama unaanza bado unauweezo wa kufahamu lugha hii vziuri zadii, hivyo kwenye return type ambayo kwetu ni int, Kwanini return type? return type inatupa majibu kwamba program yetu ni successully yaani imefanikiwa au hapan saa kwenye upande wa C+=, return type huwa ni mbili tu, program inaweza uka return 1 au ika return 0, Je 1 na sifuri zinamaanisha nini? <code>return type o</code> hii inmaanisha kwamba program yetu imefanikiwa kurun na kuwa successfully ila kama return type ni 1 <code>return type 1</code> inmaanisha kwamba program yetu imeleta error yaaani sio sucessfully.Anaglia mfano hapo chini kwenye program yangu baada ta kurn imereturn 0, kwamba program ni imefanikiwa.</p> </li> <li> <p>Baada ya kunadika function yako inafuata nafasi kidogo kisha mabano na ndani ya mabano ndio kunakuwa na parameters kwa sasa hatutazungumzia sana kuhusu parameter hadi tutakapo fika sehemu ya function ila baada ya brackets inafuata nafasi kidgo na curl braces yaani mabanio singa singa, ndani ya mabano yetu program yetu yote ndio itakuwa inaandikwa hapo.</p> </li> </ul> <pre><code>int main()\n{\n\n}\n</code></pre> <ul> <li>Baada ya hapo kun stndard library mabyo ni muhimu katika progrma yetu mabyo ni <code>#include &lt;iostream&gt;</code> inakuwa juu kabisa ya program yetu.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\n\nint main()\n{\n    return 0;\n}\n</code></pre> <ul> <li>iostream inatuwezesha kupata input kutoka kwa mtumiaji na pia kuweza kupata output kwenda kwenye screeen.Ili kuweza kupata fetures zote zilizopo ndani ya <code>iostream</code> library ndani ya main fnction yetu tutaanza na std ikimaanisha standard library bila kuwepo kwa iostream hatutaweza kuapat fnctionality zilizopo ndani iostream, kuapta functionality hizo tuatumia std ikifuatiwa na <code>scope resolution operator</code> au tunaweza tukatumia double colons kwenye std kwa hapa tutaumia character out yaani cout ili kuweza kupata output kwenye screen kama mabvyo tunaweza tunakutumia printf katika C basi hapa tunatumia cout. baada ya kuandika cout itafuatiw na nafsi kidogo then left angled brackets au watu wengine huw wanasema ni append sing kisha caha nafasi baada ya hapo double quotes na ndani ya hzio quotes ndio kutakuw ana text amnabypo unataka iwe printed kwenye screen \"Sema Dunia\" usisahau kufanya termination ya line yako kwa kutumia semi colon katika program yako.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"Sema Dunia\";\n    return 0;\n}\n</code></pre> <p></p> <p></p> <ul> <li>Katika code yetu kuna vitu vingi sana na ni muhimu kuzingatia katika program yetu <code>return 0</code> kutokana na uwepo wa return 0 hi ndio end point yetu ya program yetu nimuhimu kuweka return 0 pale ambapo program yako ndio inaishia na pia baadhi ya baadhi ya code editors usipoweka return keyword inakachokifanya kuangalia code yako line by line hadi ambako itafika kutakuwa hakuna statement yoyote ndio itaishia hapo,ila baadhi ya compilers zina insist hiyo line iwe included katika program yako,hivyo ni muhimu kuahikisha inakua included katika programu yako, hii statement <code>return 0</code> inaitwa <code>return statement</code> ambayo inatoa majibu kwa computer yako kwa iishie kwenye hiyo line yako, pia ni muhimu kuongeza na closing braces ( {} ) maana hapo ndio mwisho wa programu yako.</li> </ul>"},{"location":"basics/hello_world/hello_world/#compiling-and-running-c-program","title":"Compiling and Running C Program","text":"<ul> <li>Unaandika program zako(code) za language fulani in the same way ambayo unaweza ukaandika maandishi kwenye kitabu au daftari,Pale ambapo unaipa program yako command ya kubadili code zako ambazo ni high level language(language ambazo ni human readable) kwenda low level language languages wich are undestndable by the nmachines (0s 1s)</li> <li> <p>Kitendo cha kurn program yako i;li uweze kupata majibu au output ndani yake huwa na complilation,kama tunavyojua kwamba computer haielewi code tunazonadika ila inacchofanya inc convert kutoka human readable format in the machine format which are 0s and 1s(binary number) na ndipo utapata output yako,kuna msemo unasema garbage in, garbage outkwamba kama umekosea utapata kile ambacho sicho kwa sababu computer haifahamu kitu ulichoandika katika programu yako.</p> </li> <li> <p>Ili ntuweze kurun code yetu kwanza code yetu inabidi iwe compiled kwenda kwenye machine code, na hivi vyote vinafanywa na compiler, machine code ni ile language au lugha ambayo machine inatumia ili iweze kufanya opereshenni mabmbali za program, machine code za C++ ambazo zinakuwa compiled katika window ni tofauti na machinbe code za MacOs hivyo ili kuweza kurun machine code za MacOs ambazi zilikuwa katika Windows inabidi urun a=code zako kwanza yaani ziwe compiled kwa mara ya pili kwenye operating tofauti na ile ya mara ya kwanza.</p> </li> </ul>"},{"location":"basics/hello_world/hello_world/#introduction-to-format-specifiers","title":"Introduction to Format Specifiers","text":""},{"location":"basics/hello_world/hello_world/#basic-io-using-format-specifiers","title":"Basic I/O Using Format Specifiers","text":""},{"location":"basics/hello_world/hello_world/#integer-format-specifiers","title":"Integer Format Specifiers","text":""},{"location":"basics/hello_world/hello_world/#floating-point-format-specifiers","title":"Floating-Point Format Specifiers","text":""},{"location":"basics/hello_world/hello_world/#character-and-string-format-specifiers","title":"Character and String Format Specifiers","text":""},{"location":"basics/hello_world/hello_world/#width-and-precision-specifiers","title":"Width and Precision Specifiers","text":"<ul> <li>Unaweza pia uka specify width na precision wakati unaprint namba kwenye program yako.</li> <li><code>setw(n)</code>: setwidth inachukau parameter moja, ambayo ni dadi ya chracters ambazo unataka kuchukua au kuacha pale ambapo value yako unataka iwe printed kwenye output,inaresolve idadi ya data ambazo zinakuja baada!</li> </ul>"},{"location":"basics/hello_world/hello_world/#manipulators","title":"Manipulators","text":""},{"location":"basics/hello_world/hello_world/#user-defined-types","title":"User-Defined Types","text":""},{"location":"basics/hello_world/hello_world/#best-practices","title":"Best Practices","text":""},{"location":"basics/hello_world/hello_world/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"basics/input_handling/input_handling/","title":"Input Handling","text":"<ul> <li>Error handling</li> <li>Advanced input handling techniques</li> <li>Input validation</li> <li>Command-line arguments</li> </ul>"},{"location":"basics/input_handling/input_handling/#error-handling","title":"Error handling","text":"<ul> <li> <p>Hakikisha umejua namna cin, cout zinavyofanya kazi katika program yako kabla ya kusoma sehemu hii.</p> </li> <li> <p>Ili kuweza kuhandle errors kwenye program yako ni muhimu kuzanagtia je ni aina gani ya data ambayo mtumijai wa program yako anaingiza inaweza ikawa ni integer au string,Kama ni integer kuna namna kwa ajili ya kufanya hadnling ya user input kwenye program yako na moja kati ya njia zinazoweza kutumika katika program yako kwa ajili ya kufanya handling ya user input(integer) ni zifuatazo:</p> <ol> <li><code>cin.fail()</code></li> </ol> </li> <li> <p>Tuanze na mfano kwanza, chukulia program hapo chini.</p> </li> </ul> <pre><code>    cout &lt;&lt; \"Miaka: \";\n    int miaka;\n    cin &gt;&gt; miaka;\n    cout &lt;&lt; \"Miaka yako ni: \" &lt;&lt; miaka &lt;&lt; endl;\n</code></pre> <ul> <li>Kutoka kwenye mfano hapo juu kwamba tunauliza miaka ya mtumijai wa program na baada ya kuuliza hapo tunatoa jibu kwenye terminal,vipi kama mtumiaji wetu ataingiza herufi badala ya namba, pia vipi kama mtumiaji ataingiza miaka ambayo ni negative, sasa sehemu kama hizi ndio sehemu za kufikiria namna ya kufanya hadling.Moja kati ya njia inayotumika kufanya handling kwenye program yako ni kwa kutumia <code>cin.fail()</code> tuaangalia kwamba kama kuna uncertainities kwenye program yetu tunacapture kwa kutumia cin.fail() ndani ya if statment, inachofanya cin.fail inaangalia kama kuna error kwenye program yako kama ni kweli basi statement ndani ya if statement ndio itakuwa executed kwa kutoa warning kwa user.</li> </ul> <pre><code>    cout &lt;&lt; \"Miaka: \";\n    int miaka;\n    cin &gt;&gt; miaka;\n    if (cin.fail())\n    {\n        cout &lt;&lt; \"Miaka sio sahihi!\" &lt;&lt; endl;\n    }\n\n    else\n    {\n        cout &lt;&lt; \"Miaka yako ni: \" &lt;&lt; miaka &lt;&lt; endl;\n    }\n</code></pre> <p>2.<code>cin.ignore()</code></p> <ul> <li>Kila strem inakuwa na buffer(temporary storage) katika memory kwa ajili ya ksuoma values zako. Pale ambapo user anajaza value inaenda kwenye buffer hadi ambapo utaona whitespace au newline (\\n) ndio value iliyoingizwa inahifadhiwa ila kama kutakuwa na newline au whitespace basi value ya pii itakuwa captured pia sasa buffer inachukua value mbili tu kwa muda mmoja,Mfano:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int number1;\n    int number2;\n\n    cout &lt;&lt; \"Namba ya kwanza: \";\n    cin &gt;&gt; number1;\n    cout &lt;&lt; \"Namba ya pili: \";\n    cin &gt;&gt; number2;\n\n    cout &lt;&lt; \"Namba ya kwanza \" &lt;&lt; number1 &lt;&lt; \" , \" &lt;&lt; \"Namba ya pili \"&lt;&lt; number2 &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Ukiingiza namba ya kwanza then ukaacha nafasi ukaingiza namba ya pili kwenye program yako,sasa kwa mfano namba ya kwanza uliyoingiza ni 3 bila kupress enters ukaacha nafsi ukajaza 12 sasa kinachotokea kwenye buffer ni kwamba itasoma namba ya kwanza ambayo ni 3 ila ndani ya buffer huwa znakaa value mbili tu na namba ya kwanza ni 3 na baada ya kuwa na whitespace namba ya pili ni 12 hivyo buffer inakuwa imejaa tayri hiyo kutakuwa hakuna nafasi ya kuweza kujaza namba nyingine ambayo inabidi ihifahiwe kwenye variable yako number2 hivyo, kwa kutumia <code>cin.ignore()</code> tunatumia kwa ajili ya kufanya clear ya buffer na inachukua parameters mbili parameter ya kwanza ni streamszie(idadi ya charcaters ambazo unataka ziwe ignored) na parameter ya pili ni delimeter (whitespace au newline).Ili uweze kupata access ya cin.ignore lazima kuwepo na access ya header file lake <code>#include &lt;limits&gt;</code>, cin.ignore inakuwa baada ya kuweza kuallow kupata namba ya kwanza ndio buffer inakuwa cleared.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nusing namespace std;\n\nint main()\n{\n    int number1;\n    int number2;\n\n    cout &lt;&lt; \"Namba ya kwanza: \";\n    cin &gt;&gt; number1;\n    cin.ignore(numeric_limits&lt;int&gt;::max(), '\\n'); // clear buffer\n    cout &lt;&lt; \"Namba ya pili: \";\n    cin &gt;&gt; number2;\n\n    cout &lt;&lt; \"Namba ya kwanza \" &lt;&lt; number1 &lt;&lt; \" , \"\n         &lt;&lt; \"Namba ya pili \" &lt;&lt; number2 &lt;&lt; endl;\n    return 0;\n}\n/* Output:\nNamba ya kwanza: 12 13\nNamba ya pili: 12\nNamba ya kwanza 12 , Namba ya pili 12\n*/\n</code></pre> <p>3.<code>cin.clear()</code></p> <p>4.<code>isDigit()</code> and <code>isAlpha()</code></p> <ul> <li><code>isDigit()</code> inatumika katika C++ kwenye program yako kuweza kuangalia kama kuna digit kwenye string na pia unaweza ukawa na program ambayo unatumia kwa ajili ya kufana capturing ya user input kwenye program hivyo unaweza ukatumia isDigit kuweka kucapture kuona kama kwenye program yako kuna digit,Mfano:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nbool nambaNiSahihi(string const &amp;jina)\n{\n    for (char j : jina)\n    {\n        if (isdigit(j))\n        {\n            cout &lt;&lt; \"Jina haliwezi kuwa na namba\" &lt;&lt; endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cout &lt;&lt; \"Jina: \";\n    string jina;\n    getline(cin, jina);\n\n    // ita function\n    nambaNiSahihi(jina);\n    return 0;\n}\n</code></pre> <p>Tumetengeneza simple function ambayo itatuwezesha kuweza kuangalia kama jina atakalo ingiza mtuamiaji wa program yetu ni sahihi au sio sahihi kwamba tutafanya iteration kwenye string jina kisha tutaangalia kama kwenye string jina kuna kwamba kwa kila character ambayo ipo kwenye string jina tunaangalia kama kuna tarakimu kwa kutumia <code>isdigit()</code> function ambayo inapokea character kama argument.</p> <p>5.<code>getline()</code></p> <ul> <li>getline() inatumika ukiwa unataka kufanya capturing ya string ambayo ina maneno mengi kwa mfano jina la mtu <code>Njox McTominay</code> kwamba kama utatumia cin kinachofanyika kwenye buffer ni kwamba neno la kwanza linakuwa captured kwenye program yako na pale program katika buffer ikiona new space au newline (delimeter) ianchofanya inaruka baada ya kuona newline na kuenda sehemu nyingine kwenye program yako kama kuna kitu kingine kinakuwa captured hivyo ukitumia cinkinachokuwa captured ni neno moja tu.Mfano:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string jina;\n    cout &lt;&lt; \"Jaza jina lako: \";\n    cin &gt;&gt; jina;\n    cout &lt;&lt; \"Jina: \" &lt;&lt; jina;\n    return 0;\n}\n\n/*Output:\nJaza jina lako: Njox McTominay\nJina: Njox\n*/\n</code></pre> <ul> <li>Kwa kutumia <code>cin()</code> kuna characters zinakuwa ignored kwenye program yako baada ya white space pamoja na newline.Sasa badala ya kutumia <code>cin</code> option nzuri ni kutumia <code>getline</code>.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string jina;\n    cout &lt;&lt; \"Jaza jina lako: \";\n    getline(cin, jina);\n    cout &lt;&lt; \"Jina: \" &lt;&lt; jina;\n    return 0;\n}\n\n/* Output:\nJaza jina lako: Njox McTominay\nJina: Njox McTominay\n*/\n</code></pre> <p>getline inachukua parameters mbili, input stream ambayo ni cin na parameter ya pili ni buffer ambayo ni string, na pia inarudisha reference kwenda kwenye input stream.</p> <p>6.<code>endl()</code></p>"},{"location":"basics/input_handling/input_handling/#advanced-input-handling-techniques","title":"Advanced input handling techniques","text":""},{"location":"basics/input_handling/input_handling/#input-validation","title":"Input validation","text":"<ul> <li> <p>Checking user input for specific criteria before using it in your program.</p> </li> <li> <p>Katika C++ kuna namna nyingi na tofauti za kuweza kufanya validation ya user input kwenye program yako.Baadhi ya njia hizo zinzotumika ni kwa kutumia <code>cout</code> na <code>cin</code> na zote hizi zina built in tools kwa kuweza kudeal uncertanities kwenye msimbo wako.</p> </li> </ul> <p>-</p>"},{"location":"basics/input_handling/input_handling/#command-line-arguments","title":"Command-line arguments","text":"<ul> <li>Accessing arguments passed to the program when it is executed.</li> </ul>"},{"location":"basics/introduction/introduction/","title":"Introduction C++","text":"<ul> <li>Introduction</li> <li>Version History</li> </ul>"},{"location":"basics/introduction/introduction/#introduction","title":"Introduction","text":"<ul> <li> <p>Je ni kitu gani unaweza ukafanya na C++, C++ lugha mama ambayo lugha nyingi zimetoka kwenye C++,C++ inatumika katika kufanya vitu vifuatavyo.</p> </li> <li> <p>Buidling High performanvce apllication.C++ inatumika katika kutengeneza applications amabzo zinakuwa kwa ajili ya kufanya high performance task katika sehemu mbambali inaweza ikawa katika kampuni au hata katika taasisi mbambali za binfasi na hata zile za serikali.</p> </li> <li> <p>Operating System. C++ inatumika katika kutengeneza operating system ambazo zitatumika katika sehemu mbali mbali, mfano wa operating syetm ambazo zimetengenezwa kupitia C++, mfano wa operating syetm ambazo zimekuwa built kwa kutumia C++ kna <code>macos</code> pia unaweeza kupitia hii article kupata uelewa mzuri zaidi operating system built using C++</p> </li> <li> <p>Video Games, Kupitia C++ unaweza ukatengeneza games pia ila inahitaji uwe na na uelewa wa C++ basic na sintaksia zake kupitia hapa utaweza kuelewa vizuri nq ndio maana nimeandika hii repository kwa jaili ya wewe kujifunza. Mfano SWAT, Blizzard: StarCraft, StarCraft: Brood War, Diablo I, Diablo II: Lord of Destruction, Warcraft III, World of Warcraft, Starfleet Command, Invictus, PBS's Heritage: Civilization and the Jews, Master of Orion III, CS-XII, MapleStory.</p> </li> <li> <p>Web Browsers.Kuna web browsers nyingi ambazo zimekuwa built kw kutumia C++ ila mfano baadhi ni hizi,Microsoft Internet Explorer, Google Chrome (based on chromium web browser), Mozilla Firefox, Safari, Netscape Navigator, Opera and Opera Mini.</p> </li> <li> <p>Servers</p> </li> </ul>"},{"location":"basics/introduction/introduction/#version-history","title":"Version History","text":"<ul> <li>Kila baada ya miaka 3 huwa kunbakuwa na version za C++ zinakuwa released na zinakuwa na features mbalimbali mwaka 2023 kulikuwa na version mpya abayo imekuwa released.</li> <li>Kila version ya C++ huwa inakuja na maboresho na marekebisho ambayo ni muhimu na pia kutokana na kwa na watum,iaji huwa wanakuaja na majibu yao au mtazamo wao kuhusu hzio version mbalimbali ambazo zipio.</li> </ul> <ul> <li>C++ ni moja kati ya language ambayo ipo faster sana na pia ni lugha mabyo iko efficient, C++ ni lugha mamam na pia C++ ni lugha mabyo lugha nyingine zimezaliwa kutoka kwake ,Mfano wa lugha mabzo zimezaliw akutoka kwa C++ ni Dart, Java, TypeScript na JavaScript. Fuatilia hapo chini maelekezo mafupi kuhusu version hitsory aktika C++</li> </ul> <pre><code>C++98 (ISO/IEC 14882:1998):\n    The first standardized version of C++ was released in 1998.\n    It laid the foundation for the language and included features like classes, templates, and the Standard Template Library (STL).\n</code></pre> <pre><code>C++03 (ISO/IEC 14882:2003):\n    This version was a bug fix release and did not introduce new features.\n    It addressed some issues identified in the C++98 standard.\n\nC++11 (ISO/IEC 14882:2011):\n    Released in 2011, C++11 brought significant changes and new features to the language.\n    Some notable additions include lambda expressions, auto keyword, range-based for loops, smart pointers, and multithreading support.\n\nC++14 (ISO/IEC 14882:2014):\n    C++14, released in 2014, focused on bug fixes and small improvements.\n    It did not introduce major new features but refined and enhanced some existing ones.\n\nC++17 (ISO/IEC 14882:2017):\n    Released in 2017, C++17 introduced several new features and improvements.\n    Some highlights include std::optional, std::variant, parallel algorithms, and improvements to the standard library.\n\nC++20 (ISO/IEC 14882:2020):\n    C++20, released in 2020, brought substantial enhancements to the language.\n    Features include concepts, ranges, coroutines, and improvements to existing libraries.\n\nC++23 (Expected in the future):\n    Work is ongoing on the next version of C++, expected to be released in the coming years.\n    Proposed features include improvements to modules, reflection, and more.\n</code></pre> <ul> <li> <p>Ili uweze kumaster (!Joke) lugha ya C++ unahitaji kujua</p> <ol> <li> <p>Sintaksia ya C++. Unahitaji kujua Sintaksia za lugha ya C++ kama ambayo unajua lugha ya Kiswahili kuongeza ina maana na misamiati yake unaijua m,abayo ndio grammar sasa ili uweze kujua lugha ya CPP inabidi kujua synytax yake kwamba utaraibu wa program yako je inafanyaje kazi?</p> </li> <li> <p>C++ Standard Library. Upande wa libarary kunba vitu vuiwili ambavyo ni DSA yaani data structure na na mbili ni algorithms, hivyo upande wa libraray au tunaweza tujkasema STL ni muhimu kujua hivyo vitu.</p> </li> </ol> </li> </ul>"},{"location":"basics/loops/loops/","title":"Loops","text":""},{"location":"basics/loops/loops/#loops","title":"Loops","text":"<ul> <li>Introduction</li> <li>while Loop</li> <li>do-while Loop</li> <li>for Loop</li> <li>Range Based Loops</li> <li>break and continue Statements</li> <li>Common Mistakes</li> </ul>"},{"location":"basics/loops/loops/#introduction","title":"Introduction","text":"<ul> <li>Loop ni maelekezo (instructions) kweye programu ambayo inasababisha statement kujirudia mara baada ya muda fulani.Kwenye <code>cpp</code> kuna aina tatu za loop ambazo ni <code>for loop</code> <code>while loop</code> na <code>do while loop</code>, statement katika program yako ambayo unataka ijirudie mara kwa mara inaitwa loop body na kitendo cha statement kujirudia tunaita <code>iteration</code></li> <li>Maswali mawili ya kujiuliza pale ambapo unahitaji kutumia loop ni <code>je loop body inabidi iwaje?</code> na <code>kwa muda gani loop yako inabidi ijirudie katika program yako?</code></li> </ul>"},{"location":"basics/loops/loops/#while-loop","title":"while Loop","text":"<ul> <li>Kitu ambacho tunaweza kufanya kwenye for loop tunaweza pia kufanya kwa kutumia while loop ila sintaksia yake ndio itakuwa tofauti kidogo kwenye program yako.Mfano hapa tunatengeneza program ambayo itatuwezesha kuandika program ambayo itatatupa namba kuanzia 0 hadi 5,kwa kutumia for llop itakuwa kama hivi kwenye program yetu.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (int i = 0; i &lt;= 5; i++)\n    {\n        cout &lt;&lt; i &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Je kwa kutumia while loop program yetu itakuwaje? Kwenye upande wa while loop tunaanza na while keyword ikifuatiwa na boolean expression ya code yako kwamba endapo expression itakuwa kweli au ikweli hivyo statement yako itakuwa executed ila kama sio haitakuwa executed, kwenye for loop tumeweza kufanya declaration ya llop variable ila kwenye upnade wa while loop tunfanya declaration ya loop variable nje kabla ya while statement!</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int i = 0;\n    while (i &lt;= 5)\n    {\n        cout &lt;&lt; i &lt;&lt; endl;\n        i++;\n    }\n\n    return 0;\n}\n</code></pre> <p>Kwenye mfano hapo juu tumeanza na declaration ya loop variable kisha while keyword kisha ndani ya while statement itaingia condition au boolean expression baada ya hapo nadni ya while loop itakaa statement ambayo unataka iwe executed kwenye program yako ikifuatiwa na increment au decreement kutokana na statement yako yaani boolea n expression yako ilivyo endapo condition zitakuwa meet basi tutapata jibu sahihi kinyume na hapo itapelekea kupata infinite loop.</p> <p>Swali</p> <p>When to use while loop and for lop during execution of code?</p> <p>When to use For Loop:</p> <p>1.Tunatumia for loop katika program kama number of iterations tunazijua kwamba kama tunajua mara ngapi tunataka statement iwe executed kwenye code yako ndio tunatumia for loop.</p> <p>2.For loop ipo clean, consice na pia ni rahisi kuelewa kipi kimefanyika kwenye program yako ukifananisha na while loop kwenye program yako.</p> <p>When to Use While Loop</p> <ol> <li> <p>Handling input validation:While loops zinatumika sana kwa ajili ya kufanya validation ya input, pale ambapo utaomba mtumiaji kuweka input hadi pale ambapo data za uhakika zitaingizwa kwenye program yako.</p> </li> <li> <p>Utofauti ukubwa uliopo kati ya ya <code>do while</code> na <code>while</code> kwenye kucontrol expression za bulliani(boolean) inavyokuwa checked.    Pale ambapo <code>while</code> statement inakuwa executed katika program yako, boolean expression inakuwa checked kabla ya loop body inavyokuwa excecuted.Kama boolean expression itakuwa ni <code>false</code> then body haitakuwa executed kabisa.</p> </li> <li>Kitu cha kwanza kinachotokea pale ambapo <code>while loop</code> inakuwa executed ni kwenye kucontrol boolean expression zinavyokuwa evaluated.Kama boolean expression itakuwa evaluated kwenda false basi body ya hiyo loop haitakuwa executed</li> </ol>"},{"location":"basics/loops/loops/#do-while-loop","title":"do-while Loop","text":"<ul> <li> <p>Ukiwa na <code>do-while loop</code>, body ya loop inakuwa executed kwanza na na boolean expression inakuwa checked baada ya loop body kuwa executed angalau mara moja.Kwa hiyo do-while statement mara mara nyingi inakuwa executed kwenye loop body angalau mara moja.Baada ya hapo <code>do-while</code> na <code>while</code> loop ziankuwa na tabia moja.Kwenye do while loop lazima statement iwe executed hata mara moja kwa sababu statement inakuwa executed kwanza kisha iteration inaeendelea ila kwa upande wa while loop statement inaweza hata isiwe executed kabisa katika program yako.</p> </li> <li> <p>Kupitia uwepo wa do while loop kwenye prigram yako ni kwamba statement ndani ya do inabidi iwe executed kwanza angalau mara moja kwenye program yako ila kwenye while loop statement inaweza ikawa executed au isiwe executed kabisa kwenye program yako.</p> </li> </ul> <pre><code>\n</code></pre> <p>Sintaksia of the while Statement </p> <pre><code> while (Boolean_Expression)\n Statement\n</code></pre>"},{"location":"basics/loops/loops/#for-loop","title":"for Loop","text":"<ul> <li>For loop katika C++ tunatumia kwa ajili kuifanya execution ye code mara nyingi, chukulia mafano umeambiwa uandike program amabyo utaweza kuleta display ya neno \"C++\" mara 4, basi hapa ndio tunatumia for loop badala ya kuandika kila mstari wa line \"C++\" basi badala ya kaundika progrma hivi</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    // Print \"C++\" four times without using a loop\n    cout &lt;&lt; \"C++\\nC++\\nC++\\nC++\\n\";\n    return 0;\n}\n</code></pre> <p>Badala ya kuandika hivyo katika kutumia for loop inabidi iwe hivi,loop yet itaanza na counter variable na uwepo wa counter variable ndiyo itatuwezesha kwamba mara ngapi loop yetu itakuwa executed , hivyo inabidi kuwe na initialization ya ya variable yako ambapo kwa upande wangu <code>int i = 0</code> baada hapo inafuatiwa na boolean expression au tunaweza tukasema condition kwamba incase kwamba i inaweza ikawa sawa na boolean expression  yetu au sio sawa na kama ni sawa boolean expression itakuwa true na kama sio swa boolean expression itakuwa false.Hivyo endapo boolean expression itakuwa false then hakuna kitakachokuwa executed kwenye code yetu ila kama ni true baada itaingia ndani ya <code>for loop</code>, mfano counter variable yetu <code>i = 0</code> na boolean expression au condition yetu <code>i , 4</code> hapa ni kweli <code>i &lt; 4</code> ambapo i = 0, na ukiangalia kweli 0 &lt; 1, 0 &lt; 2, na kuendelee. Expression inayofuatiwa na je kwa namna gani inaweza ikabadilika kila baada ya repetition katika code yako!(How i it gonna change after each repetion into your code), kwenye code yetu tunaweza tukasema kwamba kila baada ya repetion i iwe inaongezewa moja yaani incrementation na hapa ni muhimu kuwa makini kwa sababu kama loop yako itakuwa evaluated kuwa kwelie na counter variable yako inaweza ikawa increment au decrement ukishindwa kufanya evaluation vizuri inaweza kupelekea <code>infinite loop!</code>, ila kwenye mfano wetu i itakuwa increment yaani kila baada ya repetition i itakuwa moja kisha 2, kisha 3, kisha 4, kisha 5 ila kutokana na uwepo wa loop condition yetu i itakuwa evaluated hivi.</p> <pre><code>0 &lt; 5; True\n1 &lt; 5; True\n2 &lt; 5; True\n3 &lt; 5; True\n4 &lt; 5; True\n5 &lt; 5; False\n6 &lt; 5; False\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n\n    // for loop\n    for (int i = 0; i &lt; 5; i++)\n    {\n        cout &lt;&lt; \"C++ \\n\";\n    }\n\n    return 0;\n}\n</code></pre> <p>Angalia hapo juu baada ya i kuwa evaluted baada ya incrementation na kuwa false baada loop yetu haitakuwa executed tena kwenye loop yetu ina maana loop yetu itakuwa terminated.Na endapo ukikosea badala kuweka incrementation unaweka decrementation basi utapata infinite loop kwa sababu statement itakuwa evaluetd kwenda true lifetime.Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n\n    // for loop\n    for (int i = 0; i &lt; 5; i--)\n    {\n        cout &lt;&lt; \"C++ \\n\";\n    }\n\n    return 0;\n}\n</code></pre> <p>Simple Sintaksia</p> <pre><code>for(counter_variable(loop variable); boolean_expression(condition), incrementation or decrementation){\n    // code to be executed;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    // Print \"C++\" four times\n    for (int i = 0; i &lt; 4; ++i) {\n        cout &lt;&lt; \"C++\" &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <p>Ili kuweza kufanya declaration ya for loop tutaanza na for keyword ikifuatiwa na mabano na ndani ya mabano kunakuwa na variable initilaization(kama haijawa declared), inafuatiwa na condition yako ambayo inaweza kuwa evaluated kama ni kweli au sikweli kisha inafuatiwa na pia condition inayokuwa ndani ya loop yako ndio utaamua kwamba muda gani loop yako itaishia, expression ya mwisho ndio utadetermine je kwa muda gani variable yako itabadilika vipi baada ya kufanya repetetion kwenye program yako.</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    for (int i = 0; i &lt; 4; ++i) {\n        cout &lt;&lt; \"C++ \";\n    }\n    return 0;\n}\n</code></pre> <p><code>for (int i = 0; i &lt; 4; ++i) {</code> hii line inaanza na declaration ya ya variable int i = 0 a,mbapo imekuwa initialized kuwa sifuri, na loop itaendelea hadi i itakapo kuwa ni ndogo(less than) 4,katika kila iteration <code>i</code> inakuwa incremented na moja yaani inaongezewa moja.Ndani ya loop kuna line `cout &lt;&lt; \"C++\" kuweza kuprint \"C++\" kwenye standard output(kwenye console), na hiyo line iatakuwa executed mara 4 kutokana na loop na pia conditions zetu. kwa kila statement itakayo kuwa ndani ya loop body yako pia iatkuwa executed kutokana na condition.</p> <p>Kila mchezaji anapojiandaa kwa \"for loop\", wanajiweka tayari kufanya mazoezi ya kupiga mpira kwenye lango. Wanapojiandaa kwa \"for loop\", wanaelewa kuwa watahitaji kurudia hatua hiyo mara kadhaa, kama ilivyoamuliwa na kocha. Wakati wa \"for loop\", mchezaji hupiga mpira kwenye lango mara kadhaa, kulingana na idadi iliyowekwa. Baada ya mchezaji kumaliza kufanya mazoezi (yaani, kurudiwa kwa \"for loop\"), wanaondoka uwanjani wakiwa wamejifunza na kuimarisha ujuzi wao.</p>"},{"location":"basics/loops/loops/#range-based-loops","title":"Range Based Loops","text":"<ul> <li>Katika modern C++ kuna fetuare ambayo imeanzishawa ambayo ni range for based loop na range based inatumika pale ambapo tunataka kufanya execution ya block ya code multiple times ila kwenye list items kama kwenye arrays. Mfano tuna array amabyo inahifadhi marks ambayo inahifadhi idadi ya marks amabzo wanafunzi wanazo. Mfano:Ili kupata marks ya kila mwanafunzi loop yetu itakuwa kama hivi</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n\n    int students[] = {2, 20, 30};\n    for (int i = 0; i &lt; 3; i++)\n    {\n        cout &lt;&lt; students[i] &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Ila moja kati ya shida ya code ya hapo juu ni kwamba imekuwa hard-coded kwamba vipi kama mbeleni kwenye array yetu mabyo inaitwa students itabadilishwa na kuwa na mwanafunzi mwingine ambaye labda marks zake zitakuwa 23, itabidi kubadili loop variable.Badala kufanya hard-coding ya size ya array basi inabidi kutafuta size ya array kwa kutumia function ya <code>sizeof</code> operator. size of operator inaleta kiasi cha bytes a,bazo zimekuwa llocated kwenye array yetu,array yetu ni students, na pia kuna integers 3 na kila integer inachukua 4 bytes, hivyo kwenye size of operator itakuwa hivi</p> <p><code>sizeof numbers = integer size * idadi ya arrays</code> <code>4 * 3</code> na jibu litakuwa 12, ukichukua size ya array kagawanya na size ya integers ambazo ni 4 bytes,utapata idadi ya items ambazo ziko kwenye array.</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n\n    int students[] = {2, 20, 30, 40};\n    for (int i = 0; i &lt; sizeof(students) / sizeof(int); i++)\n    {\n        cout &lt;&lt; students[i] &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Hivyo kutokana na uwepo wa loop yetu hiyo endapo kuna item itaongezwa kutakuwa hakuna shida kwa sababu tayari kuna sizeof operatorambayo itakuwa ina ji update dynamically na kutfata ize ya array yetu.Ila nji hapo juu ni njia ya zamani kwenye modern C++ kuna njia mabyo ni nzuri zaidi na hiyo inaitwa <code>range based for loop</code>, na pia inatumika kama tuna list of items kama arrays na pia tunataka kuloop ndani ya hizo list items.</p> <ul> <li>Wakati wa kutumia range based loop ndio huu sasa tunaanza na declaration na hiyo declaration itachukua value ya variable moja katika array yetu hivyo itakuwa kama hivi.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n\n    int students[] = {2, 20, 30};\n    for (int number : students)\n    {\n        cout &lt;&lt; number &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <ul> <li>Kupitia range based loop pia tunaweza kufanya iteration kwenye string kwa sababu string ni list ya characters!</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string name = \"Neicore\";\n    for (char ch : name)\n    {\n        cout &lt;&lt; ch &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int maksi[4] = {10, 20, 30, 40};\n\n    // Iterate over the elements of the array using a range-based for loop\n    for (int num : maksi) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre> <p>int num inafanya declaration ya variable ambayo itachukua value ya kila element ya array maksi katika kila iteration. : maksi inaspecify range ya kufanya iteration, katika case yetu array maksi ndani ya loop, std::cout &lt;&lt; num &lt;&lt; \" \"; itaprint kila element ambayo itafuatiwa na nafasi.</p> <p>Hivyo kama tunataka kufanya iteration kwenye hii array tuatumia for loop ili kuweze kuapata kila maksi ambazo zipo kwenye array yetu na kuweza kuprint kwenye newline.</p>"},{"location":"basics/loops/loops/#break-and-continue-statements","title":"break and continue Statements","text":"<ul> <li> <p>Katika C++, <code>break</code> na <code>continue</code> zinaitwa jump statements zinatumiak kubadili normal flow ya control ndani ya loops na hata pia switch statements.Kuna utofauti kati ya break na continue statements katika C++</p> <ol> <li>Break:Break inachofanya inafanya termination ya loop kabisa(completely) kwenye program yako.</li> <li>Kama break statement itakutwa ndani ya loop basi,iterations zote zilizobakia zinakuwa skipped,na program control italuka na kuenda kwenye statement papo hapo baada ya loop.</li> </ol> </li> </ul> <pre><code>for (int i = 0; i &lt; 10; i++) {\n  if (i == 5) {\n    break;  // Exit the loop when i reaches 5\n  }\n  std::cout &lt;&lt; i &lt;&lt; \" \";\n//   output: 0 1 2 3 4 \n}\n</code></pre> <p>Mfano kwenye program yetu hapo juu evaluation itafanyika na boolean expression itakuwa evalauted na hivyo baada ya statement yako hapo juu kitakachofanyika ni kwamba statement nui kweli ila iija kwenye upnade wa wa condition kwamba kama i itakuwa sawa na 5 loop yetu itabreak na kwenda sehemu nyingine ambayo ni je ya for loop kwenye program yetu.</p> <ol> <li>Continue:<ul> <li>Continue statement katika C++, itaumika kuskip iteration kwenye loop na kwenda kwenye iteration nyingine kwenye program yako ila ndani ya loop.Mfano unaweza ukawa na program ambayo itakuwezesha kuweza kuprint namba ambazo ni ood numbers kuanzia 0 hadi 10.</li> </ul> </li> </ol> <pre><code>for (int i = 0; i &lt; 10; i++) {\n  if (i % 2 == 0) {\n    continue;  // Skip even numbers\n  }\n  std::cout &lt;&lt; i &lt;&lt; \" \";\n}\n</code></pre> <p>Kwenye program yetu hapo itatupa odd number namba tasa tu ila inaskip tu zile namba ambazo sio tasa kwenye program yetu.</p>"},{"location":"basics/loops/loops/#common-mistakes","title":"Common Mistakes","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"basics/pointers/pointers/","title":"Pointers","text":"<ul> <li>Introduction</li> <li>Declaration</li> <li>Constant Pointers</li> <li>Passing Pointers To Functions</li> <li> <p>Dynamic Memory Allocation</p> </li> <li> <p>Advantages and Disadvtages Of Pointers</p> </li> <li> <p>Array and Pointers Relationship</p> </li> <li> <p>Pointer Arithmetic</p> </li> <li> <p>Smart Pointers</p> </li> <li>Unique Pointers</li> <li> <p>Shared Pointers</p> </li> <li> <p>Pointers Best Practicess</p> <p></p> </li> </ul>"},{"location":"basics/pointers/pointers/#introduction","title":"Introduction","text":"<p>Pointer ni special variable ambayo inachukua address ya variable nyingine katika memory.Mfano tunaweza tukawa na variable ambayo inaitwa age na values yake ni 10 ila katika memory variable ni kama label ya variable yako ila hiyo variable ambayo ni age inakuwa na location yake katika memory.Hivyo tunaweza tukafanya declaration ya variable nyingine mabayo tunaita pointer ambayo inachukua address ya age variable.</p> <p>Kwanini Pointers?</p> <ol> <li> <p>Passing Large objects: Katika program yetu tunaweza tukawa na function kwa ajili ya kufanya kazi fulani ila kama inafanya passing ya data ambazo ni kubwa inabidi kutumia pointer ili kuweza kurahisisha kazi yako.</p> </li> <li> <p>Dynamic Memory Allocation. Katika sehemu ya memory management nimeeleza vizuri kuhusu memory management na kwa kwa namna gani unaweza ukatumia kwa ajili ya kufanya memory alloaction, dynamic memory alloaction katika C++ ni pale ambapo memory yetu inakuwa adjusted kutokana na inputs ambazo zinakuwa ndani ya program yako.Kufanya dynamic memory allocation katika C++ tunatumia <code>new</code> keywpord kwa ajili ya kufanya alloaction na <code>delete</code> keyword kwa ajili ya kufanya deallocation.</p> </li> <li> <p>Enabling Polymorphism.</p> </li> </ol>"},{"location":"basics/pointers/pointers/#declaration","title":"Declaration","text":"<p>Pointer ni variable ambayo imechukua address ya variable nyingine katika memory. Variable katika C++ ina address yake katika memory na ili kuweza kupata address ya variable yako katika memory tunatumia ampresand operator au tunaita address of operator: Angalia mfano hapo chini</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    int age = 20;\n    cout &lt;&lt; \"Address of age is: \" &lt;&lt; &amp;age;\n    // output: 0x89787ff8ec\n    return 0;\n}\n</code></pre> <p>Address ya variable inakuwa katika hexadecimal number. Value ya address ya pointer yangu hapo juu inaweza ikawa inatofautiana na yako katika computer yako na pia address ya variable yako huwa inabadilika hivyo usishange kwamba mara ya kwnza ukirun msimbo wako unapata output tofauti.</p> <p>Kufanya declaration ya integer pointer tutuanza na int keyword ikifuatiwa na nyota yaani asterisk kisha tutaipa pointer yetu jina lako kama ambayo unazipa variable zingine majina ila ni muhimu kuzingatia kwa jina la pointer yako liwe meaningfull na pia liwe descriptive, hivyo integer pointer yetu tutaipa jina la ptr na tutafanya initilaization ya address ya age kutoka kwenye mfano pale juu.</p> <pre><code>    int* ptr = &amp;age;\n</code></pre> <p>Kwenye mfano hapo juu tmefanya declaration ya pointer variable ptr ambayo ni integer ila imechukua memory location(address) ya integer age.</p> <p>integer pointer yetu ina point kwa integer pointer, endapo tujijaribu kubadili integer yetu kuwa double au float kwenye age tutapata error: Mfano</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n  // badili int kuwa double\n    double age = 20;\n    cout &lt;&lt; \"Address of age is: \" &lt;&lt; &amp;age;\n    // output: 0x89787ff8ec\n\n    int *ptr = &amp;age;\n\n    return 0;\n}\n</code></pre> <pre><code>error: cannot convert 'double*' to 'int*' in initialization\n   10 |     int* ptr = &amp;age;\n      |                ^~~~\n      |                |\n      |                double*\n</code></pre> <p>Hivyo kama umetengeneza integer data type na kutengeneza pointer yake ni muhimu pointer variable yako iwe sawa na ile ya data type yako.Je baada ya kufanya declaration ya pointer yako tunaweza kufa ya nini ya pointer yako?</p> <p>Ili kuweza kupata value au data(value) ya pointer yako tutatumia <code>indirection(dereference operator)</code>, indirection operator inaanza na * (nyota) asterisk ikifuatiwa na jina integer pointer yako au kama umetumia float inaweza ikawa float pointer, kwa kutumia dereference operator  utapata value ya integer pointer yako.</p> <pre><code>    cout &lt;&lt; *ptr; // 20\n</code></pre> <p>Kwenye njia ya kawaida kama umefa nya declaration ya variable age na kuipa value labda 10 unaweza kubadili ya kuweka value iwe 30, Mfano:</p> <pre><code>int age = 20;\nage = 30;\ncout &lt;&lt; age; // 30\n</code></pre> <p>Kwenye upande wa pointers unaweza kufanya kitu kama hivyo kwa kutumia dereference operator ili uweze kupata value ya kisho utaipa value nyingine.Kitendo ya kubadili value ya integer pointer kunapelekea kunadilika kwa value ya age pia, Mfano</p> <pre><code>*ptr = 30;\ncout &lt;&lt; *ptr; // 30\ncout &lt;&lt; \"\\n\";\ncout &lt;&lt; age; // 30\n</code></pre>"},{"location":"basics/pointers/pointers/#constantpointers","title":"ConstantPointers","text":"<ul> <li> <p>Kwenye upande wa constants katika pointers tunaweza tukawa na vitu vitatu</p> </li> <li> <p>Data is Constant: Hapa data ni constant ila pointers sio constant.Kwa hiyo unaweza ukafanya declaration ya variable yako labda x sawa na 20 ila ukatengeneza integer pointer ambayo itapoint kwenye x integer na hiyo pointer integer yako inaweza ikawa constant hivyo endapo ukajaribu kufanya dereference ya variable yako na kuipa value kama 30 haitawezekana kwa sababu kitendo hicho ni sawa na kuwa na constant yako ambayo ni x ni sawa na kufanya const ya x kuwa 30 hivyo haitawezekana. Angalia mfano jisni ya declaration ya pointer ambayo data zake ni constant.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    // constant pointers\n\n    // 1. data is constant\n    const int x = 20;\n    const int* ptr = &amp;x;\n\n    cout &lt;&lt; *ptr;\n    return 0;\n}\n</code></pre> <p>Kumbuka tumesema kwamba pointer ni ile variable ambayo inachukua adrres ya variable nyingine katika memory hiyo kama data zetu za pointer ni constant hiyo pointer yetu inauwezo wa kuweza kufanya pointing katika variable nyingine katika program yetu.</p> <pre><code>    int y = 10;\n    ptr = &amp;y;\n</code></pre> <ol> <li>Pointer ni constant. Pointer ni constant ila data sio constant.Ili kuweza kudefine pointer ambayo ni constant katika program yako utafanya njia ya kawaida ya kufanya declration ial kwenye ile data type yako ambayo ni pointer, mfano kwenye integer pointer baada ya asterisk itafuta const keyword ikimaanisha kwamba pointer yako ni constant.Kumbuka kama pointer yetu ni constant hatuwez kubadili value yake na value yake tunapata kwa kutumia &amp;.</li> </ol> <pre><code>    int x = 20;\n    int *const ptr = &amp;x;\n</code></pre> <p>Kutokana na kuwa na constant pointer hatuwezi kubadili address ya constant pointer yetu.Mfano hao chini kufanya hiyo tutapata error.</p> <pre><code>    int x = 20;\n    int *const ptr = &amp;x;\n\n    int y = 30;\n    ptr = &amp;y;\n</code></pre> <p>error</p> <pre><code>error: assignment of read-only variable 'ptr'\n   14 |     ptr = &amp;y;\n      |     ~~~~^~~~\n</code></pre> <ol> <li>Both Data na pointer ni constant.Katika situation kama hii pointer yetu inakuwa constant na pia data zetu ni constant. Hivyo hatuwezi kubadili chochote katika program yetu.</li> </ol> <pre><code>    const int x = 20;\n    const int *const ptr = &amp;x;\n</code></pre>"},{"location":"basics/pointers/pointers/#advantages-and-disadvantages-of-pointers","title":"Advantages and Disadvantages of Pointers","text":""},{"location":"basics/pointers/pointers/#errors","title":"Errors","text":""},{"location":"basics/pointers/pointers/#passing-pointers-to-functions","title":"Passing Pointers To Functions","text":"<ul> <li>Mwanzo kabisa hapo juu nimeandika kwamba pointers zinaweza zikatumika kwa ajili ya kufanya passing large objects kwa kutumia reference kwenye data.Mfano tutatengeneza function yetu kwa ajili ya kufanya addition kisha tutacall function yetu inside.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// addition\nint addition(int* number1, int* number2, int* result){\n    *result = *number1 + *number2;\n    return *result;\n}\n\nint main(){\n    int number1, number2, result;\n\n    cout &lt;&lt; \"Enter first number: \";\n    cin &gt;&gt; number1;\n\n    cout &lt;&lt; \"Enter second number: \";\n    cin &gt;&gt; number2;\n\n    addition(&amp;number1, &amp;number2, &amp;result);\n\n    cout &lt;&lt; result;\n\n    return 0;\n}\n</code></pre>"},{"location":"basics/pointers/pointers/#relationship-between-pointers-and-arrays","title":"Relationship Between Pointers and Arrays","text":"<ul> <li>Ukifanya declaration ya array yako katika C++, Mfano:</li> </ul> <pre><code>    int numbers[] = {10, 20, 30};\n    cout &lt;&lt; numbers;\n</code></pre> <p>Baada ya kufanya cout ya numbers utapata pointer ambayo inapoint kwenye element ya kwanza katika array yako ambayo ni number[] array.Ukitumia indirectional operator utapata value ya array yako ila ya first element.</p> <pre><code>    int numbers[] = {10, 20, 30};\n    cout &lt;&lt; *numbers; // 10\n</code></pre> <p>Pia tunaweza tukawa na integer pointer ambayo inapoint kwenye array yetu ya first element kwa sababau ni pointer.Hivyo ukitumia imdirectional operator tutapata value ya first element kwenye array ila ukitumia reference operator tutapata address ya first element kwenye array.</p>"},{"location":"basics/pointers/pointers/#dynamic-memory-alocation","title":"Dynamic Memory Alocation","text":"<ul> <li>Application ya pili ya pointers ni kwenye dynamic memory allocation,Array ili iweze kutumika inabidi iwe initiliazed kwamba member wangapi wake kwenye array yetu ili kuweza kutumia memory vizuri na hata kama array ispo kuwa initialized bado ni practice mbaya kwa sababu interprter inafanya allocation ya memory kubwa kwa sababau haijui je ni kiasi gani cha memory kinahitaji kwa ajili ya program yako basi hapa ndio dynamic memory allocation inatumika,kwamba wakati wa runtime wa program yetu tunafanya llocation ya space ya baada ya program kuwa executed tuna free up space.</li> </ul> <pre><code>   int* numbers = new int[10];\n</code></pre> <p>Kwenye mfano hapo juu ndio namna dynamic memory allocation inavyofanyika kwenye program yetu,Tumefanya declaration na initialization ya array pointer,tunaanza na new operator  kisha target_type ambayo inaweza ikawa integer au characters,ila target type yetu ni integer na ndani ya mabanao tunaweka intial size, <code>new int[10]</code> hii itarudisha integer pointer na kisha inabidi tuhifadhi kwenye integer pointer inaitwa numbers,kmbuka kufanya declaration ya pointer yako kwa kutumia * kinyume hapo haitawezekana kwa sababu itaonekana kama unataka kufanya conversion ya integer pointer array kwenda integer.</p> <ul> <li>Dynamic memory allocation katika C++ inatokea kwenye sehemu ya memory inaitwa heap au free stack,tunavyofanya allocation ya pointer yetu katika program yako anayehusika kwa ajili ya kufree space katika memory yako ni wewe programmer na sio mtu mwingine endapo unashindwa kufreespace katika memory yako itapelekea program kucrash na pia kusababisha memory leak,hakikisha unapitia sehemu hii ya memory management kuweza kujua zaidi kuhusu memory allocation.Hivyo ni muhimu kufanya deallocation ya pointer yako baada ya kufanya allocation kwa kutumia delete operator.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    // allocation using new operator\n    int *numbers = new int[10];\n    // deallocation using delete operator\n    delete[] numbers;\n    return 0;\n}\n</code></pre> <p>Kwa sababu kazi ya kufanya deallocation inafanywa na programmer,kufanya deallocation tunatumia delete operator ikifuatiwa na jina pointer yetu ambayo ni numbers ila kwa sababu ni integer pointer array lazima kuweka square brackets baada ya delete operator,pia ni vizuri kufanya reset ya pointer yako kuwa nullptr baada ya kufanya allocation na deallocation,Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    // allocation using new operator\n    int *numbers = new int[10];\n    // deallocation using delete operator\n    delete[] numbers;\n    // reset to nullptr\n    numbers = nullptr;\n    return 0;\n}\n</code></pre> <ul> <li>Static memory allocation: Wakati wa declaration  wa  variable yako anayehusika na kufanya memory alloaction sio wewe bali ni compiler.</li> </ul> <pre><code>   int numbers[1000];\n</code></pre> <p>Declartion ya array yetu imefanyika na hiyo array inachukua members 1000 na yote haya yanafanyyika katika sehemu ya memory ambaye inaitwa stack kwamba kitendo cha kufanya allocation na deallocation ya memory kwenye program yako kinafanywa na compiler yenyewe na sio program,program inakuwa executed ila pale ambapo kutakuwa na return statement kwenye program yako hapo ndio memory inakuwa deallocated(allocated) kwenye program yako.</p>"},{"location":"basics/pointers/pointers/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<p>Pointer arithmetic katika C+ inakupa uwezo wa kifanya arithmetic operations katika pointers. Pale unapo perform aithmetic katika pointer, jibu linatokana na na size ya aina ya data ambayo pointer yako inapoint kwenye hiyo data.</p> <ul> <li>Adding and Subtracting Integers from Pointers</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int array[] = {10, 20, 30, 40, 50};\n    int *ptr = array; // Pointer to the first element of array\n\n    // Adding an integer to a pointer moves the pointer forward\n    ptr = ptr + 1; // Now points to the second element (20)\n\n    // Subtracting an integer from a pointer moves the pointer backward\n    ptr = ptr - 1; // Now points back to the first element (10)\n\n    // Accessing elements using pointer arithmetic\n    cout &lt;&lt; *ptr &lt;&lt; endl; // This will print 10\n\n    // Adding more than 1\n    ptr = ptr + 3; // Now points to the fourth element (40)\n\n    // Subtracting more than 1\n    ptr = ptr - 2; // Now points to the second element (20)\n\n    cout &lt;&lt; *ptr &lt;&lt; endl; // This will print 20\n\n\n    return 0;\n}\n</code></pre> <p>Array inaanzia katika index ya 0 na endapo ukajaribu kama index ya element ambayo ipo nyuma ya element ambayo ipo index ya sifuri utapata garbage value.</p> <ul> <li>Increment and Decrement Operators</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int array[] = {10, 20, 30, 40, 50};\n    int *ptr = array; // Pointer to the first element of array\n\n    // Incrementing a pointer moves it to the next memory location of its type\n    ptr++; // Now points to the second element (20)\n\n    // Decrementing a pointer moves it to the previous memory location of its type\n    ptr--; // Now points back to the first element (10)\n\n    cout &lt;&lt; *ptr &lt;&lt; endl; // This will print 10\n\n    return 0;\n}\n</code></pre> <ul> <li>Pointer Arithmetic with Arrays</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int array[] = {10, 20, 30, 40, 50};\n    int *ptr = array; // Pointer to the first element of array\n\n    // Using pointer arithmetic to access elements\n    cout &lt;&lt; *(ptr + 2) &lt;&lt; endl; // This will print 30\n\n    // Equivalent to:\n    cout &lt;&lt; array[2] &lt;&lt; endl; // This will also print 30\n\n    return 0;\n}\n</code></pre> <ul> <li></li> <li> <p>Don't delete the pointer twice   <code>example:</code></p> </li> </ul> <pre><code>int main(){\n  int* x = new int;\n  delete x;\n  delete x;\n\n  return 0;\n\n  // error: malloc: xxxx error for object\n  //  error: malloc xxx set a breakpoint\n}\n</code></pre> <ul> <li> <p>Rember to deallocate meory of the pointers in the program using the delete opertory but as the program gets bigger or we may be maintaining legacy application so it's the best practices to use smart pointers to save time and code refactoring and clean code.</p> </li> <li> <p>Dynamically reallocation katika cpp inawezekana kutokana na uwepo wa delete keyword, kwa mara ya kwanza tutaweza kuallocate memory kwa ajili ya pointers zetu ila inabidi kudeallocate memory kwenye pointer zetu</p> </li> </ul> <pre><code>int main(){\n  int* x = new int;\n  delete x;\n\n  return 0;\n}\n</code></pre> <ul> <li>Assume kwamba tuna poinetrs kama elfu moja hivi kwa hiyo utakuwa ngumu katika kufanya memory deallocation sasa katika instance kama hii ndion inabidi kutumia smart pointers,</li> <li>Whenevr we allocate memory at the heap, ni lazima tukkumbuke kutumia delete operator kfanya deallocation,kama hautafanya hivyo memory ambayo imekuwa allocated haita kuwepo mbeleni,pia jinsi ambayo tuna allocate more and more memory program yetu inapelekes ku consume meory kwa kiasi kikubwa sana na kupelkea kurun out of memory and <code>memory leak(program is consuming more and more memory)</code>, ni muhimu zipi ni best practices</li> <li>pale ambapo unfanya jkazi na pointers katika programu yetu   Kuna muda unakuta kwamba katika programu yako ambayo umenadika kuna pointers karibia elfu moja au labda inaweza ikawa umepewa kazi ya kumaintain program fulani hivyo itakuwa ngumu sana kufanya deallocation kwa pointers zote katika programu yetu kwa hiyo kwenye instance kama hii hapa ndio tunatumia <code>smart pointers</code> kuna aina mbili za smart pointers ambazo ni unique and shared pointers katika C++.</li> </ul>"},{"location":"basics/pointers/pointers/#smart-pointers","title":"Smart Pointers","text":"<ul> <li>Kuna aina mbili ya smart pointers ambapo kuna uniqe pointer pamoja na shared pointer.</li> </ul>"},{"location":"basics/pointers/pointers/#unique-pointers","title":"Unique Pointers","text":"<ul> <li> <p>Unique pointers,Ni aina ya pointers ambazo zina own kiasi fulani cha memory ambayo inapoint to(kind of pointer that owns a piece of memory it points to) ni kama <code>mwekezaji</code> ila anachukua asilimia chache. Hatuwezi tukawa na unique pointer mbili ambazo zote zimepoint kwenye same location.</p> </li> <li> <p>Ili tuweze kutumia unique pointers katika program yetu ni muhimu kuinclude file katika standard library ambalo linaitwa <code>memory</code>, kupitia memory standard libraray kuna <code>unique-ptr</code> ambayo ni builtin class kupitia unique pointer hakuta kuwa na hata kuallocate memory na pia kutumia delete operator kwa jili ya kuadeallocate memory kwenye programu</p> </li> <li> <p>Ili uweze kutumia unique pointer lazima kutumia header file katika standard library ambalo ni <code>#include &lt;memory&gt;</code> ndani ya memory header file kuna type ambayo inatwa unique pointer class ambayo ni builtin function ndani ya main function katika programu yako tutatumia <code>unique_ptr&lt;&gt;</code> ndani ya mabano katika unique pointer tutaspecify aina ya pointer ambayo tunataka kutengeneza , pointer hiyo inaweza kuwa <code>int</code> au <code>string</code> baada ya hapo acha nafasi andika jina la variable ambayo unataka iwe created kama unique pointer itaweza ikawa ni number as a variable au anything else ambacho ni valid katika C++ but is should be descriptive kiasi kwamba hata mtu mwingine akiwa anaangalia anajua umefanya nini, kwa upande wangu variable nitaipa jina la <code>x</code> baada ya hapo tengeneza mabano ndani ya mabano tutatumia <code>new operator</code> kutengeneza pointer ya integer ila inategemeana wewe umetengeneza pointer ya aina gani, ndani yahayo mabano yako adnika data type ya pointer yako int.Basi kupitia hio programu yetu tumeweza ku create unique pointer ndani ya hiyo unique pointer kuna some builtin function functions ambazo zikoamhususi kwaajili ya kudelete(deallocation f the memory) ambazo zimekuwa created. Pia tunaweza kufanya dereferencing katika pointer yetu.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main()\n{\n    unique_ptr&lt;int&gt; x(new int);\n    cout &lt;&lt; x;\n\n    // dereferencing\n    *x = 20;\n    cout &lt;&lt; *x;\n\n    return 0;\n}\n</code></pre> <ul> <li>NOTE</li> <li>Kupitia uniqe pointers hatuwezi kuperfrom arithemetic operation yoyote katika programu yetu.Ila tunaweza kufanya dereference.</li> <li>Kam unatumia codeblock kuandiak code yako kuna error inakuwa ukiwa unadeal na unique pointer pale unapotaka kupata memory location ya pointer yako unaweza ukatumai code editor nyingine ili kuweza kuepuka hili.</li> </ul>"},{"location":"basics/pointers/pointers/#shared-pointers","title":"Shared Pointers","text":"<ul> <li>Kutokana na uwepo wa shared pointers tunaweza kuwa na pointer mbili ambazo zina point to the same memory location,kw aupnade wa unique pointers hatuwezi kuwa na two pointers ambazo zzina point kwa same memory locationn ila tukiwa na shared pointers tunaweza tukwa na pointers ambazo zinshare the same memory location na ndio maana zinaitwa shared pointers.</li> <li>Jinsi ya kutengeneza shared pointers ni same na jinsi y akutengeneza unique pointers kwa upnade wa Sintaksia ila kuna baadhi ya vitu ni tofauti.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main()\n{\n\n    shared_ptr&lt;int&gt; x(new int);\n    cout &lt;&lt; x;\n\n    // but with shared pointers we can a pointer pointing tio the same location\n\n    shared_ptr&lt;int&gt; y(x);\n    cout &lt;&lt; y;\n\n    return 0;\n}\n</code></pre> <ul> <li>Pia tunaweza kuangalia kama je shared pointers zina share the same memory loaction kwa kutumia if statement in cpp.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main()\n{\n\n    shared_ptr&lt;int&gt; x(new int);\n    cout &lt;&lt; x;\n\n    shared_ptr&lt;int&gt; y(x);\n    if(x == y)\n    {\n        cout &lt;&lt; \"Zipo sawa\";\n    }\n    else\n    {\n        cout &lt;&lt; \"Hazipo sawa\";\n    }\n    // Zipo sawa\n    return 0;\n}\n</code></pre>"},{"location":"basics/pointers/pointers/#pointers-best-practicess","title":"Pointers Best Practicess","text":"<ul> <li>Ni muhimu kufanya initialization ya pointer yakoi wakti wa kufa ya declaration kinyume na hapo italeta garbage value na kupelekea kupata memory leak.au unaweza ukafanya intiliaztion ya pointer variable kuwa null pointer(nullptr), null pointer katika C++ ni pointer ambayo haipoint sehemu yoyote. na mbeleni tunaweza kuangalia kama ni nullptr au sio.Ila zamani walitumia NULL au 0.</li> </ul> <pre><code>int* ptr = nullptr;\n</code></pre> <p>\u2b06\ufe0f Return to Top</p>"},{"location":"basics/strings/strings/","title":"Strings in C++","text":"<ul> <li>Strings in C++</li> <li>Introduction</li> <li>String Declaration</li> <li>String Initialization</li> <li>String Operations</li> <li>Concatenation</li> <li>Substring</li> <li>Length</li> <li>Copying</li> <li>Comparison</li> <li>Accessing Characters</li> <li>Modification</li> <li>Searching</li> <li>String Input Output</li> <li>String Manipulation Functions</li> <li>String Conversions</li> <li>Common Mistakes</li> </ul>"},{"location":"basics/strings/strings/#introduction","title":"Introduction","text":"<ul> <li>String is the array of characters, kama ambavyo kwenye upande wa rray tunaweza kuwa na array ambayo inaweza kuwa array ya number a array ya maneno; mfano wa array ya number <code>int number[2] = {1, 2, 4}</code> basi kwenye upande wa string ni same way kwamba string is the array of characters kwamba kila character ni kama array member ambao wapo ndani ya array hiyo.</li> </ul>"},{"location":"basics/strings/strings/#string-declaration","title":"String Declaration","text":"<ul> <li>Ili tuweze kufanya declaration ya string katika cpp tunatumia standard libraray ambayo inaitwa string <code>#include &lt;string&gt;</code> baada ya hapo fdeclaration za string yetu zitafanyika ndani ya header file yetu ila inategemeana na requirement zako je utaka kufanya string yako kuwa kama global variable au kama local variable, kwa upande wangu nitatumiamkama ni local variable, ndani ya main function Sintaksia yake kama ni declaration utaanza na string keyword ikifuatiwa na jina la string yako, kumbuka kujua njina la string ambalo liko descriptive   <code>Sintaksia: string jina_la_string</code></li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main(){\n\n  string name;\n  return 0;\n}\n</code></pre>"},{"location":"basics/strings/strings/#string-initialization","title":"String Initialization","text":"<ul> <li>String initialization ina jumlisha vitendo veto vya kufanya declaration na kuipa value ambayo kiujumla tunaita initialization, baada ya kufanya decalaration tunaweza kuipa value moja kwa moja au unaweza tumia approach ambyo nimetumia hapo chini.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main()\n{\n    string name;\n    name = \"Bjarne Stroustrup\";\n    cout &lt;&lt; name;\n    return 0;\n}\n</code></pre> <ul> <li>Kabla hatujaenda kwenye string operation ni muhimu kupitia kwa nini string ni array of charcters, array ni zero indexed type kwamba tunaweza kuacces value zote kwenye array kwa ktumia index basi kwenye upnade wa charcaters ni hviyo hivyo kwamba tunaweza kuacces value au characters fulani katika variable yetu <code>name</code> kwa kutumia index, mfano; Ili tuweze kupata index ya jina la kwanza katika string yetu ambayo inaitwa name tutatumia jina la string ikifuatiwa na square braxckets na ndani ya square brackets tutandika index ambayo tunataka tuapate charcater yetu ila kumbuka ondexing katika proram yetu inaanza na zero(ndio maana nilisema array ni zero indexed)</li> </ul> <pre><code>cout &lt;&lt; name[0];\n// output: B\n</code></pre> <ul> <li>Instance za string class tunaziita instance object, kama utakuwa uewahi kusoma Javascript ili kuweza kuaccess function za hiyo object tutaumia dot operator . basi kwenye upande wa C++ tutaumia dot(.) operator pia ili kuweza kuapata acces ya functions ambazo zipo ndani ya hiyo object yako</li> </ul>"},{"location":"basics/strings/strings/#string-operations","title":"String Operations","text":""},{"location":"basics/strings/strings/#concatenation","title":"Concatenation","text":"<ul> <li>Kufanya concatenation ni sawa na kuunganisha string variable moja na nyingine katika programu yako, mfano</li> </ul> <pre><code>string name = \"Elvis\";\nname += \" Mathew\";\ncout &lt;&lt; name;\n</code></pre> <ul> <li>Kumbuka kuacha nafasi kama hutaki jina linjuunganishe katika programu yako mfano <code>\" Mathew\"</code>, baada ya kufanya string conactenation pia <code>length</code> ya string itakuwa imabedailika katika programu yako.</li> </ul> <pre><code>cout &lt;&lt; name.length()\n// otput: 12\n</code></pre> <ul> <li>Ni mhimu kjua kwamba space inakua counted pia katika string yako kama ambayo kwenye programu yetu hajo ju kuna space <code>Elvis Mathew</code></li> </ul>"},{"location":"basics/strings/strings/#substring","title":"Substring","text":""},{"location":"basics/strings/strings/#length","title":"Length","text":"<ul> <li>Ili kuweza kupata lenght(urefu) wa string lako tutatumia builtin function ambayo inaitwa .length kumbuka tumesema kwamba ili tuweze kuaccess instance za object tutaumia dot(.) operator katika program yako.Ni mhimu kuzinagtia kwamba index na length za string ni vitu viwili tofauti na havifanani katika programu yako,kumbuka katika indexing tunaanza kuhesabu kanzia sifuri ila kutafuta lnght tunanzia moja the same way tunavyofanya hesabu.</li> </ul> <pre><code>string name = \"Elvis\";\ncout &lt;&lt; name.length();\n// ouput: 5\n</code></pre>"},{"location":"basics/strings/strings/#copying","title":"Copying","text":"<ul> <li>Kama ambavyo tunaweza kucopy value za integer data type kwenye variablenyingine basi kwenye string tunaweza kufanya hivyo pia.Ila ku,buka kufanya declaration za data type yakoambayo imekuwa declared kwa ajili ya kucopy.</li> <li>Declare string nyingine then ifanye kuwa sawa na ile string ambayo tayari imekuwa declared kwenye program yako.</li> </ul> <pre><code>string name = \"Elvis\";\nstring another;\n\nanother = name;\ncout &lt;&lt; another;\n</code></pre> <ul> <li>Hakikisha declarartion ya string ambayo umefanya kuopy imefanyika kinyume na hapo utapata error:   <code>error: 'another' was not declared in this scope|</code></li> </ul>"},{"location":"basics/strings/strings/#comparison","title":"Comparison","text":"<ul> <li>Katika cpp unaweza kufanya comparison ya string moja na string nyingine kwenye program yako kwa kutumia if statement, tunaweza kucompare kama string ni sam pia tunaweza kufanya comaprison kwamba ipi ni kubwa kuliko nyingine.</li> </ul> <pre><code>    string name = \"Elvis\";\n    string another;\n    name = another;\n\n    if(name == another)\n        cout &lt;&lt; \"Sawa\";\n</code></pre> <ul> <li>Kufanya comparison kuangalia string ipi ni kunwa kuliko string nyingine tunatumai comapsrion operator s katika program, yako, mfano wa comparions operators zipo nyingi mfano: (&lt;, &gt;, ==, &gt;=, &lt;=),mfano tunaweza katika mfano hapo chini tunafnya comparison ya string moja na nyingine ila katika kwa upande wa comapsion kwenye characters tunaangalia string ipi herufi kwa kwanza katika alphabet ni kubwa kuliko string nyingine hapo ndipo moja inakuwa imezidi nyingine katika progtram yetu.</li> </ul> <pre><code>string name = \"Elvis\";\nstring another = \"Maino\";\nif(name &gt; another){\n  cout &lt;&lt; name &lt;&lt; \" ni kubwa kuliko \" &lt;&lt; another;\n}\nelse{\n  cout &lt;&lt; name &lt;&lt; \" ni ndogo kuliko \" &lt;&lt; another;\n}\n</code></pre> <ul> <li>Using starts with and ends_with function,Tumia <code>starts_with()</code> na <code>ends_with()</code> kuangalia kama string kama imeanza na herufi fulani katika program yako au hapana.</li> </ul> <pre><code>string name = \"Elvis\";\ncout &lt;&lt; boolalpha &lt;&lt; name.starts_with(\"E\");\n// output: false\n</code></pre> <ul> <li>Kuangalia kama program imeishia na na charcater fulani katika programu yako unatumia <code>ends_with()</code> ndani ya mabano una tumia string <code>\"\"</code> ila ndani yake kunakuwa na herefi ambayo unataka kuangalia kama ipo</li> </ul> <pre><code>string name = \"Elvis\";\ncout &lt;&lt; boolalpha &lt;&lt; name.ends_with(\"s\");\n// output: true\n</code></pre> <ul> <li> <p>Kumbuka kwamba C++ ni case sensitive hivyo ukiandika kwamba C ya herufi kubwa ni tofauti na c ya herufi ndogo na kwenye upande wa string kama string yetu itakuwa katika herufi ndogo ila tumetafuta kwa kutumia <code>starts_with()</code> kwa herufi ndogo tutapata error katika programu yetu.</p> </li> <li> <p>Empty functionality: Kuna functionality nyingine katika program yetu ambayo inatumiak kuangalia kama string yetu ipo empty au !empty</p> </li> </ul> <pre><code>string name = \"Elvis\";\ncout &lt;&lt; boolalpha &lt;&lt; name.empty();\n// output: false\n</code></pre> <ul> <li>Front function: Font function inarudisha jibu kwamba first cahracter inayoaanza ni ipi,</li> </ul> <pre><code>string name = \"Elvis\";\ncout &lt;&lt; name.front();\n// output: E\n</code></pre> <ul> <li>Back function: Back function inarudisha herufi ya mwihso katika string yetu,kwahiyo insted of using indexing tunatumia <code>back()</code></li> </ul> <pre><code>string name = \"Elvis\";\ncout &lt;&lt; name.back();\n// output: s\n</code></pre> <ul> <li>Ila pia ili kuna njia ya kuweza kupata last character katika string yetu tunatumia.</li> </ul> <pre><code>string name = \"Elvis\";\ncout &lt;&lt; name[name.length() - 1];\n</code></pre>"},{"location":"basics/strings/strings/#accessing-characters","title":"Accessing Characters","text":"<ul> <li>Ili kuweza ku access characters fulani katika jina la string yako utatumai indexing ni same way jkwenye upande wa array ili kuweza kupata access unatuai squre bracket then ndani yake unasepecify number ambayo charcaters yako ipo ila kumbuka tunatumia zero indexing kwamba kama kuna neno <code>cpp</code> index ya kwanza inaanza kwenye zero hivyo kupata access ya herefu c tutaumia <code>string_name[specify_index_of_string]</code>.</li> </ul>"},{"location":"basics/strings/strings/#modification","title":"Modification","text":"<ul> <li>Kuna functionalities nyingi sana ambazo zitakuwezesha kufanya modification ya string yako katika program yako.Zipo nyingi ilakwa hapa tutaona baadhi ya function ambazo tunaweza kutumia katika program yetu.</li> <li>Using append function ,append() function inachukua parameter na parameter hiyo ni string inakua na quotes ila maneno yanakua ndani ya hizo quotes,basic function ya append ni kwamba ina add string nyingine kwenye string ya <code>name</code>.</li> </ul> <pre><code>string name = \"Elvis\";\nname.append(\" Makava\");\ncout &lt;&lt; name;\n// output: Elvis Makava\n</code></pre> <ul> <li>Using insert function.Insert function inachukua parameter mbili ambapo parameter ya kwanza ni position(sehemu) ambayo hiyo string yetu inabidi ianze na parameter ya pili ni string ambayo unataka uweke.Namna nyingine kwenye code yetu hapo chini ni sawa na kusem kwamba nenda kwenye position 0 kisha weka string <code>Naitwa</code></li> </ul> <pre><code>string name = \"Elvis\";\nname.insert(0,\"Naitwa \");\ncout &lt;&lt; name;\n// output: Naitwa Elvis\n</code></pre> <ul> <li>Using erase function.EInsert function inatumika kufuta character katika program yako,insert function inachukua parameters mili parameters ya kwanza ni index ambapo unataka string yako unataka ianze kufuta na parameter ya pili ni sehemu ambayo unataka parameter yako iishie ila parameter ya pili namba itakuwa excluded,Pia kwenye upande wa erase ni sawa na kusema nenda kwenye position o kisha futa charcaters 3 Ila kumbuka kwamba hizo silabu(characters) zinahesabiwa kuanzia sifuri mfano:</li> </ul> <pre><code>string name = \"Elvis\";\nname.erase(0, 3);\ncout &lt;&lt; name;\n// output: is\n</code></pre> <ul> <li>Using clear function:Erase function inatumika kufuta string yote katika program yako,hapa clear funtion haitakuwa na parameter yeyote ndani yake</li> </ul> <pre><code>string name = \"Elvis\";\nname.clear();\ncout &lt;&lt; name;\n// output: \n</code></pre> <ul> <li>Using replace function.Replace inachukua parameters tatu ,parameter ya kwanza nisawa na kusema nenda kwenye index position (0),kisha toa herufi 2 kisha parameter ya tatu ni string yaani ambayo unataka iwe katika program yako.</li> </ul> <pre><code>string name = \"Elvis\";\nname.replace(0, 2, \"EL\");\ncout &lt;&lt; name;\n// output: ELvis\n</code></pre>"},{"location":"basics/strings/strings/#searching","title":"Searching","text":"<ul> <li>Using find function:Kupitia find tutaweza kupata position ya content (character) ila itachukua the first charcater to occur in the string,ile ambayo ndio ya kwanza, hivyo kama tuna neno: <code>C++ is awesome</code> tukitumia find function tutapata occurance ya first chracter katika string maana kwa hapa sisi charcater tunayotafuta ni e</li> </ul> <pre><code>string cpp=\"C++ is awesome\";\ncout &lt;&lt; name.find('e');\n</code></pre>"},{"location":"basics/strings/strings/#string-input-output","title":"String Input Output","text":""},{"location":"basics/strings/strings/#string-manipulation-functions","title":"String Manipulation Functions","text":""},{"location":"basics/strings/strings/#string-conversions","title":"String Conversions","text":""},{"location":"basics/strings/strings/#common-mistakes","title":"Common Mistakes","text":"<p>NOTE Kuna baadhi ya functions za object ambazo zinakuwa accessed kwenye code block kwa kutumia dot operator hazipo,hivyo basi unaweza kutumia code editor nyingine ambayo inafanya hayo.</p> <p>\u2b06\ufe0f Return to Top</p>"},{"location":"basics/variables/variables/","title":"Variables in C++","text":"<ul> <li>Variables in C++</li> <li>Introduction</li> <li>Reserved Keywords</li> <li>Variable Declaration</li> <li>Variable Initialization</li> <li>Data Types</li> <li>Narrowing</li> <li>Generating Random Number</li> <li>Formatting Output</li> <li>Type Modifiers</li> <li>Scope of Variables</li> <li>Constants</li> <li>Variable Naming Conventions</li> <li>Mathematicall Expressions</li> <li>Order Of Operations</li> <li>Writing Output To The Console</li> <li>Reading From The Console</li> <li>Comments</li> <li>Working With Booleans</li> <li>Working With Characters And Strings</li> <li>Variable Scope and Lifetime</li> <li>Working With Standard Library</li> <li>Common Mistakes</li> </ul>"},{"location":"basics/variables/variables/#introduction","title":"Introduction","text":"<ul> <li>Variable ni container ambalo linahifadhi value yaani jawabu fulani,kkwa mfano tunaweza tukawa na ndoo inahifadhio maji hivyo kwenye ulimwengu wa programming variable yetu ni ndoo am,bayo ndio inahifadhi value ambayo ni maji</li> </ul>"},{"location":"basics/variables/variables/#reserved-keywords","title":"Reserved Keywords","text":"<ul> <li>Katika C++, reserved keywords ni maneno ambayo yana maana maalumu katika lugha na hayawezi kutumika katika kwa ajli ya mambo mengine kama kuname variabless au function.</li> </ul> <pre><code>and         and_eq      asm         auto\nbitand      bitor       bool        break\ncase        catch       char        class\ncompl       const       constexpr   const_cast\ncontinue    default     delete      do\ndouble      dynamic_cast else        enum\nexplicit    export      extern      false\nfloat       for         friend      goto\nif          inline      int         long\nmutable     namespace   new         noexcept\nnot         not_eq      nullptr     operator\nor          or_eq       private     protected\npublic      register    reinterpret_cast return\nshort       signed      sizeof      static\nstatic_assert static_cast struct      switch\ntemplate    this        throw       true\ntry\ntypedef     typeid      typename    union\nunsigned    using       virtual     void\nvolatile    wchar_t     while       xor\nxor_eq\n</code></pre> <ul> <li>Hizi maneno muhimu zina maana maalum katika lugha ya C++, na huwezi kuzitumia kama vitambulisho (majina kwa ajili ya variables, functions, n.k.) katika programu yako. Ni muhimu kuzingatia kuwa viwango vya C++ vinaweza kubadilika, na maneno mapya yanaweza kuongezwa katika toleo zijazo. Daima rejea kwenye nyaraka za viwango vya C++ vilivyopo kwa habari zilizosasishwa zaidi.</li> </ul>"},{"location":"basics/variables/variables/#variable-declaration","title":"Variable Declaration","text":"<ul> <li>Ili tuweze kutengeneza variable katika program yetu tunahitaji kuwa na data na type ya data hiyo ambayo inatakiwa kuhifadhiwa katika memory kisha jina la variable na jina la variable yako katika programming ianbidi liwe descriptive na meaningfull kwamba hata mtu mwingine akiangalia program yako anaju kwamba ni kitu gani kimefanyika katika program yako.Angalia mfano wa hili swali</li> </ul> <p>Declare two variables, one for temperature in Celsius and another for temperature in Fahrenheit.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    // Declare variables for temperature in Celsius and Fahrenheit\n    double temperatureCelsius;\n    double temperatureFahrenheit;\n\n    return 0;\n}\n</code></pre> <p>Tumetumia double wakati wa kufanya declaration yetu kwa sababu ina desimali na kama ni namba njima kama miaka ya mtu tutatumia <code>int</code></p> <pre><code>int age = 20;\nint miaka = 30;\n</code></pre> <ul> <li>Usisasahau kufanya termination kwa kutumia semicolon.</li> </ul>"},{"location":"basics/variables/variables/#variable-initialization","title":"Variable Initialization","text":"<ul> <li>Kufanya initilziatio ni kitendo cha kuipa value kwenye variable yako kwa mfano wa pale juu tulisema variable ni kam nddo ya hiyo ndoo ikiwa na vitu ndani ndio value sasa kama ndoo ipo tu na haina kitu katika program yako tunaita variable declaration ila kitendo cha nddoo kuwa na maji aktika program yako tunaita initialization, yaani ndoo inakuw na maji katika, sasa kwenye upnade wa C++ unaweza ukawa na jina la variable mablo ni miaka ya mtu na hiyo miaka ikawa na value yetu ambayo ni 20 kwamba ndio mika yake hatuwezi tunaksema miaka ya mtu ni double kwa sababu miaka ya mtu ni namba kamili aktika program yako. Mfano wa intialization</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n\n    int miaka = 20;\n    return 0;\n}\n</code></pre> <p>Hivyo ndivyo initialization inafanyika katika C++, ila pia tunaweza tukafnya kwa namna nyingine kwamba tunafanya declartio kwamnza kisha iniliaztion yunaweka kwa jina la program yetu.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n\n    int age;\n    age = 20;\n\n    return 0;\n}\n</code></pre> <p>Tunaweza pia tukafanya multiple declartion kwenye line moja katika program yetu kwa mfano kama tunanamba moja, kisha namba ya pili. Mfano</p> <pre><code>    // Declare multiple variables of the same data type in a single line\n    int num1, num2, result;\n</code></pre> <p>Hapo num1, num2, na result zote zinakuwa na data type moja mabyo ni integer.</p>"},{"location":"basics/variables/variables/#data-types","title":"Data Types","text":"<ul> <li> <p>Ili tuweze kufanya declaration ya variable katika C++ inabidi tuspecify data type yake kwanza ndio maana tunasema C++ <code>statically typed language</code> na type ya vaariable haiwezimkubadilika trough the life time of a program.Mifano mingine ya statically typed langauges ni C#, Java na TypeScript. Kwenye upande wa dynamically typed langauge kuna JavaScript, Ruby na Python.Katika hizi dynamic typed langauge hakuna hata ya kuipa variable data type ila data type yake itakuwa determined kutokana na value zilizokuwa assigned katika value iliyokuwepo kwenye variable na data type hiyo inaweza ikabadilika through the life time of a program.Sasa huo ndio utofauti wa statically na dynamic typed langauges.</p> </li> <li> <p>Integer data types zinahifadhi namba kamili ambazo zinaitwa int mfano wa wa integer data types kuna integer, short, long, long long, kila data type hapo inachukua kiasi fulani cha bytes katika memory mfano int inachukua 4 bytes, short inachkua 2 bytes, long inachukua 4 bytes na long long zinachkua namba ambazo ni kubwa zinahusika kwenye biggest mathematicall computations.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    // int: Standard integer type\n    int myInt = 42;\n    cout &lt;&lt; \"int: \" &lt;&lt; myInt &lt;&lt; endl;\n\n    // short: Short integer type\n    short myShort = 32767;  // Maximum value for a short\n    cout &lt;&lt; \"short: \" &lt;&lt; myShort &lt;&lt; endl;\n\n    // long: Long integer type\n    long myLong = 2147483647L;  // Maximum value for a long\n    cout &lt;&lt; \"long: \" &lt;&lt; myLong &lt;&lt; endl;\n\n    // long long: Long long integer type\n    long long myLongLong = 9223372036854775807LL;  // Maximum value for a long long\n    cout &lt;&lt; \"long long: \" &lt;&lt; myLongLong &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <ul> <li>Kwanini mwishoni wa literal float tunasepecify kwa kutumia herufi F</li> </ul> <p>Kitendo cha kuweka F katika floating point number (Mfano, 3.14F), ni kama unafanya manual kwamba itabidi iwe treated kama float badala ya double.Kwa sababau by default, floating point numbers literlas bila suffixes zinakuwa treated kama double hiyo endapo itatumika kwenye mathematicall calculations fulani kuna baddhi ya data zitapotezwa. Hii inawreza ikawa ni muhimu ili kuweza kuhakiksha memory usage inatumika vizuri hususani pale pale unavyodeal na namba kubwa aina va float</p> <ul> <li> <p>Kwanini mwishoni wa literal long tunasepecify kwa kutumia herufi L</p> </li> <li> <p>Kitendo ya ku append L kwenye integer literal (Mfano: 42l), ni kama maelekezo yale pale ju ila hapa unaspecify kwamba inabidi iwe treated kama long type badala ya int. Bila suffix integer literals itakuwa treated kama integer.    Hii muhimu kama unafanya kazi na large integers yaani integers kubwa inaweza ikazdidi range ya int, unahakikisha kwamba literla inawakailisha values kubwa.</p> </li> <li> <p>Kama data type yako ni long long usisashau kuweka LL double LL kmwishoni wa literal yako.Mfano:</p> </li> </ul> <pre><code>long long number2 = 100000000000000000000000000LL;\n</code></pre> <pre><code>float myFloat = 3.14F;  // Explicitly a float\nlong myLong = 1234567890L;  // Explicitly a long\n</code></pre> <p></p> <ul> <li>Kwenye upande float data types, kuna float zenyewe ambazo zinachukua 4 bytes kuna double ambazo zinachukua 8 bytes na pia kuna long double ambazo zinachukua 8 bytes of memory pia.Mda mwingi tutatumia double ila kuweza kuhifadhi monetary values kwanini hatutumiii float kwa sababu kuna baadhi ya data zinapotezwa.</li> </ul> <p></p> <ul> <li>Boolean data types, bolean data types katika  c   ++,zinahusika kuhifadhi data types mabzo zi kweli au sikweli yaaani tre or false, kuna data types nyingine ni char ambazo zinahusika khifadhi single character.</li> </ul> <p></p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    float myFloatVariable;\n    long double myLongDoubleVariable;\n    double myDoubleVariable;\n    bool myBoolVariable;\n    char myCharVariable;\n\n    // Assigning values to the variables\n    myFloatVariable = 3.14f;\n    myLongDoubleVariable = 3.14159265358979323846L;\n    myDoubleVariable = 3.14159;\n    myBoolVariable = true;\n    myCharVariable = 'A';\n\n    // Printing the values\n    cout &lt;&lt; \"Float: \" &lt;&lt; myFloatVariable &lt;&lt; endl;\n    cout &lt;&lt; \"Long Double: \" &lt;&lt; myLongDoubleVariable &lt;&lt; endl;\n    cout &lt;&lt; \"Double: \" &lt;&lt; myDoubleVariable &lt;&lt; endl;\n    cout &lt;&lt; \"Bool: \" &lt;&lt; boolalpha &lt;&lt; myBoolVariable &lt;&lt; endl;\n    cout &lt;&lt; \"Char: \" &lt;&lt; myCharVariable &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <ul> <li> <p>Kwenye <code>implicit</code> ni automatic ila <code>explicit</code> ni manual kwamba conversion zinakuwa zinafanyiak manula kwenye program na hizi zinafanywa na wewe ila upande wa implicit ni automatic.</p> </li> <li> <p>Pia kwenye C++ kuna option ya kutumia uato keyword kwamba compiler yenyewe ndio utagundua data type yako ni ipi!</p> </li> </ul> <pre><code>\n</code></pre>"},{"location":"basics/variables/variables/#narrowing","title":"Narrowing","text":"<ul> <li>Katika C++, narrowing ni kitendo cha kufanya conversion ya value ya data type kubwa kwenda data type ndogo,kutokana na hiloninapelekea kupotea kwa baadhi ya data.Narrowing conversions kiujumla huwa inapelekea kupotea kwa data.</li> </ul> <p>Mfano: Kwa mfano una floating-point number <code>float myFloat = 3.14</code> na unataka kubadili kwenda integer <code>int</code>.Utafanya hivi:</p> <pre><code>float myFloat = 3.14;\nint myInt = myFloat;\n</code></pre> <p>Hio conersion hapa juu inaitwa narrowing kwa sababu unajaribu kuifanya larger type ambayo ni float kwenda small data type (int).Katika situation kama hii uatona unapewa warning au error kwa sababu sio safe conversion.</p>"},{"location":"basics/variables/variables/#generating-random-number","title":"Generating Random Number","text":"<ul> <li>Random number ni mhimu palea ambapo unataka kugenerate random number katika game ambale linaweza kuwa rolling dice au pia kwenye kutengeneza guessing game katika C++.Kuna libtrary inaitwa scdlib katika C++ ndio libraray ambayo inatupa uwezo wa kutengenza random number kwa kutumia rand function katika C++</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nint main()\n{\n    srand(time(0));\n    int number = rand() % 10;\n    cout &lt;&lt; number;\n    return 0;\n}\n</code></pre>"},{"location":"basics/variables/variables/#formatting-output","title":"Formatting Output","text":"<ul> <li> <p>Katika C++, formatting output inakuwa achieved kwa kutumia njia mbalimbali. Njia ambayo watu wengi wanatumia ni std::cout kwa ajili ya output kwenye console na std::setw, std::setprecision na maniluators nyingine ila manipulation header inayotumika ni  kwa ajili ya formatting.Ili kuweza kuformat string tunatumia string manipulators, function ambayo tunatumia kwa ajili ya kuformat na kufanya modification ya string. <li> <p>Mfano wa string maniupulators ni <code>setw()</code> inatumika kwa ajili kuset width ya string pale inavyokuwa prited kwenye console, chukulia mfano hapo chini bila kutumia <code>setw()</code></p> </li> <pre><code>    cout &lt;&lt; \"C++\" &lt;&lt; \"JavaScript\" &lt;&lt; endl\n         &lt;&lt; \"Java\" &lt;&lt; \"C\";\n        //  C++JavaScript\n        //  JavaC\n</code></pre> <ul> <li>Hapo juu unaona kwamba maneno haya yameungana ila kutokana na uwepo wa setw() tunaweza tukaweka kiasi fulani cha nafasi kwa ajili ya kila string.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nint main() {\n    std::cout &lt;&lt; setw(5) &lt;&lt; \"C++\" &lt;&lt; setw(15) &lt;&lt; \"JavaScript\" &lt;&lt; endl\n              &lt;&lt; setw(5) &lt;&lt; \"Java\" &lt;&lt; setw(15) &lt;&lt; \"C\";\n    return 0;\n}\n</code></pre> <p><code>setw(5)</code> inaweka upana wa string ya kwanza kwenda characters 5,</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nint main() {\n    int intValue = 42;\n    double doubleValue = 3.14159;\n\n    // Basic output\n    st::cout &lt;&lt; \"Integer value: \" &lt;&lt; intValue &lt;&lt; endl;\n    cout &lt;&lt; \"Double value: \" &lt;&lt; doubleValue &lt;&lt; endl;\n\n    // Formatting using setw\n    cout &lt;&lt; setw(20) &lt;&lt; \"Integer value: \" &lt;&lt; intValue &lt;&lt; endl;\n    cout &lt;&lt; setw(20) &lt;&lt; \"Double value: \" &lt;&lt; doubleValue &lt;&lt; endl;\n\n    // Formatting floating-point precision\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2); // Set precision to 2 decimal places\n    cout &lt;&lt; \"Double value with precision: \" &lt;&lt; doubleValue &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"basics/variables/variables/#type-modifiers","title":"Type Modifiers","text":""},{"location":"basics/variables/variables/#scope-of-variables","title":"Scope of Variables","text":""},{"location":"basics/variables/variables/#constants","title":"Constants","text":"<ul> <li>Constants ni kile kitu ambacho hakibadiliki, mafno wa constants ni PI na Acceleration due to gravity. Katika C++ constants inatumika kwenye ile data type yetu ambcho haibadiliki au kama hatuhitaji hiyo data type ibadilike katika program yetu. Mfano Program ya kutafuta eneo la duara katika program yetu. Formula ya kutafuta duara ni A=\u03c0r2 sasa kwenye program yetu tubahitaji Pie iwe constants sasa je tunafanyaje basi hapo utaanza na const keyword ikifuatiwa na data type ya hiyo variable yako na kisha jina ya variable na value ya data type yako,kumbuka huwei kufanya declaration tu ya consnats lazima va value iwe initialized katika program yako.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    // Declare variables\n    double radius, area;\n    const double pi = 3.14159;  // A common approximation for pi\n\n    return 0;\n}\n</code></pre> <p>Hivyo ndivyo namna constant inatumia kwenye C++.</p>"},{"location":"basics/variables/variables/#variable-naming-conventions","title":"Variable Naming Conventions","text":"<ul> <li> <p>Ni muhimu kufuata naming conventions nzuri katika program yako, Je hizo naming conventions ambazo ni za muhimu ni zipi,</p> <p>1. Snake Case: Snake case katika ulimwengu wa programming tunatumia kama kuna multiple words katika program yako, kwa mfano kama umefanya declaration ya variable yako ambyo inaitwa file size, tubatumia underscore kutofautisha neno moja na neno jingine.</p> <pre><code>#include &lt;iostream&gt;\n\nint main  () {\n    int file_size = 10; // Snake Case\n\n    return 0;\n}\n</code></pre> </li> </ul> <p>2. Pascal Case: Katika pascal naming convention tunafanya capitalization ya kila neno ambalo lio kwenye variable yako.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int FileSize = 10;\n\n    return 0;\n}\n</code></pre> <ol> <li> <p>Camel Case: Camel case na pascal case ni kama zinafanana ila utofauti wao ni kwamba kwenye upande wa camel case herefi ya kwanza ndio inakuwa katika lowercase ila herufi nyingine ya kwanza katika neno lengine linakuwa katika upprecase yaani herufi kubwa.</p> </li> <li> <p>Hungarian Naming convention. Hungarian naming convention,kila neno linaloanza katika jina la variable yako linakuwa na data type yake kwa mwanzoni kwamba kama variable yetu ni file size hivyo herufi yetu ya kwanza itakuwa ni i</p> </li> </ol> <p>```cpp</p>"},{"location":"basics/variables/variables/#include","title":"include  <p>int main() {     int iFileSize = 10;</p> <pre><code>return 0;\n</code></pre> <p>}</p> <pre><code>## Mathematicall Expressions\n\n- Kitendo cha kuweza kufanya kujumlisha, kutoa , kuzidisha na kutoa ndio mathematical expression ila hapa tutatongelea basic mathematical expression kama kuzidisha, kwenye upande wa C++, pale tutavyofanya basic operation kama kujumlisha ua kuzidisha tunatumia data types integer, angalia code hapo chini tumefanya declaration ya number1 na number2,\n\n```cpp\n#include &lt;iostream&gt;\n\nusing namespace std; \n\nint main() {\n    int number1 = 10;\n    int number2 = 3;\n    int result = number1 / number2;\n    cout &lt;&lt; result;\n\n    return 0;\n}\n</code></pre> <p>ila pale tunapofanya operation yetu kwa kutumia result data type, kama tumetumia divison basi kuna baadhi ya data zinakuwa zimekatwa kuweka result variable kama double haitasaidia ili baadhi ya namba zisikatwe.Ila kama result kama data type itakuwa katika double na moja katia ya number1 au number2 itakuwa katika double, mfano</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std; \n\nint main() {\n    int number1 = 10;\n    double number2 = 3;\n    double result = number1 / number2;\n    cout &lt;&lt; result;\n    // output: 3.33333\n    return 0;\n}\n</code></pre> <ul> <li>Kuna operator nyingine katika C++ mabyo ni modulus operator ambayo inarudisha baki ya value yako</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std; \n\nint main() {\n    int number1 = 10;\n    int number2 = 3;\n    int result = number1 % number2;\n    cout &lt;&lt; result;\n\n    return 0;\n}\n</code></pre> <ul> <li>Kama tunataka kuongeza mojakwa variable yetu au kupunguza moja kwa variable yetu tutatumia increment na decrement operator katika C++,Mfano tuntaka kuongeze moja kwenye number1 variable au tunataka kupunguza moja kwenye number1</li> </ul> <pre><code>    int number1 = 10;\n    int number2 = 3;\n\n    number1++;\n    number1--;\n</code></pre> <p>Ila kumbuka kwamba katika C++, kuna post increment yaani baada ya kuna prefix increment kabla.Kumbuka utofauti kati ya postfix na prefix. Mfano</p> <pre><code>    int number1 = 10;\n    int number2 = number1++;\n\n    cout &lt;&lt; number1;\n    // \n</code></pre>","text":""},{"location":"basics/variables/variables/#order-of-operations","title":"Order Of Operations","text":"<ul> <li> <p>Kama ambavyo tulisoma katika O-level kwamba kuna magazijuto au tunaweza tukasema BODMAS Kwenye lugha ya kingereza, sasa kwenye upande wa C++ order of operations pia zipo hivyo unavyoandika program ni vizuri na muhimu kuzingatia order of operations katika C++.</p> </li> <li> <p>Katika C++, order of operations ndio zina determine mfuatano ambao operators mbambali zinakuwa evaluated katika expression. Order of operations katika operesheni katika C++ ni sawa na order za operesheni katika hesabu yaani mathematics.</p> </li> </ul> <p></p>"},{"location":"basics/variables/variables/#writing-output-to-the-console","title":"Writing Output To The Console","text":"<ul> <li>Angalia program ifuatayo,</li> </ul> <pre><code>#include &lt;iostream&gt;\n\n\nint main() {\n    std::cout &lt;&lt; \"Karibu Ujifunze C++\";\n    return 0;\n}\n</code></pre> <p>Cout inawakilisha <code>standard output stream</code>, stream inawakilisha sequence of characters, standard output ni console au terminal window, hivyo kupitia cout tunaweza tukaprint sequence za characters katika console a terminal, na hizi &lt;&lt; left angled brackets zinaitwa stream insertion operator ni operator ambayo inatumika kfanya insertio kitu fulani kwenda kwenye output stream ila kwenye program yetu tutaspecify maneno yaani chracters ambazo ni <code>Karibu Ujifunze C++</code> na hzio chracters zitakuwa ndani ya single au double quotes katika program yetu.</p>"},{"location":"basics/variables/variables/#reading-from-the-console","title":"Reading From The Console","text":"<ul> <li>Katika C++ tuna standard output na kuna standard input standard input itatuwezesha kuweza kusoma(read) input ya user kutoka kwenye console,object hiyo inayotumika ili tuweze kyread input from the console ni <code>cin</code>, mfano wa program yetu hapa chini, tengeneza program ambyo itamuwezesha mtumiaji wetu aweze kuingiza namba moja kisha hiyo namba ihifadhiowe kwenye variable.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; \"Ingiza namba: \";\n    int number;\n    cin &gt;&gt; number;\n\n    cout &lt;&lt; number;\n    return 0;\n}\n</code></pre> <ul> <li> <p>&lt;&lt; inaitwa <code>stream extraction operator</code> ni tofauti na <code>stream insertion operator</code> variable yetu amabyo imekuwa declared katika program yetu ni int na endapo user ataigiza float basi kipande wa integer tu ndio kitachukuliwa na kile cha float kuanzia desimali kitakatwa,ila kama unataka mtumiaji wako aweze kuingiza float hakikisha data type yako inakuwa declared kama float.</p> </li> <li> <p>Kwa kutumia cin unaweza ukatengeneza a simple calculator ambayo itaumezesha user kuingiza namba ya kwanza kisha namba ya pili na wishoni inafanya calculation yako. Hii ni kama exercise hivyo hakikisha umepitia hiyo.</p> </li> </ul>"},{"location":"basics/variables/variables/#comments","title":"Comments","text":"<ul> <li>Katika C++, comments ni zile code ambazo haziwezi kuwa executed na compiler yetu,kuna ian mbili za comments kuna single line ambazo zinaandikwa kwa kutumia back slash // na pia kuna multi-line comments ambazo zinakuwa katika mtundo huu /**/, Mfano:</li> </ul> <pre><code>// This is a single-line comment\nint x = 5;  // This is another single-line comment\n\n/*\nThis is a multi-line comment.\nIt can span multiple lines and is useful for longer explanations or commenting out\nlarger blocks of code.\n*/\n\nint y = 10;\n\n/*\nYou can also use multi-line comments to temporarily disable sections of code:\nint z = 15;\n*/\n</code></pre> <ul> <li>Kujua umuhimu wa comments katika program yako ni muhimu sana, kjua zaidi kuhusu comments unaweza ukapitia hapa   .</li> </ul>"},{"location":"basics/variables/variables/#working-with-booleans","title":"Working With Booleans","text":"<ul> <li>Kama ilivyo katika lugha nyingine kama JavaScript hata pia C, kuna namna jinsi ya kufanya kazi na bullian values(boolean values) basi kwenye C++ pia kuna bulliani values,boolean values ziopo true na false katika C++, Mfano:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    bool amesajiliwa = true;\n    cout &lt;&lt; amesajiliwa;\n    // output: 1\n    return 0;\n}\n</code></pre> <p>Tumefanya declaration na initialization ya variable yetu ambayo inaitwa amesajiliwa na output ni 1, Kwanini? Katika C++ values za ndani (internal values) zinakuwa represented kwa kutumia sifuri na moja (0 na 1), hivyo Sifuri ni sawa na false na moja ni sawa na true.Pia kama tunataka tuone value ya kweli au Sio Kweli aktika terminal badala ya 0 na 1? Tuna string manipulators nyingine inaitwa boolalpha badala ya print value ya bool tutatumia boolalpha ili kuweza manipulate string yetu.Angalia mfano hapo chini!</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    bool amesajiliwa = true;\n    cout &lt;&lt; boolalpha &lt;&lt; amesajiliwa;\n    // output: true\n    return 0;\n}\n</code></pre> <p>boolapha ikishatumika kwa mara ya kwanza tu kwa kila baada ya boolean values zote zinazokuwa printed kwentye screen zitakuwa formatted Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    bool amesajiliwa = true;\n    bool anaumwa = false;\n    cout &lt;&lt; boolalpha &lt;&lt; amesajiliwa &lt;&lt; endl;     // output: true\n    cout &lt;&lt; anaumwa;     // output: false\n\n    return 0;\n}\n</code></pre> <p>Ili kuweza kuturn off boolapha utatumia <code>noboolalpha</code> Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    bool amesajiliwa = true;\n    bool anaumwa = false;\n    cout &lt;&lt; noboolalpha &lt;&lt; amesajiliwa &lt;&lt; endl;     // output: 1\n    cout &lt;&lt; anaumwa;     // output: 0\n\n    return 0;\n}\n</code></pre>"},{"location":"basics/variables/variables/#working-with-characters-and-strings","title":"Working With Characters And Strings","text":"<ul> <li>Katika C++ kuna built-in data types ngyingine kama char na string, char inatumika kufanya kazi na single character ila string inatumuika kufanya kaz na mfuatana wa characters (group of characters), Kufanya declaration ya character tunaanza na char kewyord ikifuatiwa na jia la character yako.Charcter yako itakaa ndani ya single quotes '' na sio double quotes \"\"</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    char ch = 'a';\n    cout &lt;&lt; ch;\n    // output: a\n    return 0;\n}\n</code></pre> <p>Kufanya declaration ya string ni rahisi utofauti wake na charcter ni data type na pia value ya string inakuwa ndani ya double quotes, Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string lugha = \"C++\";\n    cout &lt;&lt; lugha;\n    // output: C++\n    return 0;\n}\n</code></pre> <p>Kupitia string tunaweza tukatumia kuweza kupata details za mtumiaji kwa kutumia cin,kwamba mtumiaji ataingiza jina lake kisha tutamwambia karibu mtumiaji(jina lake),Mfano:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string name;\n    cout &lt;&lt; \"Jina lako nani? \";\n    cin &gt;&gt; name;\n    cout &lt;&lt; \"Karibu \" &lt;&lt; name;\n\n    // output: \n    return 0;\n}\n</code></pre> <p>Endapo mtumiaji wetu ataingiza jina la kwanza na la katikati kuna baadhi ya maneno yatakatwa katika kwa sababu kwa kutumia cin itaangalia kwamba sehemu ambazo kuna space program yetu ndio inaishia hapo. program yetu je ili kuweka kusolve tatizo hilo tunfanyaje? Basi hapa tutaumia <code>getline()</code> function na getline function inachukua vitu viwili yaani parameters mbili, ya kwanza input stream <code>cin</code> na ya pili ni string variable ambayo ni <code>name</code></p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string name;\n    cout &lt;&lt; \"Jina lako nani? \";\n    getline(cin, name);\n    cout &lt;&lt; \"Karibu \" &lt;&lt; name;\n\n    return 0;\n}\n</code></pre>"},{"location":"basics/variables/variables/#variable-scope-and-lifetime","title":"Variable Scope and Lifetime","text":"<ul> <li>Variable katika programming ina scope mbili ambazo ni global scope na local scope, Variable katika global scope zinakuwa nje ya main function na variable za local scope zinakuwa ndani ya main function za variable iliopo ndani ya global scope inaweza kuwa accessed hata ndani ya local scope yaani ndani ya main function.</li> </ul>"},{"location":"basics/variables/variables/#working-with-standard-library","title":"Working With Standard Library","text":"<p>-</p>"},{"location":"basics/variables/variables/#common-mistakes","title":"Common Mistakes","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"intermediate/algorithms/algorithms/","title":"Algorithms in C++","text":"<ul> <li>Introduction</li> <li>Algorithm Analysis</li> <li>Searching Algorithms</li> <li>Linear Search</li> <li>Binary Search</li> <li>Interpolation Search</li> <li>Sorting Algorithms</li> <li>Bubble Sort</li> <li>Selection Sort</li> <li>Insertion Sort</li> <li>Merge Sort</li> <li>Quick Sort</li> <li>Graph Algorithms</li> <li>Depth-First Search (DFS)</li> <li>Breadth-First Search (BFS)</li> <li>Dijkstra's Algorithm</li> <li>Bellman-Ford Algorithm</li> <li>Prim's Algorithm</li> <li>Kruskal's Algorithm</li> <li>Dynamic Programming</li> <li>Greedy Algorithms</li> <li>Backtracking</li> <li>String Matching Algorithms</li> <li>Common Algorithms</li> <li>Algorithmic Paradigms</li> <li>Choosing the Right Algorithm</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"intermediate/algorithms/algorithms/#introduction","title":"Introduction","text":""},{"location":"intermediate/algorithms/algorithms/#algorithm-analysis","title":"Algorithm Analysis","text":""},{"location":"intermediate/algorithms/algorithms/#searching-algorithms","title":"Searching Algorithms","text":""},{"location":"intermediate/algorithms/algorithms/#linear-search","title":"Linear Search","text":""},{"location":"intermediate/algorithms/algorithms/#binary-search","title":"Binary Search","text":""},{"location":"intermediate/algorithms/algorithms/#interpolation-search","title":"Interpolation Search","text":""},{"location":"intermediate/algorithms/algorithms/#sorting-algorithms","title":"Sorting Algorithms","text":""},{"location":"intermediate/algorithms/algorithms/#bubble-sort","title":"Bubble Sort","text":""},{"location":"intermediate/algorithms/algorithms/#selection-sort","title":"Selection Sort","text":""},{"location":"intermediate/algorithms/algorithms/#insertion-sort","title":"Insertion Sort","text":""},{"location":"intermediate/algorithms/algorithms/#merge-sort","title":"Merge Sort","text":""},{"location":"intermediate/algorithms/algorithms/#quick-sort","title":"Quick Sort","text":""},{"location":"intermediate/algorithms/algorithms/#graph-algorithms","title":"Graph Algorithms","text":""},{"location":"intermediate/algorithms/algorithms/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":""},{"location":"intermediate/algorithms/algorithms/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":""},{"location":"intermediate/algorithms/algorithms/#dijkstras-algorithm","title":"Dijkstra's Algorithm","text":""},{"location":"intermediate/algorithms/algorithms/#bellman-ford-algorithm","title":"Bellman-Ford Algorithm","text":""},{"location":"intermediate/algorithms/algorithms/#prims-algorithm","title":"Prim's Algorithm","text":""},{"location":"intermediate/algorithms/algorithms/#kruskals-algorithm","title":"Kruskal's Algorithm","text":""},{"location":"intermediate/algorithms/algorithms/#dynamic-programming","title":"Dynamic Programming","text":""},{"location":"intermediate/algorithms/algorithms/#greedy-algorithms","title":"Greedy Algorithms","text":""},{"location":"intermediate/algorithms/algorithms/#backtracking","title":"Backtracking","text":""},{"location":"intermediate/algorithms/algorithms/#string-matching-algorithms","title":"String Matching Algorithms","text":""},{"location":"intermediate/algorithms/algorithms/#common-algorithms","title":"Common Algorithms","text":""},{"location":"intermediate/algorithms/algorithms/#algorithmic-paradigms","title":"Algorithmic Paradigms","text":""},{"location":"intermediate/algorithms/algorithms/#choosing-the-right-algorithm","title":"Choosing the Right Algorithm","text":""},{"location":"intermediate/algorithms/algorithms/#best-practices","title":"Best Practices","text":""},{"location":"intermediate/algorithms/algorithms/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"intermediate/data_structures/dataStructure/","title":"Data Structures in C++","text":"<ul> <li>Introduction</li> <li>Arrays</li> <li>Linked Lists</li> <li>Stacks</li> <li>Queues</li> <li>Trees</li> <li>Binary Trees</li> <li>Binary Search Trees</li> <li>Graphs</li> <li>Hashing</li> <li>Heaps</li> <li>Advanced Data Structures</li> <li>Trie</li> <li>Segment Tree</li> <li>Skip List</li> <li>Choosing the Right Data Structure</li> <li>Common Operations and Algorithms</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"intermediate/data_structures/dataStructure/#introduction","title":"Introduction","text":""},{"location":"intermediate/data_structures/dataStructure/#arrays","title":"Arrays","text":""},{"location":"intermediate/data_structures/dataStructure/#linked-lists","title":"Linked Lists","text":""},{"location":"intermediate/data_structures/dataStructure/#stacks","title":"Stacks","text":"<ul> <li>Stack ni data structure ambayo computer inatumia kwa ajili ya kufanya implementation ya function calls.Stack ni list ya elements ambazo ni homogenous zikiwa na adition na deletion mwishoni,<code>top</code> of the stack,chukua mfano ukiwa na list ya vitabu ambayo vipo kwenye list ili ambavyo vipo kwenye kabati <code>kitabu cha hesabu</code> <code>kitabu cha C++</code> <code>kitabu cha Chemistry</code> <code>kitabu cha History</code> na <code>kitabu cha English</code> kila kitabu kimoja kipo juu ya chenzake,ili kuweza kupata <code>kitabu cha History</code> inabidi kutoa kitabu cha hesabu, C++ na kitabu cha Chemistry.Baada ya kutoa vitabu hivyo,kitabu cha History kinakua top,yaani top element kwenye stack.</li> </ul>"},{"location":"intermediate/data_structures/dataStructure/#queues","title":"Queues","text":""},{"location":"intermediate/data_structures/dataStructure/#trees","title":"Trees","text":""},{"location":"intermediate/data_structures/dataStructure/#binary-trees","title":"Binary Trees","text":""},{"location":"intermediate/data_structures/dataStructure/#binary-search-trees","title":"Binary Search Trees","text":""},{"location":"intermediate/data_structures/dataStructure/#graphs","title":"Graphs","text":""},{"location":"intermediate/data_structures/dataStructure/#hashing","title":"Hashing","text":""},{"location":"intermediate/data_structures/dataStructure/#heaps","title":"Heaps","text":""},{"location":"intermediate/data_structures/dataStructure/#advanced-data-structures","title":"Advanced Data Structures","text":""},{"location":"intermediate/data_structures/dataStructure/#trie","title":"Trie","text":""},{"location":"intermediate/data_structures/dataStructure/#segment-tree","title":"Segment Tree","text":""},{"location":"intermediate/data_structures/dataStructure/#skip-list","title":"Skip List","text":""},{"location":"intermediate/data_structures/dataStructure/#choosing-the-right-data-structure","title":"Choosing the Right Data Structure","text":""},{"location":"intermediate/data_structures/dataStructure/#common-operations-and-algorithms","title":"Common Operations and Algorithms","text":""},{"location":"intermediate/data_structures/dataStructure/#best-practices","title":"Best Practices","text":""},{"location":"intermediate/data_structures/dataStructure/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"intermediate/enumerations/enumerations/","title":"C++ Enumerations","text":"<ul> <li>Introduction to Enumerations</li> <li>Declaring Enumerations</li> <li>Enum Constants and Values</li> <li>Using Enums in Code</li> <li>Enum Class</li> <li>Plain Enums Vs Enum Class</li> <li>Strongly Typed Enums</li> <li>Enumeration Underlying Type</li> <li>Enum Operations</li> <li>Switch Statements with Enums</li> <li>Enum as Flags</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"intermediate/enumerations/enumerations/#introduction-to-enumerations","title":"Introduction to Enumerations","text":"<ul> <li>Enumeration ni aina ya data ambayo inabeba thamani za integer(interger values)</li> </ul>"},{"location":"intermediate/enumerations/enumerations/#declaring-enumerations","title":"Declaring Enumerations","text":"<ul> <li>Declaration ya enum inaanza na enum keyword ikifuatiwa na jina la enum ambalo linabidi kuwa katika <code>PascalCase</code> kisha mabano singasinga(curly braces {}) na ndani ya mabano ndio kunakuwa na enumerators.Mfano:</li> </ul> <pre><code>enum Rangi\n{\n    Nyeupe,\n    Nyeusi,\n    Kijani\n};\n</code></pre> <p>Declaration ya enum inaitwa <code>Rangi</code> ikiwa na enumerators <code>Nyeupe</code>, <code>Nyeusi</code> na <code>Kijani</code>.Enumerator inafupishwa kama enum.</p> <p>Kuna aina mbili na enumerations:</p> <ul> <li>Enum classes</li> <li>Plain Enums</li> </ul>"},{"location":"intermediate/enumerations/enumerations/#enum-constants-and-values","title":"Enum Constants and Values","text":"<ul> <li>Katika C++, enum constanrs ni values ambazo zimekuwa named katika enum.Ni identifiers ambazo zinawakilisha thamani za integer.</li> </ul> <pre><code>enum class Rangi\n{\n    Nyeupe, // Enum constant with value 0\n    Nyeusi, // Enum constant with value 1\n    Kijani // Enum constant with value 2\n};\n</code></pre> <p>Kama huataassign values explicit, compiler inazipa thamani kuanzia 0, kisha itakuwa inafanya incrementation kwa moja kwa kila enumerator iliyopo kuanzia chini kushuka chini.Mfano</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum class Rangi\n{\n    Nyeupe, // Enum constant with value 0\n    Nyeusi, // Enum constant with value 1\n    Kijani  // Enum constant with value 2\n};\n\nint main()\n{\n    cout &lt;&lt; static_cast&lt;int&gt;(Rangi::Nyeupe) &lt;&lt; endl\n         &lt;&lt; static_cast&lt;int&gt;(Rangi::Nyeusi) &lt;&lt; endl\n         &lt;&lt; static_cast&lt;int&gt;(Rangi::Kijani);\n    return 0;\n}\n/* Output:\n0\n1\n2\n*/\n</code></pre>"},{"location":"intermediate/enumerations/enumerations/#using-enums-in-code","title":"Using Enums in Code","text":"<ul> <li>Enums katika C++ zinaweza kutumika katika operesheni mbalimbali kama integers, kwa sababu ni set ya named integer constants.Unaweza kufanya arithmetic operations ukiwa na enum values.</li> </ul>"},{"location":"intermediate/enumerations/enumerations/#plain-enums-vs-enum-class","title":"Plain Enums Vs Enum Class","text":"<ul> <li>enum classes,ni enum ambazo majina ya enumerators(kama Kijani) yapo local kwa enum na thamani(value) zake hazijibadilishi kiautomatiki(implicity) kwenda kwenye aina nyingine.Mfano wa declaration ya enum kwa kutumia class:</li> </ul> <pre><code>enum class Rangi\n{\n    Nyeupe, // Enum constant with value 0\n    Nyeusi, // Enum constant with value 1\n    Kijani  // Enum constant with value 2\n};\n</code></pre> <ul> <li> <p>Kwenye mfano hapo juu tumefanya declaration ya enum Rangi ikiwa na enumerators Nyeupe,Nyeusi,Kijani,hivyo unaweza kufanya declaration ya enum nyingine ikiwa na enumerators sawa na wale walipo kwenye enum Rangi bila kupata error kwa sababu class enums zipo local scoped.</p> </li> <li> <p>Enumerators zinakuwa na default values ila pia unaweza ukawa na enum ambayo enumerators zake ndani ya program values zake umedefine ziwe explicit kama integer au character.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Define an enumeration named Status with two enumerators: Success and Failure\nenum class Status : int\n{\n    Success,\n    Failure\n};\n\nint main()\n{\n    // Declare a variable of type Status\n    Status result = Status::Success;\n\n    // Check the value of the result variable\n    if (result == Status::Success)\n    {\n        cout &lt;&lt; \"Operation was successful.\" &lt;&lt; endl;\n    }\n    else if (result == Status::Failure)\n    {\n        cout &lt;&lt; \"Operation failed.\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li> <p>Kwenye mfano hapo juu, tumefanya definition ya enum class Status ikiwa na enumerators mbili: Success na Failure, na pia tumespecify type explicit kuwa ni integer.Muda wa kutumia enum class, unahitaji kutumia scope resolution operator :: kupata access ya enumerators.</p> </li> <li> <p>plain enums,ni enum ambazo majina ya enumerator yapo kwenye uwanja(scope) sawa na enum na thamani(value) zake zinajibadilisha kuwa za tarakimu(integer).Kwa mfano tuna enum ambayo inaitwa Rangi ikiwa na rangi zifuatazo <code>nyeupe</code> <code>nyekundu</code> na <code>nyeusi</code>.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum Rangi\n{\n    Nyeupe,\n    Nyekundu,\n    Nyeusi\n};\n\nint main()\n{\n    cout &lt;&lt; \"Rangi Nyeupo ni namba: \" &lt;&lt; Rangi::Nyeupe &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Kutoka kwenye mfano hapo juu jina la enum ni Rangi ikiwa na enumerators <code>nyeupe</code>, <code>nyekundu</code> na <code>nyeusi</code> hazina value ila value zake huwa kama hazipo interpreter huwa inazipa value by default kwa kuanzia siuri 0 na kuendelea kutokana na idadi ya enumerators.Kwenye mfano wetu kuna enumerator 3 hizo nyeupe itakuwa na 0,nyekundu na 1 na nyeusi na 2.</p> <pre><code>    cout &lt;&lt; Rangi::Nyeupe &lt;&lt; endl\n         &lt;&lt; Rangi::Nyekundu &lt;&lt; endl\n         &lt;&lt; Rangi::Nyeusi &lt;&lt; endl;\n</code></pre> <p>Kupata access ya enumerators zako ili ziwe printed utaanza na jina la enumerator yako kisha utatumia <code>scope resolution operator</code> kisha jina la enumerator yako ambayo imekuwa declared kwenye enum.</p> <p>Shida moja ya plain enum hatuwezi kuwa na enum nyingine ambayo ina enumerators(member) sawa na wale wa enum ya kwanza.Angalia mfano:</p> <pre><code>enum Rangi\n{\n    Nyeupe,\n    Nyekundu,\n    Nyeusi\n};\n\nenum Rangi2\n{\n    Nyeupe,\n    Nyekundu,\n    Nyeusi\n};\n/*\nc:\\Users\\Njox\\Desktop\\C++\\enums.cpp:14:5: error: 'Nyeupe' conflicts with a previous declaration\n   14 |     Nyeupe,\n      |     ^~~~~~\nc:\\Users\\Njox\\Desktop\\C++\\enums.cpp:7:5: note: previous declaration 'Rangi Nyeupe'\n    7 |     Nyeupe,\n      |     ^~~~~~\nc:\\Users\\Njox\\Desktop\\C++\\enums.cpp:15:5: error: 'Nyekundu' conflicts with a previous declaration\n   15 |     Nyekundu,\n      |     ^~~~~~~~\nc:\\Users\\Njox\\Desktop\\C++\\enums.cpp:8:5: note: previous declaration 'Rangi Nyekundu'\n    8 |     Nyekundu,\n      |     ^~~~~~~~\nc:\\Users\\Njox\\Desktop\\C++\\enums.cpp:16:5: error: 'Nyeusi' conflicts with a previous declaration\n   16 |     Nyeusi\n      |     ^~~~~~\nc:\\Users\\Njox\\Desktop\\C++\\enums.cpp:9:5: note: previous declaration 'Rangi Nyeusi'\n    9 |     Nyeusi\n      |     ^~~~~~\n\n*/\n</code></pre> <p>Error inasema kwamba kuna conflict,kwamba kutokana na declaration ya enumerators zetu kuna nyingine zinaingiliana,basi katika situation kama hii hapa <code>class enums</code> zinatumika katika C++.</p> <p>Kiujumla ni muhimu kutumia enum classes kwa sababu hazijibadili mara kwa mara,ila error zake mara chache.</p>"},{"location":"intermediate/enumerations/enumerations/#strongly-typed-enums","title":"Strongly Typed Enums","text":"<ul> <li>Strongly typed enums ni sawa na Class enums. Hivyo hakikisha unapitia sehemu ya class enums.</li> </ul>"},{"location":"intermediate/enumerations/enumerations/#enum-class","title":"Enum Class","text":"<ul> <li>enum class zipo katika wigo(scoped) na pia ziko strongly typed,na zinaanza na enum ikifuatiwa na neno class ikimaanisha kwamba enum ni strongly typed baada ya hapo jina la enum yako(inabidi liwe katika PascalCase),kama mfano hapo chini:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum class Rangi\n{\n    Nyeupe,\n    Nyeusi,\n    Kijani\n};\n\nint main()\n{\n    cout &lt;&lt; static_cast&lt;int&gt; (Rangi::Nyeupe);\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/enumerations/enumerations/#enumeration-underlying-type","title":"Enumeration Underlying Type","text":""},{"location":"intermediate/enumerations/enumerations/#enum-operations","title":"Enum Operations","text":""},{"location":"intermediate/enumerations/enumerations/#switch-statements-with-enums","title":"Switch Statements with Enums","text":"<p>Switch statement zinafanya kazi vizuri zikiwa na enums, inafanya msimbo wakonkuonekana vizuri kuliko kuwa na multiple if-else statements.</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum Day\n{\n    Jumatatu,\n    Jumanne,\n    Jumatano,\n    Alhamisi,\n    Ijumaa,\n    Jumamosi,\n    Jumapili\n};\n\nint main()\n{\n\n    Day currentDay = Jumatatu;\n\n    switch (currentDay)\n    {\n    case Jumatatu:\n        cout &lt;&lt; \"Soma enumerations\" &lt;&lt; endl;\n        break;\n    case Jumanne:\n        cout &lt;&lt; \"Pumzika\";\n        break;\n    case Alhamisi:\n        cout &lt;&lt; \"Nenda kusali\";\n        break;\n    }\n}\n</code></pre>"},{"location":"intermediate/enumerations/enumerations/#enum-as-flags","title":"Enum as Flags","text":"<p>Enum zinaweza kutmika kama bit flags, ambapo kila enumerator inawakilisha bit moja.</p>"},{"location":"intermediate/enumerations/enumerations/#best-practices","title":"Best Practices","text":"<ul> <li>Majina ya enum zako yawe katika PascalCase,Mfano:</li> </ul> <pre><code>enum class Rangi\n{\n    Nyeupe,\n    Nyeusi,\n    Kijani\n};\n</code></pre> <ul> <li> <p>Ni muhimu kutumia class enums badala ya plain enums katika program zako.</p> </li> <li> <p>Kama umefanya declaration ya enum yako na kisha kuipa value enum yako ila unataka values nyingine ziwe zinapungua kwenda chini kwamba in the same way na compiler inafanya mfano,tuna enum inaitwa <code>SikuKatikaWiki</code> zikiwa na enumerators za siku ila unataka jumatatu kama enumerator ianze na 1 na zinazo fuata ziwe na 2 na kuongeneza 1 kwa kila enumerator,Mfano</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum class SikuKatikaWiki\n{\n    Jumatatau = 1,\n    Jumanne = 2,\n    Jumatano = 3,\n    Alhamisi = 4,\n    Ijumaa = 5,\n    Jumamosi = 6,\n    Jumapili = 7\n};\n\nint main()\n{\n    return 0;\n}\n</code></pre> <p>Badala ya kufanya hivyo unaweza fanya hivi kufanya code yako iwe clean na kuonekana vizuri.Amgalia mfano hapo chini!</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum class SikuKatikaWiki\n{\n    Jumatatau = 1,\n    Jumanne,\n    Jumatano,\n    Alhamisi,\n    Ijumaa,\n    Jumamosi,\n    Jumapili\n};\n\nint main()\n{\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/enumerations/enumerations/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li> <p>Declaring enums kwa kutumia old way(plain enums) badala ya class enums ili kuweza kuimprove type safety.</p> </li> <li> <p>Explicitly Set Enum Values: Ni vizuri kutumia explicit set enum values ili kuweza kubadili.</p> </li> <li> <p>Avoid Implicit Conversions: Be cautious with implicit conversions between enums and integers. Use static_cast for clarity.</p> </li> <li> <p>Error Handling: Hakikisha una default statement kama umetumia switch statement katika program yako ili uweze kuhandle unexpected situations.</p> </li> </ul> <p>\u2b06\ufe0f Return to Top</p>"},{"location":"intermediate/errors/errors/","title":"Errors","text":"<ul> <li>Introduction</li> <li>Common Errors and Solutions</li> <li>Syntax Error</li> <li>Logical Errors</li> <li>Run Time Errors</li> <li>Semantic Errors</li> <li>Linker Errors</li> <li>Handling Errors</li> <li>Best Practices</li> </ul>"},{"location":"intermediate/errors/errors/#introduction","title":"Introduction","text":"<p>These are just a few common errors that you might encounter while working on this project. If you encounter an error that is not listed here, consider searching online for more information or asking for help from your colleagues or online communities.</p>"},{"location":"intermediate/errors/errors/#syntax-error","title":"Syntax Error","text":"<ul> <li>Syntax error katika programming ni sawa na grammar error katika lugha za kawaida.Zinatokea endapo utakuwa umefanya violation ya Sintaksia za lugha ya C++.Mfano</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int x = 10 // Kukosekana kwa semi colon mwisho wa line\n    if (x &gt; 5) // Missing opening brace for the if statement\n        cout &lt;&lt; \"x is greater than 5\";\n\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/errors/errors/#logical-errors","title":"Logical Errors","text":"<ul> <li>Error ambazo code inafanya compilation vizuri na kurun vizuri bila kufanya crashing, lakini haitoi matokeo(jibu) ambalo ulitegemea kutokana na logic ya program yako.Mfano:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{ // Logical error: Incorrect condition\n    if (x = 5)\n    {\n        cout &lt;&lt; \"x is 5\";\n    }\n\n    // Logical error: Incorrect loop termination condition\n    for (int i = 0; i &lt;= 10; i++)\n    {\n        // Do something\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/errors/errors/#run-time-errors","title":"Run Time Errors","text":""},{"location":"intermediate/errors/errors/#semantic-errors","title":"Semantic Errors","text":""},{"location":"intermediate/errors/errors/#linker-errors","title":"Linker Errors","text":""},{"location":"intermediate/errors/errors/#handling-errors","title":"Handling Errors","text":""},{"location":"intermediate/errors/errors/#best-practices","title":"Best Practices","text":""},{"location":"intermediate/memory_management/memory/","title":"Memory Management in C++","text":"<ul> <li>Introduction</li> <li>Memory Allocation</li> <li>Stack Memory</li> <li>Heap Memory</li> <li>Pointers and Memory</li> <li>Dynamic Memory Allocation</li> <li>new and delete Operators</li> <li>malloc and free Functions</li> <li>Memory Leaks</li> <li>Smart Pointers</li> <li>RAII (Resource Acquisition Is Initialization)</li> <li>Memory Allocation Strategies</li> <li>Memory Management in Containers and Data Structures</li> <li>Memory Safety</li> <li>Memory Debugging Tools</li> <li>Exception Safety</li> <li>Memory Management Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"intermediate/memory_management/memory/#introduction","title":"Introduction","text":"<p>Memory management in C++ involves allocating and deallocating memory for objects and data structures. C++ provides several mechanisms for memory management, including:</p> <ul> <li> <p>Memory management katika C++ inahusisha allocating na deallocating memory kwa ajili ya objects na data structures wakati wa runtime katika program yako.Katika C++ kuna njia mbalimbali za memory management.</p> </li> <li> <p>Kuna utofauti kati ya compile time na runtime katika programming,Compile time ni kipindi kile ambacho source code za program zinakuwa trasanslated kwenda katika machine code au bytecode na compiler. Ila runtime ni kipindi ambacho compiled code inakuwa executed na compiler.</p> </li> </ul> <p>Kwanini memory management ni muhimu katika C++ Kumbuka kwamba arrays zinahifadhi data za same type, kwa hiyo mud mwingi memory inakuwa alklocated kwa ajili ya array wakati wa declraration. Kuna muda mwingine pia inaweza ikatekea exact memory haijawa determined hadi pale muda wa runtime. Ili kuweza kuzuia situation kama hii, tunafanya declaration ya array ambayo inakuwa na maximum size lakini memory itakuwa unuse yaani haitatumika. Kuweza kuzuia wastage ya memory, tunatumia new operator ili kufanya allocation ya memory dynamiccally wakati wa runtime.</p>"},{"location":"intermediate/memory_management/memory/#memory-allocation","title":"Memory Allocation","text":"<ul> <li> <p>Memory Allocation ni moja kati ya concept muhimu sana kwenye upande wa memory management. Kuna aina tatu za memory allocationb katika C++,</p> </li> <li> <p>Static Memory Allocation. Memory kwa ajili ya variables,inkuwa allocated wakati wa kuwa compiled na inakuwa deallocated pale program inatoka kwenye scope ambayo imekuwa declared.</p> </li> </ul> <pre><code>int main() {\n    int num = 10; // memory for num is allocated statically\n    // ...\n    return 0;\n} // memory for num is deallocated upon exiting main()\n</code></pre> <p>2.Automatic Memory Allocation. Memory kwa jili ya local variable inakuwa llocated pale program inakuwa ndani ya scope ambayo imekuwa declared na inakuwa deallocated pale ambapo program ina exit ile scope yake.Na hii mara nyingi ndio inaitwa stack memory.</p> <pre><code>void foo() {\n    int num = 10; // memory for num is allocated automatically\n    // ...\n} // memory for num is deallocated upon exiting foo()\n</code></pre> <p>3.Dynamic Memory Allocation. Memory allocation na deallocation inakuwa inafanywa na programmer mwenyewe kwa kutumia <code>new</code> na <code>delete</code> operators. Memory allocation katika dynamic inakuwa allocated kutoka kwenye heap.</p>"},{"location":"intermediate/memory_management/memory/#stack-memory","title":"Stack Memory","text":"<ul> <li>Stack ni eneo katika memory ambalo  linatumika katika C++ na C, stack inatumika kwa ajili ya local variables, function parameters na temporary data storage. Memory inakuwa automatically allocated na kuwa deaallocated pale amabpo function inakuwa called,, na hata pia pale ambapo baada ya kufanya declaration ya local variable na kitu program yetu kutoka nje ya local variable hapo deallocation inafanywa na compiler yenyewe.Mfano:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    // declare local variable\n    int age = 20;\n\n    void greetUser(){\n        cout &lt;&lt; \"Hello Welcome!\" &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <p>Mfano kwenye program yetu hapo juu kuna local variable ambayo ni <code>age</code> na pia kuna function ambayo ni <code>greetUser()</code> local variable yetu age baada ya kuwa declared inahifadhiwa kwenye stack kwasababu ni local na pia allocation inafanyika kwenye stack baada ya hapo void ya <code>greetUser()</code> baada ya function kuwa declared memory allocation imekuwa allocated na baada ya function kuitwa kwenye progtram yetu au hata kama itakuwa na return value hapo chini deallocation ya program yetu itatokea.</p> <ul> <li>Sifa mojawapo ya stack memory allocation baaada ya kuwa executed inakuwa flashed nje ya memory kwenye stack automatically.Hivyo value yoyote inayohifadhiwa ndani ya stack inakuwa acessed kabla ya kuwa executed hauwezi kupata access ya code yako.</li> </ul>"},{"location":"intermediate/memory_management/memory/#sifa-za-stack","title":"Sifa Za Stack","text":"<ul> <li>Stack memory inakuwa managed na sytem. Stack ni eneo katika memory ambalo linakuwa managed na system,linakuwa na fixed size na size inakuwa determined za operating system au inakuwa automatically determined na compiler.</li> <li>Stack ni eneo ambalo local variables na function call information zinakuwa stored.</li> <li>Memory allocation na deallocation katika stack inafanyawa na compiler yenyew tofauti na heap memory, pia memory deallocation zinafanyika pale ambapo kutakuwa na function calls pamoja na returns.</li> <li>Access kwenye stack zipo faster ukifananisha na heap memory kwa sababu ni rahisi na pia zinapredicatble alloaction mechanism na pia kuna dealloaction mechanism.</li> <li>Size ya stack is ndogo ukifananisha na heap memory katika program yako. Mfano wa Stack Allocated variables ni pamoja na function parameters na local variables.</li> <li>Stack memory ina space ndogo ukifananisha na heap memory.</li> <li>Memory allocation na deallocation ni haraka ukifananisha na heap memory allocation.</li> </ul> <pre><code>int main()\n{\n  // All these variables get memory\n  // allocated on stack\n  int a;\n  int b[10];\n  int n = 20;\n  int c[n];\n}\n</code></pre>"},{"location":"intermediate/memory_management/memory/#heap-memory","title":"Heap Memory","text":"<ul> <li>Heap ni eneo katika memory ambalo linakuwa allocated kwa ajili ya dynamic memory allocation wakati wa execution ya program yako.Kinyume na stacl, ambayo inatumika kwa ajili ya automatic memory allocation, heap inakupa kibali kwa ajili ya dynacmic memory alloaction memory inakuwa allocated na kuwa deallocated wakati wa runtime pale inapotumika.</li> </ul> <pre><code>int main()\n{\n   // This memory for 10 integers\n   // is allocated on heap.\n   int *ptr  = new int[10];\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\n    int a = 10; // stored in stack\n    int* p = new int(); // allocate memory in heap\n    *p = 10;\n    delete (p);\n    p = new int[4]; // array in heap allocation\n    delete[] p;\n    p = NULL; // free heap\n    return 0;\n}\n</code></pre> <ul> <li> <p>Sifa za Heap memory</p> </li> <li> <p>Dynamic Memory Allocation: Memory allocation katika heap ni dynamic, ikinmaanisha kwamba memory inakuwa lloacted na kuwa deallocated pale inapohitajika wakati wa kufanya execution kwa kutumia new na delete operator.</p> </li> <li> <p>Size Flexibility: Heap inatoa kibali kwa jkili ya kufanya alloacation ya memory block ambayo size yake inakuwa determined wakati wa runtime.Flexibility ni muhimu pale ambapo pale unafanya kazi na data structure ya variable size au pale ambapo size ya data yako haujui wakati wa compilation.</p> </li> <li> <p>Lifetime Control: Memory inayokuwa lloacted katika heap inabaki hadi pale ambapo inakuwa deallocated na kwa kutumia delete operator au hadi pale program itakavyofanya termination ila kwa imekuwa created kwa kutumia new operator inabidi iwe deallocated kwa kutumia delete keyword katika program yako.</p> </li> <li> <p>Manual Memory Mnagement: Kinyume na styack memory, ambayo inakuwa managed na compiler, heap memory inahitaji amnual management na programmer. Ni kazi ya programmer kufanya kufanya alloaction pale ambapo inahitajika na na pia kufanya deallocation pale ambapo inahitajika,kinyime na hapo itapelekea kupata memory leaks.</p> </li> <li> <p>Memory alloaction na deallocation kwenye heap zinafanywa kwa kutumia <code>new</code> <code>delete</code>, <code>malloc</code> pamoja na <code>freeze</code>.</p> </li> </ul> <p></p>"},{"location":"intermediate/memory_management/memory/#pointers-and-memory","title":"Pointers and Memory","text":""},{"location":"intermediate/memory_management/memory/#dynamic-memory-allocation","title":"Dynamic Memory Allocation","text":"<ul> <li> <p>Dynamic Memory Allocation(DMA) katika C++ inakuwa managed na programmerv  mwenyewe katika compiler hizo ni muhimu kuzingatia safe procedures kwa jaili ya kufanya allocation na deallocation ya variables katika C++ kinyume na hapo utasababisha memory leak. Dynamic memory alloaction aktika C++ inampa programmer kuweza kufanya alloaction ya memory wakati wa runtime badala ya wakati wa compile time.</p> </li> <li> <p>Dynamic memory alloaction zinfanyika nadani ya <code>heap</code> data stricture katika C++, Pia hakikisha umepitia kipande cha pointers kuweza kujua pointers ni nini na zinafanyaje kazi, katika dynamic memory allocation tunatumia pointers ili kuweza kutebngeneza new variable tunatumia <code>new</code> kewyord kwa ajili ya kutengeneza variable yaani kufanya allocation na ili kuweza kufanya deallocation ya object yako ambayo imkuwa created katika programming utatumia <code>delete</code> keyword ili kufa nya memory deallocation katika C++.</p> </li> </ul>"},{"location":"intermediate/memory_management/memory/#new-and-delete-operators","title":"new and delete Operators","text":""},{"location":"intermediate/memory_management/memory/#malloc-and-free-functions","title":"malloc and free Functions","text":"<ul> <li> <p>Katika C++, <code>malloc()</code> na <code>free()</code> ni functions a,bazo zinatumika kwa ajili ya kuifanya dynamic memory alloaction na deallocation.Lakini, ni sehemu ya C standard library,!C++ standard libraray. Kwenye C++ kuan alternative kama new na delete operators kwa ajili ya memory management.Ila kwenye upnade wa C++ <code>delete</code> pamoja na <code>new</code> operator ndio zinakuwa prefered sana kwa ajili ya C++, ila pia unaweza ukatumia malloc pamoja na free.</p> </li> <li> <p>Malloc():</p> </li> <li> <p>Malloc inasimamam badala ya memory allocation, inatumika kwa ajili ya kufa nya alloacation ya memory juu ya heap..</p> </li> <li>Syntax ya malloc ipi hivi</li> </ul> <p><code>cpp  void* malloc(size_t size);</code></p> <p>Size ni number(idadi) ya bytes kwa ajili ya kufanya allocation.Function kwa ajili ya malloc inarudisha pointer mwanzoni allocated block kama utakuwa successful or <code>NULL</code> kama allocation haitawezekana.</p> <p>2.Free():</p> <ul> <li>Free() inatumika kwa ajili ya kufanya deallocation ya memory ambayo nyuma imekuwa allocated dynamically kwa kutumia <code>malloc()</code> au <code>calloc()</code> au <code>realloc()</code>.</li> <li>Syntax yake iko hivi.</li> </ul> <p><code>cpp  void free(void* ptr);</code></p> <p>ptr ni pointer kwenye memory block ambayo inatakiwa kuwa deallocated.Baada ya kuita <code>free()</code> memory inakuwa available for ajili ya subsequent alocations.</p> <p>Mfano namna matumizi ya malloc pamoja na free katika C++</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // Include the necessary header for malloc and free\n\nint main() {\n    // Allocate memory for an array of 5 integers\n    int* array = (int*)malloc(5 * sizeof(int));\n    if (array == nullptr) {\n        std::cerr &lt;&lt; \"Memory allocation failed.\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    // Initialize the array\n    for (int i = 0; i &lt; 5; ++i) {\n        array[i] = i * 10;\n    }\n\n    // Print the array\n    for (int i = 0; i &lt; 5; ++i) {\n        std::cout &lt;&lt; array[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n</code></pre> <p>Katika mfano hapo juu, malloc() imetumika kwa ajili ya kufanya alloaction ya memory ya array yenye integers 5. Memory kisha inakuwa initailized, printed na mwishowe kuwa deaallocated kwa kutumia <code>free()</code>.</p> <p>Ni muhimu kumbuka kwamba, kutumia <code>new</code> na <code>delete</code> ndio inakuwa prefered kuzidi <code>malloc()</code> na <code>free()</code>, especially pale unavyofanya kazi kwa jili ya classes na objects.</p>"},{"location":"intermediate/memory_management/memory/#utofauti-kati-ya-stack-na-heap-allocations","title":"Utofauti kati Ya Stack na Heap Allocations","text":"<ol> <li> <p>Katika Stack,allocation na de-allocation inakuwa inafanywa na compiler yenyewe lakini kwenye heap memory allocation na deallocation inafanywa na programmer mwenyewe.</p> </li> <li> <p>Handling heap frame ni cost ukifananisha na stack frame.</p> </li> <li> <p>Stack ipo faster sana ukifanananisha na heap.</p> </li> </ol>"},{"location":"intermediate/memory_management/memory/#memory-leaks","title":"Memory Leaks","text":"<ul> <li> <p>Memory Leaks inatokea katika C++ pale ambapo memory ambayo ni dynamically allocated wakati wa program execution inakkuwa not properly deallocated pale ambapo haihitajiki. Hii inaweza ikapelekea  depletion ya memory, program kuweza kuchukua resources na hata kupelekea program kucrush,Hizi ni baadhi ya vitu ambavyo vinasababisha memory leak katika C++ and mbinu za kuzuia.</p> </li> <li> <p>Kusahau kufanya deallocation ya memory yako: Pale ambapo unafanya dynamic deallocation ya memory kwa kutumia <code>new</code> operator au <code>malloc</code>, inabidi ukumbuke pia kufanya deallocation ya memory yako ambapo itakuwa haitumiki katika program yako.Mfano:</p> </li> </ul> <pre><code>int *ptr = new int;\n// Code that uses ptr\ndelete ptr; // Memory deallocation\n</code></pre> <p>2.Lost Pointers: Kama utasahau</p>"},{"location":"intermediate/memory_management/memory/#smart-pointers","title":"Smart Pointers","text":""},{"location":"intermediate/memory_management/memory/#raii-resource-acquisition-is-initialization","title":"RAII (Resource Acquisition Is Initialization)","text":""},{"location":"intermediate/memory_management/memory/#memory-allocation-strategies","title":"Memory Allocation Strategies","text":""},{"location":"intermediate/memory_management/memory/#memory-management-in-containers-and-data-structures","title":"Memory Management in Containers and Data Structures","text":""},{"location":"intermediate/memory_management/memory/#memory-safety","title":"Memory Safety","text":""},{"location":"intermediate/memory_management/memory/#memory-debugging-tools","title":"Memory Debugging Tools","text":""},{"location":"intermediate/memory_management/memory/#exception-safety","title":"Exception Safety","text":""},{"location":"intermediate/memory_management/memory/#memory-management-best-practices","title":"Memory Management Best Practices","text":""},{"location":"intermediate/memory_management/memory/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"intermediate/object-oriented-programming/oop/","title":"Object-Oriented Programming in C++","text":"<ul> <li>Introduction to OOP</li> <li>Classes and Objects</li> <li>Acess Modifiers</li> <li>Encapsulation</li> <li>Inheritance</li> <li>Polymorphism</li> <li>Abstraction</li> <li>Constructors and Destructors</li> <li>Access Control</li> <li>Operator Overloading</li> <li>Templates</li> <li>Exceptions in OOP</li> <li>Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"intermediate/object-oriented-programming/oop/#introduction-to-oop","title":"Introduction to OOP","text":"<ul> <li>Ili uweze kuandika software mablimbali kuna namba mbalimbali za kuandika program zako kama mabvyo kuna namna mbalimbali za kupika ugali pia kuna namna mabalimbali za kuandika software,hivyo katika object oriented kila kitu kinatambulika kama ni object na pia kitendo cha kutengeneza program kwa kutumia objects ndio tunaita object oriented programming.</li> <li>Namna hizo za kuandika program katika <code>C++</code> zipo nyingi ila mfano ni</li> <li>Functional programming</li> <li>Object Oriented Programming</li> <li>Event driven programming</li> <li>Procedural Programming</li> </ul> <p>Ila njia mbili kubwa zinazotumika kwa sana ni <code>functional</code> na <code>object oriented</code></p> <ul> <li>Ngoja tuangalia utofauti kati ya <code>functional</code> na <code>object oriented</code></li> </ul> Feature Functional Programming (FP) Object-Oriented Programming (OOP) Paradigm Type Declarative paradigm, focuses on \"what to achieve\" Imperative paradigm, focuses on \"how to achieve\" State Management Emphasizes immutability; avoids changing state Manages state through mutable objects and methods Data Mutation Discourages mutable data; encourages pure functions Allows mutable data and state changes through methods Functions First-class functions, higher-order functions Functions encapsulated within objects, methods Encapsulation Data is immutable and hidden; no shared state Encapsulation through objects and access modifiers Inheritance Avoids classical inheritance; favors composition Utilizes class-based inheritance hierarchy Polymorphism Achieved through higher-order functions and parametric polymorphism Achieved through method overriding and interfaces Side Effects Minimizes side effects for deterministic behavior Embraces side effects, can lead to non-deterministic behavior Parallelism/Concurrency Easier to achieve due to immutability and lack of shared state May face challenges due to shared mutable state Typing System Strong typing, often supports type inference Strong typing, supports static and dynamic typing Flexibility and Extensibility Easier to extend and compose functions Extensibility through class inheritance and polymorphism Error Handling Relies on immutability and monads for error handling Uses exceptions and error handling within objects Common Languages Haskell, Scala, Clojure, Lisp, Erlang Java, C++, Python, C#, Ruby, JavaScript Popular Frameworks/Libraries React, Redux (JavaScript); Apache Spark (Scala); RxJava (Java) Spring (Java), Django (Python), .NET Framework (C#), React (JavaScript) <p>Object ni kitu chochote katika ssoftware ambacho kina properties(attributes) na pia methods au functions,Mfano mzuri ni gari,gari lina properties kama color na pia kuna methods ambazo zipo kwenye gari kama brake().Kwenye upande wa programming object sio kitu cha uhalisia ila ni vitu ambavyo vinatumika kutengeneza user interface ya program, mfano kama unaangalia video kwenye VLC basi vlc ina propeties kama playback speed na pia ina method au function kama play(), pause(), stop().</p> <ul> <li>Ili tuweze kutengeneza object katika C++ tunahitaji kuwa na class na class ni ndio blueprint ya kuweza kutengeneza object yetu.</li> <li> <p>Properties au attributes ina majina mengi mojawapo ya hayo majina ni <code>attributes</code>, <code>member variables</code>, <code>fields</code>, <code>properties</code>, kwa hiyo hayo ni moja ya majina yanayotumika katika C++ kwa ajili ya attributes.</p> </li> <li> <p>Ngoja tuangalia utofauti kati ya classes na structs katika C++</p> </li> </ul> Feature Classes Structs Access Modifiers Can have private, protected, and public members Can have private, protected, and public members Inheritance Supports public, private, and protected inheritance Supports public, private, and protected inheritance Member Functions Can have member functions with or without access specifiers Can have member functions with or without access specifiers Member Initializers Can use member initializers in constructors Can use member initializers in constructors Default Access Members default to private if not specified Members default to public if not specified Use Case Typically used for modeling complex objects, encapsulation, and abstraction Typically used for lightweight data structures or small objects with no encapsulation needed Memory Alignment Can have alignment specifiers for better control over memory layout Limited control over memory alignment Object Initialization Constructor is used for object initialization Constructor is used for object initialization Pointer to Members Supports pointers to members Supports pointers to members In-Class Initialization Supports in-class member initialization Supports in-class member initialization Complexity Generally used for more complex scenarios and larger projects Often used for simpler data structures and small, self-contained objects Default Accessibility Members default to private if not specified Members default to public if not specified Compatibility with C Closer to C++ philosophy with additional features Maintains compatibility with C structures"},{"location":"intermediate/object-oriented-programming/oop/#classes-and-objects","title":"Classes and Objects","text":"<ul> <li>Ili uweze kutengeneza class yako katika program yako, kama unatumia <code>Clion editor</code> ni rahisi nenda kwenye editor yako kisha nenda sehemu ya project right click then chagua <code>new</code> kisha chagua <code>C/C++ Class</code></li> </ul> <p> then click ok, baada ya hapo utakutana na file limekuwa created kama hili.</p> <p></p> <p>Baada ya hapo utakuta file mbili zimekuwa created kwenye program yetu ambapo file la kwanza linaitwa <code>Rectangle.h</code> ambalo ndio header file na file la pili ni <code>Rectangle.cpp</code>, header file linakuwa na features za rectangle class na pia la <code>Rectangle.cpp</code> ni file ambalo litakuwa na actual implementation la <code>Rectangle.cpp</code> file.</p> <ul> <li> <p>Hapa kwenye header file na actual file ni kama kwenye upande wa Remote controller,remote controller inakuwa na uwezo wa kufanya operesheni mbalimbali ila ili uweze kufanya operesheni hizo kama kuongeza sauti au kuplay video na vitu vingine hauhitaji kujua ndani ya hiyo remote inafanyaje kazi basi hapo ni sawa katika program yetu,kwamba class yetu itakuwa na header file na file la actual implementation ili kupunguza complexity ndani ya class file <code>Rectangle.cpp</code>.</p> </li> <li> <p>Hivyo ndani ya <code>Rectangle.h</code>, tunahitaji kudefine properties na methods za hiyo class yako katika program yetu.Rectangle itakuwa na features kama <code>height</code> na <code>width</code> , yaani upana na urefu na pia itakuw na methods kama <code>draw()</code> na <code>getArea()</code></p> </li> </ul> <pre><code>#ifndef SRC_RECTANGLE_H\n#define SRC_RECTANGLE_H\n\n\nclass Rectangle {\n    // properties\n    int width;\n    int height;\n\n    // methods\n    void draw();\n    int getArea();\n};\n\n\n#endif //SRC_RECTANGLE_H\n</code></pre> <p></p> <ul> <li> <p>Actual implementation ya code yetu itakuwa ndani ya file na <code>Rectangle.cpp</code>, katika <code>Rectangle.cpp</code> ndio tunaweza kufanya implementation ya rectangle class.Kufanya implementation ya draw class tutaanza Rectangle class ikifuatiwa <code>scope resolution operator</code> <code>: :</code> ikifuatiwa na jina la function au property yako.</p> </li> <li> <p>Ni muhimu kujua kwamba kuna utofauti wa header files kama zimetoka kwenye standard library zitakuwa ni na <code>&lt; &gt;</code> kama iostream ila kama ya kwetu hiyo itakuwa ndani ya quotes <code>\" \"</code>.</p> </li> </ul> <pre><code>#include \"Rectangle.h\"\n#include &lt;iostream&gt;\n\nusing namespace  std;\n\nvoid Rectangle::draw() {\n    cout &lt;&lt; \"Nachora rectangle\" &lt;&lt; endl;\n}\n\nint Rectangle::getArea() {\n    return width * height;\n}  cout &lt;&lt; \"Nachora rectangle\" &lt;&lt; endl;\n</code></pre> <ul> <li>Ili tuweze kutengeneza rectangle object katika file letu kwanza inabidi header file liwe katika <code>main.cpp</code> <code>#include \"Rectangle.h\"</code>, na pia file linalotakiwa kuwa included ni header file na sio <code>Rectangle.cpp</code> file.Hivyo ndani ya main.cpp file ndiyo tutatumia class ya Rectangle kutengeneza object kama <code>Rectangle rectangle</code> na ili kuweza kupata methods za instance amabyo ni object rectangle tutatumia dot operator <code>rectangle.</code>.</li> </ul> <pre><code>// main.cpp file\n#include \"Rectangle.h\"\n\nint main(){\n    Rectangle rectangle;\n    rectangle.draw();\n\n    return 0;\n}\n</code></pre> <p>Kwenye upande wa structures ukifanya declaration ya members wako huwa wanakuwa public by default ila kwa upande wa class hapana, kwa hiyo kama kwenye rectangle class yako utafanya initialization ya value ya object kama width by default utapata error kwanini? <code>class members huw wanakuwa private by default kwa hiyo inabidi ubadilishe kuwa public kama unataka iwe public</code></p> <pre><code>// main.cpp file\n#include \"Rectangle.h\"\n\nint main(){\n    Rectangle rectangle;\n    rectangle.draw();\n\n    rectangle.width = 10;\n    // error because the member variable rectangle.widh is private\n    return 0;\n}\n</code></pre> <p>Inabidi ubadili kuwa public kwahiyo ndani ya header file ndio unabadili ndani ya class declaration.</p> <pre><code>#ifndef SRC_RECTANGLE_H\n#define SRC_RECTANGLE_H\n\n\nclass Rectangle {\npublic:\n    // properties\n    int width;\n    int height;\n\n    // methods\n    void draw();\n    int getArea();\n};\n\n\n#endif //SRC_RECTANGLE_H\n</code></pre> <ul> <li>Baada ya member variables kufanywa public basi unaweza ukabadili value zake katika program yako.</li> </ul> <pre><code>// main.cpp file\n#include \"Rectangle.h\"\n\nint main()\n{\n    Rectangle rectangle;\n    rectangle.draw();\n\n    rectangle.width = 10;\n    rectangle.height = 20;\n\n    rectangle.getArea();\n\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/object-oriented-programming/oop/#acess-modifiers","title":"Acess Modifiers","text":"<ul> <li> <p>Katika C++, \"access modifiers\" ni maneno muhimu yanayosaidia kudhibiti jinsi class members (vitu kama vile sifa(attributes) na njia)(methods) wanavyoweza kufikiwa kutoka nje ya class. Kuna \"public\", \"private\", na \"protected\". Hizi zinasaidia kutekeleza dhana ya \"encapsulation,\" moja ya misingi ya programu katika OOP. Hapa kuna maelezo fupi:</p> </li> <li> <p>Public     Wanachama wa \"public\" wa darasa hufanya kuwa interface yake kwa ulimwengu wa nje.     -Members (Wanachama) ambao ni public wanaweza kufikiwa hata wakiwa nje ya class, na mda wowote</p> </li> </ul> <pre><code>    class Example {\n\npublic:\n    int publicVar;\n    void publicMethod() {\n        // code here\n    }\n};\n</code></pre> <p>2.Private Members ambao wamekwa kama private hawawezi kufikiwa kutoka nje ya class. Members ambao ni private huficha sifa na maelezo ya utekelezaji. Members ambao ni private wanaweza kuwa accessed ndai ya hiyo class tu.</p> <pre><code>    class Example {\nprivate:\n    int privateVar;\n    void privateMethod() {\n        // code here\n    }\n};\n</code></pre> <ol> <li>Protected: Wanachama waliotangazwa kama \"protected\" ni kama \"private,\" lakini wanaweza kufikiwa katika class  zilizojengwa juu yake. Members wa \"protected\" huruhusu class iliyojengwa yaliyojengwa kurithi(inherit) na kufikia wanachama(class members) hao. Members wa \"protected\" hutumika unapotaka kuzuia upatikanaji kutoka nje ya (class)darasa, lakini kuruhusu upatikanaji kwa madarasa yaliyojengwa juu yake</li> </ol> <pre><code>    class Base {\nprotected:\n    int protectedVar;\n    void protectedMethod() {\n        // code here\n    }\n};\n\nclass Derived : public Base {\n    // Can access protectedVar and protectedMethod here\n};\n</code></pre>"},{"location":"intermediate/object-oriented-programming/oop/#encapsulation","title":"Encapsulation","text":""},{"location":"intermediate/object-oriented-programming/oop/#inheritance","title":"Inheritance","text":"<ul> <li> <p>Kama ambavyo binadamu tuna uwezo wa kurithi sura kwamba mtu anaweza akawa anafanana ya baba yake aua mama yake sasa kwenye upnade wa programming katika C+ kuna inheritance pia kwamba kwenye program yaetu kuna baadhi ya vitu vinarithi properties na methods ambazo zipo kwenye vitu vingine,Kwa mfano tunaweza tukawa na C++ class amabyo inaitwa <code>Umbo</code> na hilo umbo linaweza likaw na properties pamoja na methods mabalimbali sasa kutoka kwenye umbo tunaweza tengeneza umbo la <code>mduaala</code> ambalo linarithi baadhi ta tabia na methods amabzo zipo kwenye class ya umbo,pia tunaweza tengeneza umbo la triangle ambalo linarithi tabia kutoka kwa umbo class.</p> </li> <li> <p>Kwa upande wmingine tunaweza tukawa na class ambayo inaitwa <code>gari</code> na class hiyo ya gari inaweza ikazaa gari kama <code>BMW</code> <code>IST</code> hilo gari ambazo umeona hapo zinaweza zikawa na uwezo wa au properties na methods amabazo zimetoa kwenye class ya gari na hio ndio maana na inheritance,inheritance inarahisisha mambo kwamba baadala ya kuandika program yetu upya kuhusu object fulani basi tunaamua kuchukua properties au methods ya class fulani na kuweka kwenye class nyingine ambayo imetoka kwenye parent class.</p> </li> </ul>"},{"location":"intermediate/object-oriented-programming/oop/#polymorphism","title":"Polymorphism","text":""},{"location":"intermediate/object-oriented-programming/oop/#abstraction","title":"Abstraction","text":"<ul> <li>Abstraction ni sawa na kusema data hding kwamba unapunguza complexity kwenye program yako.Kwa mfano kwenye remote controller ya TV yako hauhitaji kujua dani kuna nini ya hivyo vitu vyakop vinafanyaje kazi,sasa hapa ni sawa na abstraction kwamba unaficha vile vitu ambavyo sio vya msingi kwenye program yako na kuonesha vitu vyile tu ambavyo ni vya msingi kwenye program yako.Ni kama pia vile kwenye upande wa gari hauhitaji kujua gear ya gari inakoje na pia infanyaje kazi ila wao wameamua kunyesha vile vitu ambavyo ni vya muhimu tu kama uskani,sehemu na vitu vingine na hio ndio maana ya sbtraction.</li> </ul>"},{"location":"intermediate/object-oriented-programming/oop/#constructors-and-destructors","title":"Constructors and Destructors","text":""},{"location":"intermediate/object-oriented-programming/oop/#access-control","title":"Access Control","text":""},{"location":"intermediate/object-oriented-programming/oop/#operator-overloading","title":"Operator Overloading","text":""},{"location":"intermediate/object-oriented-programming/oop/#templates","title":"Templates","text":""},{"location":"intermediate/object-oriented-programming/oop/#exceptions-in-oop","title":"Exceptions in OOP","text":""},{"location":"intermediate/object-oriented-programming/oop/#best-practices","title":"Best Practices","text":"<ul> <li>Ndio nzuri ni kuweka public methods kwanza zikifuatiwa na private methods</li> </ul> <pre><code>/*\nIn this header file we are going to declare the features of the rectangle class\n*/\n\n#ifndef SRC_RECTANGLE_H\n#define SRC_RECTANGLE_H\n\nclass Rectangle\n{\npublic:\n    int width;\n    int height;\n    void draw();\n    int getArea();\n\nprivate:\n    // private methods and variables\n};\n\n#endif // SRC_RECTANGLE_H\n</code></pre> <ul> <li> <p>Pendelea kuandka program yako kwa njia ya object oriented ili kuweza kufanya program yako iwe rahisi na kueleweka.</p> </li> <li> <p>Whenever we have string parameter it's best practice to declare it as reference parameter when setting value using setter.</p> </li> </ul>"},{"location":"intermediate/object-oriented-programming/oop/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"intermediate/streams/streams/","title":"Streams Intro","text":""},{"location":"intermediate/streams/streams/#streams","title":"Streams","text":"<ul> <li>Streams</li> <li>Streams</li> <li>Introduction to Streams</li> <li>Input and Output Streams</li> <li>Standard Streams</li> <li>Reading from Streams</li> <li>Handling Input Errors</li> <li>Writing to Streams</li> <li>File Streams</li> <li>String Streams</li> <li>Stream Manipulators</li> <li>Chaining Streams</li> <li>Error Handling with Streams</li> <li>Custom Streams</li> <li>Streams and User-defined Types</li> <li>Best Practices</li> </ul>"},{"location":"intermediate/streams/streams/#streams_1","title":"Streams","text":"<ul> <li>Katika C++ kuna namna ya kudeal na standard input na kudeal standard output,kuna functionality ambazo zipo upnad wa standard output(so) kama <code>cout</code> mfano wa standard input ni <code>cin</code>.Kwahiyo kwenye stream assume kwamba kuna bomba mbili ambapo bomba ya kwanza inahusika na kutuma meseji na bomba ya pili inahusika na kupokea message katika C++ na hizo pipe mbili kwenye C++ tunaita streams.</li> <li>Hivyo pale ambapo unataka kuiambia computer kitu fulani au akuuliza swali, unatumia pipe ya kusend ambayo ndio (output stream kupeleka meseji).Na pale ambapo computer inataka kusema kitu fulani au kujibu swali back kwangu.</li> </ul>"},{"location":"intermediate/streams/streams/#introduction-to-streams","title":"Introduction to Streams","text":""},{"location":"intermediate/streams/streams/#input-and-output-streams","title":"Input and Output Streams","text":""},{"location":"intermediate/streams/streams/#standard-streams","title":"Standard Streams","text":""},{"location":"intermediate/streams/streams/#reading-from-streams","title":"Reading from Streams","text":"<ul> <li>Tunataka kutengeneza a simple program ambayo inamruhusu user aweze kuingiza namba mbili then baada ya hapo majibu yawe displayed kwenye output.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    // strems in C++\n    cout &lt;&lt; \"First: \";\n    int first;\n    cin &gt;&gt; first;\n\n    cout &lt;&lt; \"Second: \";\n    int second;\n    cin &gt;&gt; second;\n\n    cout &lt;&lt; \"First number is \" &lt;&lt; first &lt;&lt; \" Second number is \" &lt;&lt; second;\n\n    return 0;\n}\n</code></pre> <ul> <li>Kwenye program yetu kuna kitu kinitwa buffer na ndio kinachohusika na kuhifadhi value ambazo mtumiaji wetu kaingiza hivyo value ambayo user ataingiza iatahifadhiwa kwenye buffer na buffer huwa inajaa,sasa kwa mfano user akaingiza namba ya kwanza bila kupress enter sasa kinchofanyika namba ya kwanza aliyoingiza inawekwa kwenye buffer na buffer ikiona white space au newline imekuwa created namba inayofuata inahifadhiwa kwenye buffer pia na hiyo napelekea kujaa kwa buffer hivyo namba ya pili user hattaweza kuingiza hivyo inabidi kutumia <code>cin.ignore()</code> kwa ajiili ya kufanya clear ya buffer.</li> </ul> <p>mwanzoni user wetu anaingiza number yake kwenye program hiyo namba huwa inahifadhiwa katika temporary storgae amabyo inaitwa buffer, buffer Je ni nini hichi kimetokea? Katika pale ambapo user ataingiza namba ya kwanza ambayo itaenda kwenye variable ya <code>first</code> namba hiyo inaenda kuhifadhiwa katika sehemu inaitwa <code>buffer</code>, buffer ni temporaray storage</p> <p>buffer-is the temporary storage area where the program can hold some information before using it or sending it somewhere else.</p> <ul> <li>Hivo kwa mara ya kwanza user wetu anaingiza value ya kwanza yaani namba ya kwanza kama itatokea usera ameingiza namba ya kwanza labda <code>10</code> akaingiza namba nyingine bila kaupiga enter kwamba kuingiza namba nyingine kwenye program yetu basi tutapata error kidogo ila haitakuwa displayed, kwenye screen kwanini? Kwasababu kwa mara ya kwanza user anaingiza value kwenye programu yetu kinachotokea ni kama namba ya kwanza inahifadhiwa katika temporary storage ambayo ndio buffer <code>[10 20]</code> baada ya user kuingiza value ya kwanza a,bayo ni 10 buffer inahifadhi data ambayo ni 10 ila cout ya secodn haitasomwa kwa sababu user wetu ameingiza value mbili kwenye programu yetu kwenye first kwa hiyo buffer ilichokifanya ni kuangalia je baada ya 10 kuna whitespace? ndio then baada ya hapo itakachofanya itachukua namba ya pili baada ya whitespace ambapo itapelekea namba ya pili kutosomwa compiler kuotoa ruhusa ya kufanya compiling kwa sababu imeshachukua value ile ya mara ya pili baada ya 10.</li> <li>Basi kwenye instance kama hii tunatumia <code>cin.ignore()</code>, cin.ignore inachukua parameter 2</li> <li>first parameter: Parameter ya kwanza ni type ya streamsize ambayo inawakilisha idadi ya characters ambazo zinatakiwa kuwa ignored, na idadi huwa inakuwa katika numbers mfano:hapo herefu 10 zitakuwa ignored.</li> </ul> <p><code>cpp    cin.ignore(10)</code></p> <ol> <li>Second parameter:Parameter ya pili inaitwa dlm ambayo ni delimeter,na delimter amabyo tunataka tuweze inaweza iakawa baada ya user kuplace enter.</li> </ol> <p><code>cpp    cin.ignore(10, '\\n');</code></p> <ul> <li>Kuna situation ambayo user anaweza akaingiza number kubwa sana hapo ndio inabidi kutumia umeric limits.</li> </ul> <p><code>cpp    numeric_limits&lt;streamsize&gt;::max();</code></p>"},{"location":"intermediate/streams/streams/#handling-input-errors","title":"Handling Input Errors","text":""},{"location":"intermediate/streams/streams/#writing-to-streams","title":"Writing to Streams","text":""},{"location":"intermediate/streams/streams/#file-streams","title":"File Streams","text":""},{"location":"intermediate/streams/streams/#string-streams","title":"String Streams","text":""},{"location":"intermediate/streams/streams/#stream-manipulators","title":"Stream Manipulators","text":""},{"location":"intermediate/streams/streams/#chaining-streams","title":"Chaining Streams","text":""},{"location":"intermediate/streams/streams/#error-handling-with-streams","title":"Error Handling with Streams","text":""},{"location":"intermediate/streams/streams/#custom-streams","title":"Custom Streams","text":""},{"location":"intermediate/streams/streams/#streams-and-user-defined-types","title":"Streams and User-defined Types","text":""},{"location":"intermediate/streams/streams/#best-practices","title":"Best Practices","text":""},{"location":"intermediate/streams/files/files/","title":"Streams","text":"<ul> <li>Introduction to Streams</li> <li>Input and Output Streams</li> <li>Standard Streams</li> <li>Writing to Streams</li> <li>Reading from Streams</li> <li>Writting to Binary Files</li> <li>File Streams</li> <li>String Streams</li> <li>Stream Manipulators</li> <li>Chaining Streams</li> <li>Error Handling with Streams</li> <li>Custom Streams</li> <li>Streams and User-defined Types</li> <li>Best Practices</li> </ul>"},{"location":"intermediate/streams/files/files/#introduction-to-streams","title":"Introduction to Streams","text":"<p>Stream class zinashare common base (same interface), kuna interface 3 katika C++ zinazohusika za files.       - <code>ifstream</code>: Ifstream inamaanisha input file stream, inahusika kuread data from a file.       - <code>ofstream</code> : Ouput file stream, output stream for files, inatumika kuweka kuandika data kwenye file(Writting data toa file).       - <code>Fstream</code> : fstream inajumlisha vote kwa pamoja, <code>ifstream</code> pamoja na <code>ofstream</code>, Hivyo kama utatuma file streams njia nzuri ni kuweka header files zake,na pia ni muhimu ukaweka <code>fstream</code> kwa sababu ina include zote kwa pamoja.</p>"},{"location":"intermediate/streams/files/files/#input-and-output-streams","title":"Input and Output Streams","text":""},{"location":"intermediate/streams/files/files/#standard-streams","title":"Standard Streams","text":""},{"location":"intermediate/streams/files/files/#writing-to-streams","title":"Writing to Streams","text":"<ul> <li>Ili uweze kufanya writting to a text file unatumia <code>fstream</code> kwa sababu inacombine vyote pia unaweza kutumia <code>ofstream</code> kama header,baada ya hapo ndani ya main function hakikisha unatumia filestream au unaweza ukatumia ofstream ili uweze kuandika kwa file,kumbuka kwamba ofstream ni class hivyo lazima ucreate instance ya class yako(instance of an object) <code>ofstream file</code>, file object lina method kwa ajli ya kufungua file <code>file.open</code> kisha ndani ya file.open(\"pass name of the file\"), <code>file.open(\"file.txt\")</code>,kama file aina ya <code>file.txt</code> halitakuepo basi litakuwa created zaidi ya hapo kama tayari lipo kwenye program yetu basi litakuwa overwritten katika program yetu,ili kuweza kuangali kama file liko opened au laa tumia conditional statement, pia ndani ya file object kuna properies ya <code>.is_open</code>  inatumika kuangali kama file limefunguliwa au hapana.</li> <li>Baada yta hapo ni tayari kuweka kuandika kwenye new file badala ya kutumia cout kuandika kwenye new file tuatumia fiole ili kuweka kuandika to a new file katika program yetu. <code>file &lt;&lt; \"Hello Njox\"</code> baada ya hapo close file lako ili kuweza kurealease space ambayo ilikuwa alloca. <code>file.close()</code></li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nint main()\n{\n    // create an instance of a class(object)\n    ofstream file;\n\n    // check to see if the file is opened or not\n    file.open(\"file.txt\");\n\n    if (file.is_open())\n    {\n        file &lt;&lt; \"C++ is awesome\" &lt;&lt; endl;\n        file.close();\n    }\n    else\n    {\n        cout &lt;&lt; \"Error when opening file\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>Kama unatumia VS Code ukiangali upande wa pannel utaona file lako limekuwa created au kwenye control panel utaona folder linaitwa output na ndani utaona file lako <code>file.txt</code>.</li> </ul> <p>Ila kama unatumia CLion nenda upande wa project then nenda kwenye folder linaitwa CMake-Build-Debug hapo ndipo utaona file lako limekuwa created.</p>"},{"location":"intermediate/streams/files/files/#reading-from-streams","title":"Reading from Streams","text":"<ul> <li>Procedures ni kama zinafanana</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main()\n{\n    ifstream file(\"data.txt\");\n\n    if (!file.is_open())\n    {\n        cerr &lt;&lt; \"Cannot open data.txt!\" &lt;&lt; endl;\n        return 1;\n    }\n\n    string line;\n    while (getline(file, line))\n    {\n        cout &lt;&lt; line &lt;&lt; endl;\n    }\n    file.close();\n\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/streams/files/files/#writting-to-binary-files","title":"Writting to Binary Files","text":""},{"location":"intermediate/streams/files/files/#file-streams","title":"File Streams","text":""},{"location":"intermediate/streams/files/files/#string-streams","title":"String Streams","text":""},{"location":"intermediate/streams/files/files/#stream-manipulators","title":"Stream Manipulators","text":""},{"location":"intermediate/streams/files/files/#chaining-streams","title":"Chaining Streams","text":""},{"location":"intermediate/streams/files/files/#error-handling-with-streams","title":"Error Handling with Streams","text":""},{"location":"intermediate/streams/files/files/#custom-streams","title":"Custom Streams","text":""},{"location":"intermediate/streams/files/files/#streams-and-user-defined-types","title":"Streams and User-defined Types","text":""},{"location":"intermediate/streams/files/files/#best-practices","title":"Best Practices","text":""},{"location":"intermediate/structures/structures/","title":"Structures","text":"<ul> <li>Structures</li> <li>Introduction to Structures</li> <li>Declaring Structures</li> <li>Arrays And Structs</li> <li>Accessing Structure Members</li> <li>Structured Binding</li> <li>Nested Structures</li> <li>Comparing Structures</li> <li>Working With Methods</li> <li>Operator Overloading</li> <li>Array of Structures</li> <li>Pointer to Structures</li> <li>Functions with Structures</li> <li>Passing Structures to Functions</li> <li>Dynamic Allocation of Structures</li> <li>Structures and Classes</li> <li>Best Practices</li> </ul>"},{"location":"intermediate/structures/structures/#introduction-to-structures","title":"Introduction to Structures","text":"<ul> <li>Structures katika programming zinatumika kutengeneza custom data types au tunaweza tukasema ADT(Abstract data type), abstraction kwa ajili ya student.Absstraction ni general model ya kitu!</li> </ul>"},{"location":"intermediate/structures/structures/#declaring-structures","title":"Declaring Structures","text":"<ul> <li>Struct ni muhimu sana kwa mfano tuna function yetu inaitwa <code>displayCustomerDetails</code> na pia hiyo function inachukua parameter funtion zipo parameter 4 ambazo zinadisplay customer details, ila ili kuweza kusave mda wako unaweza na pia kama Bob anavyosema kwamba <code>The best function is that with no parameters at all</code>, badala ya kuwa na function tunatumia ambayo tunapush details kama customerID, customerName, customerEmail na isRegistered tutakuwa na struct ambayo itatuwezesha kufanya yote hayo, badala ya kuwa na hiyo function tutatumai strcut na ndani ya strcut tutakuwa na hao member wanne(4).</li> <li>Anza with the struct keyword ikifuatiwa na jina la struct yako ila kumbuka struct yako inabidi iwe katika PascaLCase <code>PascalNamingConventions</code> baada ya hapo tumia braces and ndani ya braces zako define data ambazo zinahitajika. Syntax for structs</li> </ul> <pre><code>Syntax\nstruct Structure_Tag\n{\n Type_1 Member_Variable_Name_1;\n Type_2 Member_Variable_Name_2;\n};\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Customers\n{\n    int id;\n    string name;\n    string email;\n    bool isRegistered;\n};\n\nint main(){\n  return 0;\n}\n</code></pre> <ul> <li>Kumbuka structure yako inaweza ikawa kwenye global scope au local scope, nimeweka iwe katika global scope ili niweze kureuse struct yako ndani ya main function.</li> <li>Njia nyingine za kuweza kuzipa values struct zako ni kuweka default values kwa mfano hapo chini katika struct yetu <code>Customer</code> tumeweka default value kwenye customer id.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Customers\n{\n    int id = 13;\n    string name;\n    string email;\n    bool isRegistered;\n};\n\nint main(){\n  return 0;\n}\n</code></pre> <ul> <li>Baada ya kufanya defintion ya struct zako,interpreter haitafanya memory allocation ya members wako wa struct hadi pale ambapo struct itatengenezwa kama umbile(object) kwenye program yako kwa kutengeneza umbile(struct) ambalo litachukua properties ambazo zipo kwenye struct yako.Muda mwingine struct zako zinaweza zikawa na default value.</li> </ul> <pre><code>struct Mwanafunzi\n{\n    int miaka;\n    string jina;\n    string jinsia = \"Female\";\n};\n</code></pre> <p>Kwenye upande wa jinsia kuna default value ambayo ni \"Female\".</p>"},{"location":"intermediate/structures/structures/#accessing-structure-members","title":"Accessing Structure Members","text":"<ul> <li>Kuna namna nyingine ambayo unaweza kupass values zako katika array yako kwa kutumia kwenda kwenye umbile(object) katika njia nyepesi zaidi kwa kutumia curl braces</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Customers\n{\n    int id = 13;\n    string name;\n    string email;\n    bool isRegistered;\n};\n\nint main(){\n  // passing values into curl braces\n  Customers customer = {13, \"Njox\", \"mdudu@gmail.com\", true}\n  return 0;\n}\n</code></pre> <ul> <li>Kuna namna nyingine ya kutengeneza instance ya struct yako</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Customers\n{\n    int id = 13;\n    string name;\n    string email;\n    bool isRegistered;\n} customer;\n\nint main(){\n\n  customer.id = 13;\n  customer.name = \"Njox\";\n  return 0;\n}\n</code></pre> <ul> <li>Hakikisha pale unavyopass values by default ni muhimu kuzingatia values zipi zimekuwa assigned na values zipi hazijakuwa assigned.</li> <li>Accessing structure members kwenye program yetu tutaumia dot (.) operator ila kwan za inabidi kucreate a instance ya class yetu ambyo ni umbile(object).Anza na jina la struct yako iliyokuwa created ikifuatiwa na umbile(object) ambayo unatka iwe created.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// define struct\nstruct Customers\n{\n    int id;\n    string name;\n    string email;\n    bool isRegistered;\n};\n\nint main()\n{\n    // create an instance of umbile(object) from Customer\n    Customers customer;\n\n    // give values\n\n    // print customer details\n    cout &lt;&lt; \"ID: \" &lt;&lt; customer.id &lt;&lt; endl &lt;&lt; \"Name: \" &lt;&lt; customer.name &lt;&lt; endl  &lt;&lt; \"E-mail: \" &lt;&lt; customer.email &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <ul> <li>Ili kuapata access ya members wa hiyo structure tumia dot operator kutoka kwenye instance ya hiyo umbile(object)</li> </ul> <pre><code>customer.id = 221;\ncustomer.name = \"Godbless Nyagawa\";\ncustomer.email = \"godblessnyagawa@gmail.com\";\n</code></pre>"},{"location":"intermediate/structures/structures/#arrays-and-structs","title":"Arrays And Structs","text":"Feature Arrays Structs Definition Collection of elements of the same type, accessed by index. User-defined data type that can hold elements of different types, accessed by name. Data Type Homogeneous (all elements must be of the same type). Heterogeneous (elements can be of different types). Size Fixed size once declared. Size can vary, as it's determined by the sum of the sizes of its members. Memory Layout Contiguous memory allocation. Members are stored in separate memory locations. Access Access elements using index (e.g., <code>arr[0]</code>). Access members using their names (e.g., <code>structVar.member</code>). Initialization Can be initialized using an initializer list. Members can be initialized individually or using an initializer list. Usage Useful for storing and processing a collection of homogeneous elements. Suitable for grouping related data with different data types. Example <code>int numbers[5] = {1, 2, 3, 4, 5};</code> <code>struct Point { int x; int y; };</code> <code>Point p = {10, 20};</code>"},{"location":"intermediate/structures/structures/#structured-binding","title":"Structured Binding","text":"<ul> <li>Ili kuweza kupata values ya kila member wa umbile(object) ya <code>customer</code>, tutacreate new variable ambayo kila variable itahifadhi value yake katika program yako, Mfano wa value ambayo itahifadhi jina la customer wetu</li> </ul> <pre><code>int customerName = customer.name;\nstring customerName = customer.name;\ncout &lt;&lt; customerName;\n</code></pre> <ul> <li> <p>Njia hapo juu ni sawa ila sio best practices kwa sababu ina consume mda kwa hiyo badala ya kutumia njia hiyo unaweza ukatumia structured binding kupata kila value, kwenye C++ wanaita <code>structured  binding</code> upande wa Javascript wanita <code>desctructuring</code> upande wa Python wanaita <code>unpacking</code>.</p> </li> <li> <p>Ili kuweza kufanya desctructuring kwenye structure yetu anza na <code>auto</code> keyword ikifuatiwa na sqaure brackets(mabano) ndani ya hayo mabano andika variables zote kwa kila member ambaye yuko katika umbile(object) yako katika oder inayotakiwa kinyume na hapo uatapata error baada ya kuandika kuandika variables zako tengeneza curl braces { } zako na ndani ya curl braces yako pass jina la umbile(object) yako ambayo iko katika program yako.</p> </li> </ul> <pre><code>auto [id, name, email, isRegistered] {customer};\n// you can print individual members\ncout &lt;&lt; id;\n</code></pre>"},{"location":"intermediate/structures/structures/#nested-structures","title":"Nested Structures","text":"<ul> <li>Nested structure ni kwamba ndani ya structure moja kunakuwa na structure nyingine ambayo imepitishwa katika struct mama,kwenye mfano wetu wa customer tunaweza tukawa na struct ya <code>email</code> ambayo imekuwa nested badala ya kuandika hivi</li> </ul> <pre><code>struct Customers\n{\n    int id;\n    string name;\n    string workEmail;\n    string emailPersonal;\n    bool isRegistered;\n};\n</code></pre> <p>Kwamba kunakuwa na struct kwa ajili ya email kwa ajili ya kazi na struct kwa email ambayo ipo kwa personal use,tunatumia nested struct kwamba kunakuwa na struct kwa ajili ya email kisha tunapitisha struct kwa ajili ya e-mail ndani ya Customers struct! Mfano</p> <pre><code>struct Email\n{\n    string workEmail;\n    string emailPersonal;\n};\n</code></pre> <p>Baada ya struct email kutengenezwa kisha tunapitisha ndani ya Customers struct.</p> <pre><code>struct Customers\n{\n    int id;\n    string name;\n    Email email; // email struct nested\n    bool isRegistered;\n};\n</code></pre> <p>Kutoka kwenye mfano hapo juu,tumepitisha Email struct kwenda kwenye Customers struct kwa hiyo tunakuwa na Email struct pamoja na jina la hiyo nested struct ambayo ni email.</p> <p>Ili kuweza kupitisha value zako kwenye struct yako hakikisha Customer object imekuwa created na Email object imekuwa created pia.</p> <pre><code>    Email email;\n    Customers customers;\n</code></pre> <p>Baada ya hapo ili kuweza kutumia email member(work and personal email) lazima iwe initialized kwanza kama hapo juu <code>Email email;</code> ili kupitisha value zetu kwenye customer struct itakuwa hivi.</p> <pre><code>    Customers customers{\n        12,                                    // customer ID\n        \"Ronald\",                              // customer name\n        {\"ronald@gmail.com\", \"ron@gmail.com\"}, // Email struct with work email and personal email\n        true,                                  // email is registered or not\n    };\n</code></pre> <p>Kwamba customers object inakuwa na member wafuatao ,id, name, email ila kwenye email ni struct object hivyo tutatumia mabano singasinga kupitisha value ambapo object yetu email ina email kwa ajili ya work na personal <code>{\"ronald@gmail.com\", \"ron@gmail.com\"}</code> kisha baada ya hapo member mwingine ni bool value.</p> <p>Ili kuweza kupata access ya work email na personal email iwe printed kwenye screen itakuwa hivi.Tutaumia dot operator kuweza kupata access ya object email kisha tutatumia tena dot operator kuweza kupata access ya personal au work email, au unaweza access email object moja kwa moja kisha ukatumia dor operator kupata work email pamoja na personal email.</p> <pre><code>    cout &lt;&lt; \"Work E-Mail: \" &lt;&lt; customers.email.workEmail &lt;&lt; endl;\n    cout &lt;&lt; \"Personal E-Mail: \" &lt;&lt; customers.email.emailPersonal &lt;&lt; endl;\n    // Output Work E-Mail: ronald@gmail.com\n    // Personal E-Mail: ron@gmail.com\n</code></pre>"},{"location":"intermediate/structures/structures/#comparing-structures","title":"Comparing Structures","text":"<p>-Huwezi kufanya comparison ya structure moja na structure nyingine ila unaweza kufanya comparison ya individual comparion ya member moja na mwingine.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Email\n{\n    string workEmail;\n    string emailPersonal;\n};\n\nstruct Customers\n{\n    int id;\n    string name;\n    Email email; // email struct nested\n    bool isRegistered;\n};\n\nint main()\n{\n    Email email;\n    Customers customer1{\n        12,\n        \"Ronald\",\n        {\"ronald@gmail.com\", \"ron@gmail.com\"},\n        true,\n    };\n\n    Customers customer2{\n        12,\n        \"Ronald\",\n        {\"ronald@gmail.com\", \"ron@gmail.com\"},\n        true,\n    };\n\n    if (customer1.email.emailPersonal == customer2.email.emailPersonal &amp;&amp; customer1.email.workEmail == customer2.email.workEmail &amp;&amp; customer1.id == customer2.id &amp;&amp; customer1.name == customer2.name &amp;&amp; customer1.isRegistered == customer2.isRegistered)\n    {\n        cout &lt;&lt; \"Equal \" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/structures/structures/#working-with-methods","title":"Working With Methods","text":"<ul> <li>Katika C++,unaweza ukadefine methods au kwa jina lingine zinaitwa member functions kwa ajili ya struct kama ambavyo unaweza ukawa na methods kwenye class.Utofauti kati ya struct na class katika C++ ni kwamba member wa struct ni public by default.Hapo chini ni mfano unaoelezea namna ya kufanya kazi na methods katika struct.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n// Define a struct called Person\nstruct Person\n{\n    string name;\n    int age;\n\n    // Method to print the details of the person\n    void printDetails()\n    {\n        cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl;\n        cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; endl;\n    }\n\n    // Method to increment the age by a given value\n    void incrementAge(int years)\n    {\n        age += years;\n    }\n};\n\nint main()\n{\n    // Create an instance of the Person struct\n    Person person1;\n    person1.name = \"John\";\n    person1.age = 25;\n\n    // Call the printDetails method\n    cout &lt;&lt; \"Before increment:\" &lt;&lt; endl;\n    person1.printDetails();\n\n    // Call the incrementAge method\n    person1.incrementAge(5);\n\n    // Call printDetails again to see the updated age\n    cout &lt;&lt; \"After increment:\" &lt;&lt; endl;\n    person1.printDetails();\n\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/structures/structures/#operator-overloading","title":"Operator Overloading","text":"<p>-</p>"},{"location":"intermediate/structures/structures/#array-of-structures","title":"Array of Structures","text":"<ul> <li>Ili kuweza kutumia array of structures basi hapa tutatumia <code>vectors</code>, vectors ni dynamic arrays kwamba zinaongeneza na kupungua size bila ya kufanya hardconding yaani automatic.Ili kuweza kutumia hizo vector lazima header file iwepo <code>#include &lt;vector&gt;</code>, kwenye mfano pale juu tumetmia customer kama ni object yetu ila hapa tunaweza tukawa na na customer object ambayo inaweza ikachukua vitu vingine na hivyo vitu tunahifadhi ndani ya vector yetu,kutumia vector tunaanza na vector keyword na ikifuatiwa na &lt;&gt; ndani ya &lt;&gt; tunapitisha jina la object yetu au struct yetu ila sisi struct yetu ni Customers baada ya hapo nje ya &lt;&gt; litafuatia jina la vector yetu ambayo ni cutomers,ila vector inaoffer function inaitwa <code>push_back</code> ambayo inakuwezesha wewe kuweza kupitisha values zako.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Customers\n{\n    int id;\n    string name;\n    string email;\n    bool isRegistered;\n};\n\nint main()\n{\n    vector&lt;Customers&gt; customers;\n    customers.push_back({23, \"Neicore\", \"neicore@gmail.com\", false});\n    cout &lt;&lt; customers[0].email;\n    return 0;\n}\n</code></pre> <p>Ili kuweza kufanya iteration katika vector tunatumia <code>for range</code> loop.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Customers\n{\n    int id;\n    string name;\n    string email;\n    bool isRegistered;\n};\n\nint main()\n{\n    vector&lt;Customers&gt; customers;\n    customers.push_back({222, \"Ronald\", \"ronald@gmail.com\", true});\n    customers.push_back({245, \"Neicore\", \"neicore@gmail.com\", false});\n\n    for (auto customer : customers)\n    {\n        cout &lt;&lt; customer.email &lt;&lt; endl; \n        // Output: ronald@gmail.com \n        // neicore@gmail.com\n    }\n    return 0;\n}\n</code></pre>"},{"location":"intermediate/structures/structures/#pointer-to-structures","title":"Pointer to Structures","text":""},{"location":"intermediate/structures/structures/#functions-with-structures","title":"Functions with Structures","text":""},{"location":"intermediate/structures/structures/#passing-structures-to-functions","title":"Passing Structures to Functions","text":""},{"location":"intermediate/structures/structures/#dynamic-allocation-of-structures","title":"Dynamic Allocation of Structures","text":""},{"location":"intermediate/structures/structures/#structures-and-classes","title":"Structures and Classes","text":""},{"location":"intermediate/structures/structures/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Use Pascal Case naming convention, katika programming kuna naming conventions nyingi sana ila kwenye upande wa structures tutaumia Pascal naming convention mfano; Kila neno linalo anxza linakuwa capitalized   <code>struct CustomerDetails</code></p> </li> <li> <p>Whenever we create an instance of the class is the good practices to initialize it's memember kinyume na hapo utapata garbage value(junk value).Kwenye upnade wa string always huwa inakuwa initilaized kuwa empty string hivyo hakuna haja ya kuwa initialized.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// define struct\nstruct Customers\n{\n    int id;\n    string name;\n    string email;\n};\n\nint main()\n{\n    // create an instance of umbile(object) from Customer\n    Customers customer;\n\n    // initialize it's members\n    cout &lt;&lt; customer.name;\n    // output:\n    return 0;\n}\n</code></pre> <p>Kuna baadhi ya code editors kama hujaweka values kwenye struct members wako kama ni int huwa inakuwa by default ambayo ni zero.</p> <p>\u2b06\ufe0f Return to Top</p>"},{"location":"intermediate/templates/templates/","title":"Templates in C++","text":"<ul> <li>Introduction</li> <li>Function Templates</li> <li>Class Templates</li> <li>Template Specialization</li> <li>Template Metaprogramming</li> <li>Template Containers</li> <li>Template Libraries</li> <li>Template Best Practices</li> <li>Common Pitfalls</li> </ul>"},{"location":"intermediate/templates/templates/#introduction","title":"Introduction","text":""},{"location":"intermediate/templates/templates/#function-templates","title":"Function Templates","text":""},{"location":"intermediate/templates/templates/#class-templates","title":"Class Templates","text":""},{"location":"intermediate/templates/templates/#template-specialization","title":"Template Specialization","text":""},{"location":"intermediate/templates/templates/#template-metaprogramming","title":"Template Metaprogramming","text":""},{"location":"intermediate/templates/templates/#template-containers","title":"Template Containers","text":""},{"location":"intermediate/templates/templates/#template-libraries","title":"Template Libraries","text":""},{"location":"intermediate/templates/templates/#template-best-practices","title":"Template Best Practices","text":""},{"location":"intermediate/templates/templates/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"mastering-STL/stl/","title":"Mastering STL","text":"<ul> <li>Algorithms</li> <li>Containers</li> <li>Pair</li> <li>Sequence Containers</li> <li>Vectors</li> <li>List</li> <li>Deque</li> <li>Associative Containers</li> <li>Set</li> <li>Multiset</li> <li>Map</li> <li> <p>Multimap</p> </li> <li> <p>Unordered Containers</p> </li> <li>Unordered Set</li> <li>Unordered Multiset</li> <li>Unordered Map</li> <li>Unordered Multimap</li> <li>Queue</li> <li> <p>Tuple</p> </li> <li> <p>Stack</p> </li> <li>Functions</li> <li>Iterators</li> </ul> <p></p>"},{"location":"mastering-STL/stl/#algorithms","title":"Algorithms","text":""},{"location":"mastering-STL/stl/#pair","title":"Pair","text":"<ul> <li>Pair kama jina lilivyo kwamba ndani ya pair huwa na vitu viwili hivyo kwenye STL pair inahifadhi vitu viwili,arrays inahifadhi data ambazo zio za mchanganyiko ila kwa kutumia pair unaweza kuhifadhi data za mchanganyiko mbalimbali kama,<code>string na integer</code> au hata <code>int kwa int</code> hata <code>int kwa double</code>.</li> </ul> <p>Syntax</p> <pre><code>    pair&lt;Type1, Type2&gt; pElement;\n</code></pre> <ul> <li>Kufanya declaration ya pair lazima <code>utility</code> library iwe included kwa juu kabla ya kufanya declaration,baada ya hapo ndani ya main function anza na <code>pair</code> keyword ikifuatiwa na <code>&lt;&gt;</code> ambapo data type zako zinakaa ndani yake,ambapo hapo chini nitatumia <code>int</code> na <code>string</code> baada ya kufanya hivyo nje ya <code>&gt;</code> tutaacha nafasi na kuweka jina la pair yetu <code>mwanafunzi</code> baada ya hapo,kuna njia na kuweka value za integer na string,unaweza ukaweka moja kwa moja kwamba baada ya jina pair utaweka kitendakazi = (assignment operator) kisha value zako zitakuwa ndani ya {} mabano singasinga ndani ya mabano singa singa kutakuwa na value zako katika mfuatano unaotakiwa mfano,pale juu tumeanza na int hivyo itakuwa hivi <code>{2, \"Njox\"}</code>.</li> </ul> <pre><code>    #include &lt;iostream&gt;\n    #include &lt;utility&gt;\n\n    using namespace std;\n\n    int main()\n    {\n    pair&lt;int, string&gt; mwanafunzi = {10, \"Njox\"};\n    return 0;\n    }\n</code></pre> <ul> <li> <p>Statement kwenye mfano wetu hapo juu,inafanya declaration ya mwanafunzi kuwa object ya aina(type) ya pair. Component ya mwanafuzni ni int; component ya pili ni ya aina ya string.Endapo kama kutakuwa hamna value ambazo zipo kwenye declaration ya mwanafuzni,component ya kwanza na component ya pili zitakuwa initialized na thamani a,bayo ni default na default vaue ni sifuri 0 na kama ni member aina yake itakuwa ni string itakuwa empty.</p> </li> <li> <p>Kuna njia nyingine ya kuzipa value kwenye za data type zako,ilikuweka value kwenye pair yako utaanza na jina la pair ambapo pair yetu ni <code>mwanafunzi</code> kisha dot operator kuweka kupata methods ambazo zipo ndani ya hio pair kama pair ya kwanza inakuwa na method ya <code>.first</code> kama ya pili itakuwa na <code>.second</code>,Angalia mfano hapo chini zaidi!</p> </li> </ul> <pre><code>    #include &lt;iostream&gt;\n    #include &lt;utility&gt;\n\n    using namespace std;\n\n    int main()\n    {\n    pair&lt;int, string&gt; mwanafunzi;\n    mwanafunzi.first = 10;\n    mwanafunzi.second = \"Njox\";\n    return 0;\n    }\n</code></pre> <ul> <li>Njia ya pili ya kuweza  kuweka values zako baada ya kuweka jina la pair yako itafuatiwa na mabano na ndani ya mabano utaweka value zako katika mfuatano ambao umefanya declaration kwa mfano pale juu tulianza na intger ikifuatiwa na string hivyo inatakiwa iwe hivyo.</li> </ul> <pre><code>    #include &lt;iostream&gt;\n    #include &lt;utility&gt;\n\n    using namespace std;\n\n    int main()\n    {\n    pair&lt;int, string&gt; mwanafunzi(10, \"Njox\");\n    return 0;\n    }\n</code></pre> <ul> <li>Statement hapo chini inaonesha namna ambayo unaweza kufanya output za value ya object ambayo type yake ni pair</li> </ul> <pre><code>    #include &lt;iostream&gt;\n    #include &lt;utility&gt;\n\n    using namespace std;\n\n    int main()\n    {\n    pair&lt;int, string&gt; mwanafunzi = {12, \"Njox\"};\n    cout &lt;&lt; mwanafunzi.first &lt;&lt; \" \" &lt;&lt; mwanafunzi.second &lt;&lt; endl;\n    // Output: 12 Njox\n    return 0;\n    }\n</code></pre> <ul> <li>Pia ni muhimu kujua kwamba pair inahifadhi data ambazo ni mbili na si vingine,vipi endapo tukijaribu kuweka data zaidi ya mbili?</li> </ul> <pre><code>    #include &lt;iostream&gt;\n    #include &lt;utility&gt;\n\n    using namespace std;\n\n    int main()\n    {\n    pair&lt;int, string, int&gt; mwanafunzi;\n    mwanafunzi.first = 10;\n    mwanafunzi.second = \"Njox\";\n    mwanafunzi.third = 12;\n    return 0;\n    }\n</code></pre> <p>Endapo tutaongeza member mmoja kwenye pair yetu,tutapata error hii hapo chini kwamba arguments zimezidi,arguments inabidi ziwe 2 tu.</p> <pre><code>    too many arguments for class template \"std::pair\"C/C++(443)\n    wrong number of template arguments (3, should be 2)gcc\n</code></pre> <ul> <li>Tunaweza pia tukawa na nested pairs katika STL,kwamba object <code>mwanafunzi</code> ambayo type yake ni pair kunakuwa kwenye component ya pili kunakuwa na pair nyingine ambayo itakuwa ni ya object ambayo ndani ya hiyo pair ya pili ndio kunakuwa na value zako ambapo inaweza ikawa string au integer,ni muhimu kuzingatia jinsi ambavyo value zetu zinakuwa nested kwa sana ndio inakuwa tabu na pia complexity inaongezeka kwenye programu yako.</li> </ul> <pre><code>    pair&lt;int, pair&lt;string, int&gt;&gt; mwanafunzi = {2, {\"Njox\", 20}};\n</code></pre> <ul> <li>Kupitia mfano hapo juu kuna component wawili tu wa umbile(object) ambapo component wa kwanza ni integer na component wa pili ni pair na huyo component wa pili wa pair object wana value mbili value ya kwanza ni string na ya pili ni integer.Kupata value ya member wa kwanza itakuwa ni <code>mwanafunzi.first</code></li> </ul> <pre><code>    pair&lt;int, pair&lt;string, int&gt;&gt; mwanafunzi = {2, {\"Njox\", 20}};\n    cout &lt;&lt; mwanafunzi.first; // Output: 2\n</code></pre> <p>Kupata thamani ya component ya pili,kumbuka component ya pili ni pair,kupata value ya component ya pili ambayo ni ya kwanza itakuwa hivi.</p> <pre><code>    pair&lt;int, pair&lt;string, int&gt;&gt; mwanafunzi = {2, {\"Njox\", 20}};\n    cout &lt;&lt; mwanafunzi.second.first; // Output: Njox\n</code></pre> <p>Hapo ni sawa na kuambia program yetu kwanza nenda kwenye object yetu ambayo ni mwanafunzi chukua component ya pili kwenye mwanafunzi object kisha chukua value ya kwanza.</p> <p>Kama component ya pili kwenye pair ila value ni ya pili itakuwa hivi.</p> <pre><code>    pair&lt;int, pair&lt;string, int&gt;&gt; mwanafunzi = {2, {\"Njox\", 20}};\n    cout &lt;&lt; mwanafunzi.second.second; // Output: 20\n</code></pre>"},{"location":"mastering-STL/stl/#function-make_pair","title":"Function make_pair()","text":"<ul> <li>Header file utility pia lina defintion ya function template make_pair.Kwa msaada ya function make_pair, tunaweza kutengeneza pairs pia kuzipa type za pair. Defintion ya function template make_pair inafanana na ifuatayo</li> </ul> <pre><code>template &lt;class T1, class T2&gt;\npair&lt;T1, T2&gt; make_pair(const T1&amp; X, const T2&amp; Y)\n{\nreturn (pair&lt;T1, T2&gt;(X, Y));\n}\n</code></pre> <p>Kutoka kwenye defintion ya function template make_pair, ni wazi kwamba function template make_pair ni value returning function na unarudisha value ya type pair.Component za value ambazo zimerudishwa na function template make_pair inapitishwa kama parameter kwenye function template make_pair.Expression hapo chini!</p> <pre><code>make_pair(75, 'A')\n</code></pre> <p>Itarudisha value ya aina ya pair.Value ya component ya kwanza ni 75; na value ya component ya pili itakuwa ni character 'A' Function <code>make_pair</code> ni muhimu kama pair inatumika kupitishwa kwenye function kama argument.Angalia mfano hapo chini</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\n// create function and pass pair as parameter(pair) to\nvoid funcExp(pair&lt;int, int&gt; x)\n{\n    cout &lt;&lt; \"funcExp: \" &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; endl;\n}\n\nint main()\n{\n    funcExp(make_pair(75, 80));\n    return 0;\n}\n</code></pre> <p>Kwenye function hapo juu nimetengeneza function inayoitwa <code>funcExp</code> inachukua parameter pair kama parameter, <code>pair&lt;int, int&gt; x</code>,ndani ya function tunatapata value ambazo zipo kwenye object <code>x</code> ndani ta function tunapass function yetu <code>make_pair(75, 80)</code>.</p> <ul> <li>Huwa kunakuwa na pair za array katika programm yako declaration inakuwa kawaida tu kwamba linaanza na pair keyword ikifuatiwa na &lt;&gt; ndani yake kunakuwa na data type zako kisha jina la pair yako ila kwenye upande wa array baada ya kundika jina la pair yako itafuatiwa na square brackets na ndani ya mabano kutakuwa na idadi ya members wako ambao inabidi wawe ndani ya array yako,mfano array yangu kama ina members watatu itakuwa hivi <code>arrayName[3]</code> baada ya itafuatiwa na assignment operator ambayo ni = na baadaa ya = itafuatiwa na mabano singasinga ndani ya mabano kutakuwa na values zako katika program yako mfano array yetu ina member watatu hivyo ndani yake itakuwa na member wa kwanza ambae yuko katika index ya zero(sifuri), kesho itafuatiwa na member wa pili ambao wapo index ya 1 na mwisho member 3 ambao wapo index ya 2.Angalia mafano hapo chini!</li> </ul> <pre><code>    pair&lt;int, int&gt; arr[3] = {{1,2}, {3,4}, {5,6}};\n</code></pre> <p></p> <p>Kwenye mfano hapo ni kwamba tumetengeneza pair array ambayo ina value mbalimbali kwenye index ya sifuri kuna value mbili ambazo ni 1 na 2,kwenye index ya kwanza kuna value 2 ambazo ni 3 na 4 kwenye index ya pili kuna value mbili ambazo ni 5 na 6,kumbuka kwamba pair inahifadhi value mbili tu hivyo zinakuwa na member wawili tu kinyume na hapo utapata error!</p> <ul> <li>Ili uweze kupata access ya value zako kwenye array kama basi kama ni member wa kwanza ina maana tutaanza katika index ya sifuri na kwenye index ya sifuri kupata value zile mbili za object yet,value ya kwanza itakuwa accessed kwa kutumia dot operator ikifuatiwa na first na value ya pili tutatumia dot operator ikifuatiwa na second function,angalia mfano hapo chini.</li> </ul> <pre><code>    pair&lt;int, int&gt; arr[3] = {{1, 2}, {3, 4}, {5, 6}};\n\n    cout &lt;&lt; \"Fist Element kwenye index ya 0 ni: \" &lt;&lt; arr[0].first &lt;&lt; endl;\n    cout &lt;&lt; \"Second Element kwenye index ya 0 ni: \" &lt;&lt; arr[0].second &lt;&lt; endl;\n    /*\n    Fist Element kwenye index ya 0 ni: 1\n    Second Element kwenye index ya 0 ni: 2\n    */\n</code></pre> <p>Task yako ni kuandika program ambayo itaweza kupata value ya array kwenye index ya pili ikiwa na element ya kwanza na ya pili,na array katika index ya kwanza ikiwa na element ya kwanza na ya pili</p> <p>Kujifunza vizuri namna pair zinafanya kazi pitia project hii</p>"},{"location":"mastering-STL/stl/#containers","title":"Containers","text":"<ul> <li>Container zinatumika manage umbile(object) za aina fulani.STL Containers zimegawanyika katika categories nne ambazo ni:</li> <li>Sequence Containers(Sequantial)</li> <li>Associative Containers</li> <li>Container Adapter</li> </ul>"},{"location":"mastering-STL/stl/#sequence-containers","title":"Sequence Containers","text":"<ul> <li>Kila umbile(object) katika sequence(mfuatano) lina sehemu(position) yake maalumu,pia mpangilio wa element unakuwa maintained kwa namna ambavyo unakuwa umehifadhiwa.Mfano wa sequence containers ni vectors, list na deque.Karibia kila sequence containers zina aina moja ya operesheni ambayo unaweza ukafanya kwa ajili ya manipulation.</li> </ul>"},{"location":"mastering-STL/stl/#vectors","title":"Vectors","text":"<ul> <li> <p>Vector zinahifadhi na pia zina manage objects zake katika dynamic array.Kwa sababu array ni random data structure,element za array unaweza ukazipata randomly.Kuweka item katiakati au mwanzoni katika array inatumia muda hususani kama array yako ni kubwa,lakini, kuweka data(item) mwishoni ni haraka zaidi. Jina la class ambayo inafanya implementation ya vector container ni vector.Jina la header file  ambalo lina class <code>vector</code> ni vector,Hivyo, kutumia vector container katika program,program lazima header file <code>#include &lt;vector&gt;</code> liwe included juu kabisa!</p> </li> <li> <p>Kabla hujapitia kipande hichi hakikisha umepitia hapa, vector zipo faster zaidi ya array na ili uweze kutumia vector ni muhimu kuweka header kwa ajili ya vector yako.Ni muhimu kuzangatia kwamba kama hujui idadi ya data zako ambazo unataka ziingie katika program yako ni vizuri kutumia vector badala ya array kwanini? Ili kutumia array ni muhimu kuzingatia kwamba je ni kiasi gani cha data unataka ziwe ndani ya array yako mfano kama array yako inadata za wanafunzi mfanon wako 4 itakuwa hivi</p> </li> </ul> <pre><code>    int studentsMark[4] = {12, 56, 79, 87};\n</code></pre> <p>Vipi endapo hatujui idadi ya members wako ambao wapo ndania array yako itakuwa hivi!</p> <pre><code>    int studentsMark[] = {12, 56, 79, 87};\n</code></pre> <p>Ila shida inapokuja kwenye program yetu hapo juu ni kwenye upade wa memory management kwamba interpreter ikiona kwenye program yetu tumeandika kitu kama hicho inachofanya inaenda kufanya allocation ya nafasi kwenye memory ila interpreter yetu nayo haijui kwamba je ni kiasi gani cha memory kinachohitajila kwa ajili ya array yetu ambapo inapelekea interpretr nufanya allocation kubwa ya memory na memory hiyo inaweza isitumike ikapelekea memory leak kwahiyo kwenye kitu kama hichi katika program yetu tatuzi ya hili tatizo ni kutumia vector.</p> <ul> <li>Kufanya declaration ya vector utaanza neno vector ikifuatiwa na alama ya &lt;&gt; ndani yake tunaweka aina ya data mabyo inabidi iwe ndani yake,mfano unaweza ikawa int,double hata string nje ya &lt;&gt; tunaweka jina la vector yako.</li> </ul> <pre><code>    vector&lt;int&gt; wanafunzi;\n    vector&lt;string&gt; name;\n</code></pre> <p>Hapo juu tumefanya declaration ya vector ambayo ni wanafunzi ikiwa ni ya type integer.Tumefanya declaration ya vector yetu ya kwanza inaitwa wanafunzi ya pili inaitwa name ila zote vectors zetu hazina value yeyote,kwa njia rahisi tunaweza weka value katika njia zifuatazo.</p> <pre><code>    vector&lt;string&gt; name(5,\"Njox\"); // {\"Njox\", \"Njox\", \"Njox\", \"Njox\", \"Njox\"}\n</code></pre> <p>Hapo vector yetu name imekuwa declared ikiwa na mabano na nadni ya mabano kuna 5 na neno \"Njox\" hapo ni sawa kwamba vectors 5 zimekuwa initialized na zote zikiwa na value ya \"Njox\",ili kuweza kutengeneza copy ya vector moja kwa nyingine ni rahisi,unahitaji kufanya declaration ya vector moja(ambayo unataka ikopiwe) kisha declaration ya vector nyingine ambayo inakopi kutoka kwenye array ya kwanza,angalia mfano hapo chini!</p> <pre><code>    vector&lt;int&gt; v1(5, 20);\n    vector&lt;int&gt; v2(v1);\n</code></pre> <ul> <li> <p>Sasa tumejua jinsi ya kufanya decalartion ya vector katika kipande cha sequence container,sasa ngoja tujue jinsi ya kufanya manipulation ya data ambazo zimehifadhiwa katika vector.Kufanya hivyo inabidi ujue basic operesheni zifuatazo!</p> </li> <li> <p>Item Insertion</p> </li> <li>Item Deletion</li> <li>Stepping through the elements of a vector container</li> <li> <p>Operesheni zinatotumika kupata access ya element za vector container.</p> </li> <li> <p><code>vectorName.at(index)</code>- Inarudisha element katika position ambayo imekuwa specified kutokana na index.</p> </li> </ul> <pre><code>\n</code></pre> <p>2.<code>vectorName[index]</code>- Inarudisha element katika position ambayo imekuwa specified kutokana na index.</p> <pre><code>\n</code></pre> <p>3.<code>vectorName.front()</code>- Inarudisha element ya kwanza katika vector.</p> <pre><code>\n</code></pre> <p>4.<code>vectorName.back()</code>- Inarudisha element ya mwisho katika vector.</p> <pre><code>\n</code></pre> <ul> <li> <p>Vector ya kwanza imekuwa declared na kuwa initialized ikiwa na element 5 zote zikiwa na value ya 20,na vector ya pili ambayo ni v2 imekuwa declared ila imekopi values za array ya v1 katika program yako.</p> </li> <li> <p>Ili kuweza kuweka values ndani ya vector yako kuna njia mbalimbali ila kuna method inaitwa <code>.pushBack()</code> na hata pia <code>.emplace_back()</code> ndani ya mabano tunapitisha value zako.</p> </li> <li> <p><code>push_back()</code> function inachofanya inaingiza value ambayo umeweka kwenye mabano kwenda kwenye value yako pia kuna <code>emplace_back()</code> nayo pia inaweka value mwishoni mwa vector yako ila kuna utofauti ulipo kati ya push_back na emplace_back,emplace_back ipo haraka ukifananisha na push_back katika vector.</p> </li> <li> <p>Kwenye upande wa vector pia unaweza kutengeneza pair ya vector,kwa declaration ya pair yako inakuwa hivi <code>pair&lt;int int&gt;pairName</code> ila declaration ya vector inakuwa hivi <code>vector&lt;int&gt; vectorName</code> kinchobadilika ni kwamba badala ya ile data type yako ambayo ni int kwenye vector unabadili na kuweka declaration ya pair yako <code>vector&lt;pair&lt;int, int&gt;&gt; vec;</code></p> </li> </ul> <pre><code>    vector&lt;pair&lt;int, int&gt;&gt; vec;\n</code></pre>"},{"location":"mastering-STL/stl/#list","title":"List","text":""},{"location":"mastering-STL/stl/#queue","title":"Queue","text":"<ul> <li>Queue ni sawa na stack ila utofauti wao ni kwamba queue inatumia FIFO Algorith(First In First Out),Kufanya declaration ya queue unaanza na </li> </ul>"},{"location":"mastering-STL/stl/#deque","title":"Deque","text":"<ul> <li>Deque ni moja kati ya sequenc containers katika STL,deque inasimama badala ya double ended queue.Deque containers zinakuwa implemented kama dynamic arrays katika namna elements zinakuwa inserted katika both ends.Deque zinaweza expand katika pande yeyote,insertion mwishoni,katikati zipo haraka.Insertion katikati zinatumia muda kwa sababu element katika katika queue zinahitaji ziwe shifted.Jina la class ambalo linafanya definition ya deque container ni deque,class deque na function ya kufanya implementation ya operesheni ambazo ziko kwenye deque object,pia zipo kwenye header file deque.Hivyo kuweza kutumia seque container katika program inabidi header file iwe included.</li> </ul> <pre><code>#include &lt;deque&gt;\n</code></pre> <ul> <li>Kufanya declaration ya qeque kwenye program yako utaanza na deque keyword ikifuatiwa na &lt;&gt; ndani yake kunakuwa na aina ya data nje ya &lt;&gt; utaweka jina la deque yako.</li> </ul> <pre><code>    deque&lt;int&gt; dq;\n</code></pre>"},{"location":"mastering-STL/stl/#associative-containers","title":"Associative Containers","text":""},{"location":"mastering-STL/stl/#set","title":"Set","text":""},{"location":"mastering-STL/stl/#multiset","title":"Multiset","text":""},{"location":"mastering-STL/stl/#map","title":"Map","text":""},{"location":"mastering-STL/stl/#multimap","title":"Multimap","text":""},{"location":"mastering-STL/stl/#unordered-containers","title":"Unordered Containers","text":""},{"location":"mastering-STL/stl/#unordered-set","title":"Unordered Set","text":""},{"location":"mastering-STL/stl/#unordered-multiset","title":"Unordered Multiset","text":""},{"location":"mastering-STL/stl/#unordered-map","title":"Unordered Map","text":""},{"location":"mastering-STL/stl/#unordered-multimap","title":"Unordered Multimap","text":""},{"location":"mastering-STL/stl/#tuple","title":"Tuple","text":""},{"location":"mastering-STL/stl/#stack","title":"Stack","text":"<ul> <li>Stack inafanya kazi kwa kutumia algorithm ya LIFO(Last in First Out),kwamba element ambayo itakuwa ya mwisho kuwa added ndio itakuwa ya kwanza kutolewa.Declaration ya stack unaanza na stack keyword kisha &lt;&gt; ndani ya &lt;&gt; inakaa data type kisha nje ya &lt;&gt; inafuata jina la stack yako,usisahau kuweka header yako <code>##include &lt;stack&gt;</code>.</li> </ul> <pre><code>    stack&lt;int&gt; st;\n</code></pre> <ul> <li> <p>Ili kuweza kufanya baadhi ya operation kwenye stack yako kuna methods 7 tu, emplace, push, empty, pop, top, size, swap</p> </li> <li> <p>push: Hapo tu tumefanya declaration ya stack yetu ila iko empty hivyo kama tunataka tuweke value kwenye stack yetu tutaumia method ya <code>push()</code> ndani ya mabano tunaweka value ya data.Mfano,kupitia mfano inakuwa kwamba ndani ya stack yetu kunakuwa na value yetu ambayo ni 1.</p> </li> </ul> <pre><code>    st.push(1); // {1}\n</code></pre> <ul> <li>emplace:emplace ni sawa na push ila utofauti wake ni kwamba emplace ipo haraka ukifananisha na push kwenye stacks.</li> </ul> <pre><code>    st.emplace(2); // {2, 1}\n</code></pre> <ul> <li>empty:empty inatumika kuangalia kama stack yako ipo tupu au laa,mfano tunaweza tukatumia .empty kuangalia kama stack ina kitu ndani au hamna na kama hamna tunaweza ukapush value kwenye stack yetu.Kumbuka kwenye C++ kama jibu ni false inarudisha 0 na kama ni true inarudisha 1 kumbuka mwanzoni nilielekeza namna jinsi ya kutumia <code>boolalpha</code> kama umesahahu kapitie tena!</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n    stack&lt;int&gt; st;\n\n    if (st.empty() == true)\n        cout &lt;&lt; \"Stack is empty!\" &lt;&lt; endl;\n    else\n        cout &lt;&lt; \"The last element added into a stack: \" &lt;&lt; st.top() &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <ul> <li>pop:pop() inatumika kutoa element ya mwisho kabisa ambayo imekuwa added kwenye stack yetu.Mfano</li> </ul> <pre><code>\n</code></pre> <ul> <li>top:top inarudisha value ya mwisho kuwekwa kwenye stack yako.</li> </ul> <pre><code>    stack&lt;int&gt; st;\n\n    // push\n    st.push(1); // {1}\n\n    // emplace\n    st.emplace(2); // {2, 1}\n\n    cout &lt;&lt; st.top(); // output: 2\n</code></pre> <p>Mwanzoni kabisa tulifanya declaration hii <code>stack&lt;int&gt; st;</code> kisha tunapush 1 na emplace 2 hivyo stack yetu itakuwa hivi <code>{2, 1}</code> kwa hiyo top inachofanya inatoa output ya value ya mwisho kuwa added kwenye stack yetu hivo 2 endapo tutatumia <code>s.pop()</code> value ya mwisho kuwa added itatolewa na hivo baada ya hapo tukijaribu <code>cout &lt;&lt; s.top()</code> tutapata 1 kwa sababu 2 imetolewa kwenye stack yetu,Zingatia hilo! Mfano</p> <pre><code>    stack&lt;int&gt; st;\n\n    // push\n    st.push(1); // {1}\n\n    // emplace\n    st.emplace(2); // {2, 1}\n\n    // pop(removes the last element to be added into a stack)\n    st.pop();\n\n    cout &lt;&lt; st.top(); // output: 1\n</code></pre> <ul> <li>size: inarudisha idadi ya element ambazo zipo kwenye stack.Mfano hapo chini baada ya kufanya declaration ya stack <code>st</code> tumepush 23 kwenda kwenye stack yetu na ndio ipo 23 tu ndani ya stack.</li> </ul> <pre><code>    stack&lt;int&gt; st;\n    st.push(23); // {1}\n    cout &lt;&lt; st.size() &lt;&lt; endl; // Output: 1\n</code></pre> <ul> <li>swap:Kama ambazo neno linsema swap unaweza swap values za stack moja kwenda kwenye stack nyingine kwenye program yako.</li> </ul> <pre><code>    stack&lt;int&gt; st1, st2;\n    st1.swap(st2);\n</code></pre>"},{"location":"mastering-STL/stl/#functions","title":"Functions","text":""},{"location":"mastering-STL/stl/#iterators","title":"Iterators","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"networking/networking/","title":"Networking in C++","text":""},{"location":"networking/networking/#introduction","title":"Introduction","text":"<ul> <li>Introduction</li> <li>OSI Model</li> <li>Ports</li> <li>IP Addresses</li> <li>Sockets</li> </ul>"},{"location":"networking/networking/#architecture","title":"Architecture","text":""},{"location":"networking/networking/#introduction_1","title":"Introduction","text":"<ul> <li> <p>Hakikisha unajua baadhi ya basic za newtorking kama OSI model na kwa namna gani inafanya kazi, IP Adress, Port.</p> </li> <li> <p>Connection always inakuwa kati ya devices mbili(vifaa viwili), na kila pande inatumia portnumber yake na IP yake.Always upande mmoja huwa unaitwa client na upande mwingine huwa unaitwa server.Kwenye upande wa server ninaweza nikasema wamba na kama central kwamba maombi au request zako zote zikitumwa server ndio inarudisha majibu kwenda wa client ambaye ndio wewe baada ya kurequest kitu fulani na pia kwenye upande wa kurudisha majibu tunweza tukasema kwamba ni resposne ya response inaweza ikawa ya aina mbambali kwamba majibu yamerudishwa au majibu hayajarudishwa kwako(client).</p> </li> </ul> <ul> <li>Kazi ya server ni kusikiliza na kusubilia connection zinazokuja.Hiki kitendo kinaitwa listening ambacho mara nyingi kinafanwa katika IP na namba ya port.</li> </ul>"},{"location":"networking/networking/#ip-addresses","title":"IP Addresses","text":"<ul> <li>Server pamoja na client zinatumia IP pamoja na port number,IP address ya server pamoja na client zinakuwa configured wakati wa network setup unless imekuwa allocated dynamically.</li> <li>Machine inaweza ikawa na interface card(NIC) zaidi ya moja, na katika situation kama hiyo basi machine inakuwa na IP Address zaidi ya moja.</li> <li>Wakati wa kutengeneza network program port number ya server mara nyingi huwa inakuwa specified ndani ya code ila client port number inakuwa allocated na O/S.</li> <li>Loopback address <code>127.0.0.1</code> refers to the current machine.Hii inaweza ikatumika wakati wa kuetengeneza test ya client na server kwenye machine moja(single machine).</li> <li>Ports zinakuwa idemtified na namba na kila TCP au UDP packet zinakuwa na source port na destination port.</li> </ul>"},{"location":"networking/networking/#ports","title":"Ports","text":"<ul> <li>Port numbers(16 bit address) inakuwa integer kati ya 1 na 65.535, Ports 1.1023 zinakuwa described kama know ports zinakuwa reserved kwa ajili ya specific applications(port 21 FTP).</li> <li>Ni vizuri na pia unashauriwa kuchagua number zaidi ya 1024.Ili kuwa na uhakika kabisa kwamba port yako haipo kwenye kutumika.</li> </ul>"},{"location":"networking/networking/#sockets","title":"Sockets","text":"<ul> <li>Socket ni software abstraction ambayo inatumika kwa ajili ya kutuma na kupokea data kati ya endpoints over a network.Katika C++, sockets zinakuwa created kwa kutumia networking libraries kama <code>Boost.Asio</code> au standard <code>&lt;netinet/in.h&gt;</code> libraray kwa ajili ya POSIX systems.</li> <li>Sockets zinaweza zikawa na aina mabambali kama TCP sockests(stream oriented) au UDP sockets(datagram oriented), depending on the underlying protocol.</li> <li> <p>Bomba mbili kati ya computer katika newtork ambazo data zinapita ndio tunaita Sockets (Mulholland 2004), karibia kila Winsock(window sockets) zinafanya kazi katika socket,pande zote za connection zinatumia socket.Pia sockets ni two way kwamba data zinaweza zikatumwa na pia zinaweza zikapokelewa katika socket.Kuna aina mbili za socket</p> <ol> <li>Streaming Socket(SOCK_STREAM)TCP</li> <li>Datagram Socket(SOCK_DGRAM)UDP</li> </ol> </li> <li> <p>Katika C++, sockets zinatumika kwa ajili ya kutengeneza connections, kutuma na kupokea data na kumanage network communication.</p> </li> </ul>"},{"location":"networking/networking/#osi-model","title":"OSI Model","text":""},{"location":"projects/projets/","title":"C++ Projects for All Skill Levels","text":"<p>Katika sehemu hii utaweza kupitia mfano wa project ambazo utaweza kutengeneza kuanzia beginner, intermnediate hadi advanced katika ulimwengu wa programming katika C++, na njia nyepesi ya kuweza kujua programming project fulani ni kwa kufanya project inaweza ikawa ni ngumu kwa mwanzao ila jinsi muda unavyoenda ndivyo ambavyo unafanya practice na kupitia concept mabalimbali katiak project yako inakuwa rahisi zaidi.</p>"},{"location":"projects/projets/#beginner-projects","title":"Beginner Projects","text":""},{"location":"projects/projets/#1-hello-world-program","title":"1. Hello World Program","text":"<ul> <li>The classic starting point for any programming language.</li> <li>Practice printing \"Hello, World!\" to the console.</li> </ul>"},{"location":"projects/projets/#2-simple-calculator","title":"2. Simple Calculator","text":"<ul> <li>Katika sehemu hii tutatengeneza simple calculator kwa kutumia concepts amabzo hata beginner ataweza kuzifanya na ni simple tu kikubwa na kujua nini kimefanyika na kwanini kimefanyika.Calculator itakuwa na uwezo wa kufanya basic operesheni kama kujumlisha, kugawanya, kuzidisha na kutoa. Code zode zitakuwa hapa Calculator</li> </ul>"},{"location":"projects/projets/#3-guess-the-number-game","title":"3. Guess the Number Game","text":"<ul> <li>Katika project yetu ya pili tutatengeneza game ambalo computer itagenerate random number ial mtumiaji wetu atajaribu kufanya makadilio ya hiyo namba katika game hilo,ipo hapa Guess number game</li> </ul>"},{"location":"projects/projets/#intermediate-projects","title":"Intermediate Projects","text":""},{"location":"projects/projets/#4-todo-list-application","title":"4. Todo List Application","text":"<ul> <li>Hakuna developer ambaye hajawahi kutengeneza todolist apllication ila pia sio lazima na wewe kufanya ila ni muhimu,hivyo katika sehemu hii tutatengeneza todo list application ambayo itatuwezesha kuweka task, kumark task kama imekamilika na pia kufuta task katika program.</li> </ul>"},{"location":"projects/projets/#5-bank-management-system","title":"5. Bank Management System","text":"<ul> <li>Simple bank management sytem pia unaweza ukapitia project nyingine amabyo nilifanya ya hotel managemeny sytem kwa kutumia <code>C++</code>, ila hapa tutatengeneza bank management system amabyo tutaweaz functionalities kama kutengeneza account , kutuma hela na pia kuangalia salio.</li> </ul>"},{"location":"projects/projets/#6-simple-file-encryptiondecryption","title":"6. Simple File Encryption/Decryption","text":"<ul> <li>Tutatengeneza program ambayo tutaweza kufanya encryption na decrption ya text files na pia tutaangalia baadhi ya encryption algorithms</li> </ul>"},{"location":"projects/projets/#advanced-projects","title":"Advanced Projects","text":""},{"location":"projects/projets/#7-network-chat-application","title":"7. Network Chat Application","text":"<ul> <li>Develop a client-server chat application that allows users to communicate over a network.</li> <li>Implement features like private messaging and chat rooms.</li> </ul>"},{"location":"projects/projets/#8-compiler-design","title":"8. Compiler Design","text":"<ul> <li>Tutatengeneza simple compiler kwa kutumia lugha ya C++ pia tutatengeneza interpreter kwa, tutatumia lexical analysis, parsing na code generation.</li> </ul>"},{"location":"projects/projets/#9-memory-leak-detector","title":"9. Memory Leak Detector","text":"<ul> <li>Katika sehemu hii tutajifunza jinsi ya kutengeneza memory leak detector kwa kutumia C++ ila hii tutatumia hususani pointers kwahiyo hakikisha kipande cha pointers imepitia vizuri.</li> </ul>"},{"location":"projects/projets/#conclusion","title":"Conclusion","text":"<p>Choose a project that aligns with your current skill level and interests. Don't hesitate to push your boundaries and explore new concepts. Happy coding!</p> <p>Chagua project ambayo inaendana na level yako ambayo upo,pia usisahau kupush boundaries katika project zako</p> <p>Pushin P(Positive)</p> <p>Happy Coding</p>"},{"location":"resources/books/books/","title":"C++ Books","text":"<ul> <li>Introduction</li> <li>Beginner's Guide</li> <li>Intermediate to Advanced</li> <li>Specialized Topics</li> <li>Reference Books</li> <li>Best Practices and Design Patterns</li> <li>Online Resources</li> <li>Books for Competitive Programming</li> <li>C++ Standards and Updates</li> <li>Community Recommendations</li> </ul>"},{"location":"resources/books/books/#introduction","title":"Introduction","text":""},{"location":"resources/books/books/#beginners-guide","title":"Beginner's Guide","text":""},{"location":"resources/books/books/#intermediate-to-advanced","title":"Intermediate to Advanced","text":""},{"location":"resources/books/books/#specialized-topics","title":"Specialized Topics","text":""},{"location":"resources/books/books/#reference-books","title":"Reference Books","text":""},{"location":"resources/books/books/#best-practices-and-design-patterns","title":"Best Practices and Design Patterns","text":""},{"location":"resources/books/books/#online-resources","title":"Online Resources","text":""},{"location":"resources/books/books/#books-for-competitive-programming","title":"Books for Competitive Programming","text":""},{"location":"resources/books/books/#c-standards-and-updates","title":"C++ Standards and Updates","text":""},{"location":"resources/books/books/#community-recommendations","title":"Community Recommendations","text":"<p>\u2b06\ufe0f Return to Top</p>"},{"location":"resources/questions/questions/","title":"Questions","text":""},{"location":"resources/questions/questions/#questions","title":"Questions","text":"<ul> <li>Basics</li> <li>Arrays</li> <li>Control Flow</li> <li>Functions</li> <li>Pointers</li> <li>Strings</li> <li>Variables</li> <li>Decision Making</li> <li>Operators</li> <li>Intermediate</li> <li>Algorithms</li> <li>Data Structures</li> <li>Enumerations</li> <li>Errors</li> <li>Memory Management</li> <li>Object Oriented</li> <li>STL</li> <li>Structures</li> <li>Templates</li> <li>Advanced</li> </ul>"},{"location":"resources/questions/questions/#basics","title":"Basics","text":""},{"location":"resources/questions/questions/#arrays","title":"Arrays","text":""},{"location":"resources/questions/questions/#control-flow","title":"Control Flow","text":"<ul> <li>What is the purpose of the if statement in C++?</li> <li>How do you use the if-else statement in C++?</li> <li>Discuss the nested if-else statement in C++.</li> <li>Explain the concept of the else-if ladder in C++.</li> <li>How do you use the switch statement as an alternative to multiple if-else statements?</li> <li>What is the ternary conditional operator (? :) in C++, and how is it used?</li> <li>Discuss the usage of short-circuit evaluation with if-else statements.</li> <li>How do you write multi-line if-else statements in C++?</li> <li>Explain the importance of the default case in switch statements.</li> <li>Discuss the common mistakes to avoid when using if-else statements in C++.</li> </ul>"},{"location":"resources/questions/questions/#control-flow-in-c","title":"Control Flow in C++","text":"<ol> <li>What is control flow in programming, and why is it important?</li> <li>Describe the role of conditional statements in C++ control flow.</li> <li>Explain the syntax and usage of the <code>if</code> statement in C++.</li> <li>How does the <code>else if</code> statement differ from nested <code>if</code> statements in C++?</li> <li>Discuss the purpose and usage of the <code>switch</code> statement in C++.</li> <li>What is the difference between <code>while</code> and <code>do-while</code> loops in C++? Provide examples.</li> <li>Explain the concept of loop control statements (<code>break</code>, <code>continue</code>, <code>goto</code>) in C++.</li> <li>Discuss the syntax and usage of the <code>for</code> loop in C++. How does it compare to <code>while</code> loops?</li> <li>Describe the role of iteration control variables in <code>for</code> loops in C++.</li> <li>What is the purpose of the <code>range-based for</code> loop introduced in C++11?</li> <li>Explain how you can use <code>break</code> and <code>continue</code> statements in nested loops in C++.</li> <li>Discuss the dangers and potential misuse of the <code>goto</code> statement in C++.</li> <li>How does C++ handle nested control structures, such as nested loops and conditional statements?</li> <li>Describe the behavior of control flow statements in C++ in relation to scope and variable visibility.</li> <li>What are the advantages of using functions to control program flow in C++?</li> <li>How does C++ handle control flow in error and exception handling scenarios?</li> <li>Discuss the role of recursion in control flow in C++. What are its advantages and disadvantages?</li> <li>Explain the differences between static and dynamic control flow in C++.</li> <li>Describe the role of conditional operators (<code>&amp;&amp;</code>, <code>||</code>, <code>?:</code>) in C++ control flow.</li> <li>Discuss the impact of control flow optimization techniques on the performance of C++ programs.</li> </ol>"},{"location":"resources/questions/questions/#functions","title":"Functions","text":""},{"location":"resources/questions/questions/#functions-in-c","title":"Functions in C++","text":"<ol> <li>What is a function in C++?</li> <li>Explain the difference between a function declaration and a function definition.</li> <li>How do you declare a function in C++?</li> <li>Discuss the syntax for defining a function in C++.</li> <li>What is the purpose of function prototypes in C++?</li> <li>How do you call a function in C++?</li> <li>Explain the concept of function parameters. What are the different types of function parameters in C++?</li> <li>Describe the difference between pass-by-value and pass-by-reference in function parameters.</li> <li>How do you return values from a function in C++?</li> <li>What is function overloading? Provide an example.</li> <li>Discuss the concept of default arguments in C++ functions.</li> <li>Explain the role of inline functions in C++. When should they be used?</li> <li>What are recursive functions? How do you implement recursion in C++?</li> <li>Discuss the benefits and drawbacks of using recursion in C++.</li> <li>How does C++ handle function scope and variable visibility?</li> <li>Describe the use of function pointers in C++. Provide an example.</li> <li>Explain the purpose of function templates in C++. How do you define and use them?</li> <li>Discuss the concept of lambda functions in C++. How are they defined and used?</li> <li>What are the differences between lambdas and regular functions in C++?</li> <li>How do you organize functions within a C++ program for readability and maintainability?</li> </ol>"},{"location":"resources/questions/questions/#pointers","title":"Pointers","text":""},{"location":"resources/questions/questions/#pointers-in-c","title":"Pointers in C++","text":"<ol> <li>What is a pointer in C++?</li> <li>Explain the concept of memory address and how pointers relate to it.</li> <li>How do you declare a pointer variable in C++?</li> <li>Describe the difference between a null pointer and a void pointer.</li> <li>How do you initialize a pointer in C++?</li> <li>Discuss the significance of the asterisk (*) operator in C++ pointer declarations.</li> <li>Explain the concept of pointer arithmetic in C++. Provide an example.</li> <li>What are the advantages of using pointers in C++?</li> <li>Describe the process of allocating memory dynamically using pointers.</li> <li>How do you access the value stored at a memory address pointed to by a pointer?</li> <li>Discuss the dangers of using uninitialized pointers in C++.</li> <li>What is a dangling pointer? How can it be avoided?</li> <li>Explain the difference between pass by value and pass by reference using pointers.</li> <li>How do you deallocate memory allocated dynamically using pointers?</li> <li>What are function pointers in C++? Provide an example of their usage.</li> <li>Discuss the role of pointers in creating data structures like linked lists and trees.</li> <li>Explain the concept of pointer-to-pointer (double pointer) in C++.</li> <li>How can you check if a pointer is pointing to valid memory?</li> <li>Discuss the use of const pointers and pointer to constants in C++.</li> <li>Describe the relationship between arrays and pointers in C++.</li> <li>How can you use pointers to achieve dynamic memory allocation for multidimensional arrays?</li> <li>Discuss the differences between pointers and references in C++.</li> <li>What is the <code>nullptr</code> keyword in C++ and how is it used with pointers?</li> <li>Explain the concept of smart pointers and their role in modern C++ programming.</li> <li>How do you handle pointers in object-oriented programming in C++?</li> </ol>"},{"location":"resources/questions/questions/#strings","title":"Strings","text":""},{"location":"resources/questions/questions/#strings-in-c","title":"Strings in C++","text":"<ol> <li>What are strings in C++ and how are they represented?</li> <li>Explain the difference between C-style strings and C++ <code>std::string</code>.</li> <li>How do you declare and initialize a <code>std::string</code> variable in C++?</li> <li>Discuss the advantages of using <code>std::string</code> over C-style strings.</li> <li>How do you concatenate two strings in C++?</li> <li>What is the <code>length()</code> method in <code>std::string</code> and how is it used?</li> <li>Explain the usage of the <code>substr()</code> method in <code>std::string</code>.</li> <li>How can you access individual characters in a <code>std::string</code>?</li> <li>Discuss the various ways to traverse through a <code>std::string</code>.</li> <li>What is string interpolation, and does C++ support it natively?</li> <li>Explain the usage of the <code>find()</code> method in <code>std::string</code>.</li> <li>How do you compare two strings in C++?</li> <li>Discuss the role of character encoding in C++ strings.</li> <li>What are the limitations of C-style strings compared to <code>std::string</code>?</li> <li>How do you convert between C-style strings and <code>std::string</code> in C++?</li> <li>Discuss the impact of string manipulation on memory management in C++.</li> <li>Explain the difference between <code>c_str()</code> and <code>data()</code> methods in <code>std::string</code>.</li> <li>How does C++ handle string input/output operations?</li> <li>Discuss the performance considerations when working with large strings in C++.</li> <li>What are some common pitfalls to avoid when working with strings in C++?</li> </ol>"},{"location":"resources/questions/questions/#variables","title":"Variables","text":"<ul> <li>What is a variable, and why is it essential in programming?</li> <li>Differentiate between local and global variables in C++.</li> <li>How do you declare and initialize variables in C++?</li> <li>Discuss the role of data types in determining the type of variables.</li> <li>What is the significance of the const keyword when declaring variables?</li> <li>Explain the difference between automatic, static, and dynamic variables.</li> <li>How does the lifetime of a variable impact its usage in a program?</li> <li>Discuss the rules and best practices for naming variables in C++.</li> <li>Provide examples of variable declarations with appropriate data types.   What is a data type, and why is it important in C++?</li> <li>Explain the purpose of the int data type in C++.</li> <li>What is the range of values that an int can represent in C++?</li> <li>How do you use the sizeof operator to determine the size of an int variable?</li> <li>Discuss the differences between signed and unsigned integers.</li> <li>Explain the concept of integer overflow and how it can be mitigated.</li> <li>Provide examples of arithmetic operations using int variables.</li> <li>Describe the role of casting in converting between different data types, including int.</li> <li>Discuss the significance of the % (modulo) operator with respect to integers.</li> <li>How does C++ handle division of integers, and what are the potential issues?</li> </ul>"},{"location":"resources/questions/questions/#decision-making","title":"Decision Making","text":""},{"location":"resources/questions/questions/#operators","title":"Operators","text":"<ul> <li>What are comparison operators in C++?</li> <li>Discuss the equality operator (==) in C++.</li> <li>Explain the inequality operator (!=) in C++.</li> <li>Describe the greater than (&gt;) and less than (&lt;) operators in C++.</li> <li>Discuss the greater than or equal to (&gt;=) and less than or equal to (&lt;=) operators in C++.</li> <li>What is the significance of comparing floating-point numbers using == in C++?</li> <li>Explain the concept of operator overloading in C++ concerning comparison operators.</li> <li>Discuss the usage of comparison operators with strings in C++.</li> <li>How do you compare pointers using comparison operators in C++?</li> <li>What happens when comparing objects of user-defined types in C++?</li> </ul>"},{"location":"resources/questions/questions/#intermediate","title":"Intermediate","text":""},{"location":"resources/questions/questions/#algorithms","title":"Algorithms","text":""},{"location":"resources/questions/questions/#algorithms-in-c","title":"Algorithms in C++","text":"<ol> <li>What is an algorithm in the context of computer science?</li> <li>Explain the importance of algorithm analysis in software development.</li> <li>Describe the difference between time complexity and space complexity of an algorithm.</li> <li>How do you measure the efficiency of an algorithm in terms of time complexity?</li> <li>Discuss the concept of Big O notation and its significance in algorithm analysis.</li> <li>What are the common categories of algorithmic complexity (e.g., O(1), O(log n), O(n), O(n^2), etc.)?</li> <li>Explain the concept of algorithmic stability. Why is it important?</li> <li>Describe the process of algorithm design. What are the key steps involved?</li> <li>Discuss the advantages and disadvantages of iterative versus recursive algorithms in C++.</li> <li>Explain the difference between a brute-force algorithm and an optimized algorithm.</li> <li>What are searching algorithms? Provide examples of commonly used searching algorithms in C++.</li> <li>Discuss the characteristics and use cases of linear search and binary search algorithms.</li> <li>What is a sorting algorithm? List and briefly explain some commonly used sorting algorithms in C++.</li> <li>Compare and contrast the performance of bubble sort, insertion sort, selection sort, and merge sort.</li> <li>Explain the concept of divide and conquer in algorithm design. Provide examples of algorithms that use this approach.</li> <li>What is dynamic programming? How does it differ from greedy algorithms?</li> <li>Describe the process of backtracking in algorithm design. Provide examples of problems solved using backtracking.</li> <li>Discuss the importance of algorithmic optimization techniques in C++ programming.</li> <li>Explain the role of recursion in algorithm design. How can tail recursion be optimized in C++?</li> <li>Describe how algorithms are implemented and utilized in the C++ Standard Template Library (STL).</li> <li>Discuss the significance of algorithmic complexity analysis in the context of real-world applications.</li> <li>How can you determine the efficiency of an algorithm experimentally through benchmarking in C++?</li> <li>Describe the process of algorithm debugging and optimization in C++.</li> <li>Discuss the impact of algorithmic complexity on system performance and scalability.</li> <li>What are some strategies for improving the efficiency of algorithms in C++?</li> </ol>"},{"location":"resources/questions/questions/#data-structures","title":"Data Structures","text":""},{"location":"resources/questions/questions/#enumerations","title":"Enumerations","text":""},{"location":"resources/questions/questions/#enumerations-in-c","title":"Enumerations in C++","text":"<ol> <li>What is an enumeration in C++?</li> <li>How do you declare an enumeration in C++?</li> <li>Explain the purpose of enumerations in programming.</li> <li>What is the difference between an enumeration and a set of preprocessor #define constants?</li> <li>How are enumerations implemented in memory in C++?</li> <li>Can you assign integer values explicitly to enumeration constants? If so, how?</li> <li>How do you access individual elements of an enumeration in C++?</li> <li>Discuss the scope of enumeration constants in C++.</li> <li>Can you define methods or member variables inside an enumeration in C++? Why or why not?</li> <li>Explain the concept of scoped enumerations (enum class) introduced in C++11.</li> <li>What are the advantages of using scoped enumerations over traditional enumerations?</li> <li>How do you specify the underlying type of a C++ enumeration?</li> <li>Discuss the use of enumerations in switch statements in C++.</li> <li>Can you convert between enumeration values and integers in C++? If so, how?</li> <li>How do you iterate through all the values of an enumeration in C++?</li> <li>Explain the role of enumeration types in improving code readability and maintainability.</li> <li>Discuss scenarios where enumerations are preferable over other data types in C++.</li> <li>What are the limitations of using enumerations in C++?</li> <li>How do you handle out-of-range enumeration values in C++?</li> <li>Provide examples of real-world scenarios where enumerations are commonly used in C++ programming.</li> </ol>"},{"location":"resources/questions/questions/#enumerations-in-c_1","title":"Enumerations in C++","text":"<ol> <li>What is an enumeration in C++?</li> <li>How do you declare an enumeration in C++?</li> <li>Explain the purpose of enumerations in programming.</li> <li>What is the difference between an enumeration and a set of preprocessor #define constants?</li> <li>How are enumerations implemented in memory in C++?</li> <li>Can you assign integer values explicitly to enumeration constants? If so, how?</li> <li>How do you access individual elements of an enumeration in C++?</li> <li>Discuss the scope of enumeration constants in C++.</li> <li>Can you define methods or member variables inside an enumeration in C++? Why or why not?</li> <li>Explain the concept of scoped enumerations (enum class) introduced in C++11.</li> <li>What are the advantages of using scoped enumerations over traditional enumerations?</li> <li>How do you specify the underlying type of a C++ enumeration?</li> <li>Discuss the use of enumerations in switch statements in C++.</li> <li>Can you convert between enumeration values and integers in C++? If so, how?</li> <li>How do you iterate through all the values of an enumeration in C</li> </ol>"},{"location":"resources/questions/questions/#errors","title":"Errors","text":"<ol> <li>What are the different types of errors in C++?</li> <li>Explain the difference between compile-time errors and runtime errors in C++.</li> <li>How does C++ handle syntax errors during compilation?</li> <li>Describe the process of handling runtime errors in C++.</li> <li>What are logical errors in C++? How can they be identified and fixed?</li> <li>Discuss the role of exception handling in C++ error management.</li> <li>Explain the purpose and usage of <code>try</code>, <code>catch</code>, and <code>throw</code> keywords in C++ exception handling.</li> <li>What are the benefits and drawbacks of using exceptions for error handling in C++?</li> <li>How does C++ support error handling in functions that return values?</li> <li>Describe the role of the standard library's <code>&lt;stdexcept&gt;</code> header in C++ error handling.</li> <li>Discuss the concept of stack unwinding in C++ exception handling.</li> <li>Explain the relationship between error handling and resource management in C++.</li> <li>What are segmentation faults (segfaults) in C++? How can they be prevented?</li> <li>How does C++ handle memory allocation errors?</li> <li>Describe common strategies for debugging errors in C++ programs.</li> <li>Discuss the role of assertions in error checking during program development.</li> <li>How can you handle input/output errors in C++ programs?</li> <li>Explain the purpose and usage of the <code>errno</code> variable in C++ error handling.</li> <li>What are the potential consequences of unchecked errors in C++ programs?</li> <li>Discuss best practices for effective error handling and debugging in C++.</li> </ol>"},{"location":"resources/questions/questions/#memory-management","title":"Memory Management","text":""},{"location":"resources/questions/questions/#memory-management-in-c","title":"Memory Management in C++","text":"<ol> <li>What is dynamic memory allocation in C++?</li> <li>Explain the difference between stack and heap memory.</li> <li>How do you allocate memory on the heap in C++?</li> <li>What is the purpose of the <code>new</code> operator in C++?</li> <li>Describe the process of deallocating memory in C++.</li> <li>What are memory leaks? How can they be avoided in C++?</li> <li>Explain the concept of smart pointers in C++. How do they help with memory management?</li> <li>What are the differences between <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>?</li> <li>How does C++ handle memory management for local variables?</li> <li>Discuss the dangers of using raw pointers for memory management in C++.</li> <li>What is RAII (Resource Acquisition Is Initialization) and how does it relate to memory management?</li> <li>Describe the role of destructors in C++ memory management.</li> <li>How does C++ manage memory for objects created with <code>new</code> and <code>delete</code>?</li> <li>Explain the purpose and usage of the <code>malloc</code> and <code>free</code> functions in C++.</li> <li>How can you determine memory usage and performance issues in a C++ program?</li> <li>Discuss the benefits and drawbacks of using custom memory allocators in C++.</li> <li>How does C++ handle memory management in multi-threaded environments?</li> <li>Explain the role of move semantics in optimizing memory management in C++.</li> <li>What are some best practices for effective memory management in C++?</li> <li>Discuss the impact of memory fragmentation on C++ programs and potential mitigation strategies.</li> </ol>"},{"location":"resources/questions/questions/#stl","title":"STL","text":"<ol> <li>What is the difference between an STL container and an STL algorithm?</li> <li>Suppose that you have the following statement: pair temp; a. Write a C++ statement that stores the pair (1, \"Hello\") into temp. b. Write a C++ statement that outputs the pair stored in temp onto the standard output device. <li>Suppose that you have the following statement:</li> <pre><code>pair&lt;string, string&gt; name;\n</code></pre> <p>What is the output, if any, of the following statements?</p> <pre><code>name = make_pair(\"Duckey\", \"Donald\");\ncout &lt;&lt; name.first &lt;&lt; \" \" &lt;&lt; name.second &lt;&lt; endl;\n</code></pre>"},{"location":"resources/questions/questions/#object-oriented","title":"Object Oriented","text":""},{"location":"resources/questions/questions/#structures","title":"Structures","text":"<ul> <li>Given the following structure and structure variable declaration:</li> </ul> <pre><code>struct TermAccount\n{\n double balance;\n double interest_rate;\n int term;\n char initial1;\n char initial2;\n};\n\nTermAccount account;\n</code></pre> <p>what is the type of each of the following? Mark any that are not correct. a. account.balance b. account.interest_rate c. TermAccount.term d. savings_account.initial1 e. account.initial2 f. account</p> <ul> <li>Consider the following type definition:</li> </ul> <pre><code>struct ShoeType\n{\n char style;\n double price;\n};\n</code></pre> <p>Given this structure type definition, what will be the output produced by the following code?</p> <pre><code>ShoeType shoe1, shoe2;\nshoe1.style ='A';\nshoe1.price = 9.99;\ncout &lt;&lt; shoe1.style &lt;&lt; \" $\" &lt;&lt; shoe1.price &lt;&lt; endl;\nshoe2 = shoe1;\nshoe2.price = shoe2.price/9;\ncout &lt;&lt; shoe2.style &lt;&lt; \" $\" &lt;&lt; shoe2.price &lt;&lt; endl;\n</code></pre> <ul> <li>Here is an initialization of a structure type. Tell what happens with each initialization. Note any problems with these initializations.</li> </ul> <pre><code>struct Date\n{\n int month;\n int day;\n int year;\n};\n</code></pre> <p>a. Date due_date = {12, 21}; b. Date due_date = {12, 21, 20, 22}; c. Date due_date = {12, 21, 20, 22}; d. Date due_date = {12, 21, 22};</p> <ul> <li>Write a definition for a structure type for records consisting of a person\u2019s wage rate, accrued vacation (which is some whole number of days), and status (which is either hourly or salaried). Represent the status as one of the two char values 'H' and 'S'. Call the type EmployeeRecord.</li> <li>Give a function definition corresponding to the following function declaration. (The type ShoeType is given in Self-Test Exercise 2.) void read_shoe_record(ShoeType&amp; new_shoe); //Fills new_shoe with values read from the keyboard.</li> </ul>"},{"location":"resources/questions/questions/#templates","title":"Templates","text":"<ul> <li>What is a template in C++?</li> <li>Discuss the difference between function templates and class templates.</li> <li>How do you define a template function in C++?</li> <li>Explain the concept of template specialization.</li> <li>What are the advantages of using templates in C++?</li> <li>How do you pass template arguments in C++?</li> <li>Discuss the role of template arguments deduction.</li> <li>What is the syntax for creating a template class in C++?</li> <li>How do you ensure type safety in template programming?</li> <li>Explain the use of template metaprogramming in C++</li> </ul>"},{"location":"resources/questions/questions/#advanced","title":"Advanced","text":""},{"location":"resources/website/website/","title":"Websites for Practicing C++ Skills","text":"<p>Iwapo unatazamia kuboresha ustadi wako wa kupanga wa C++, kuna tovuti kadhaa na majukwaa ya mtandaoni ambapo unaweza kufanya mazoezi na kuboresha uwezo wako. Hapa kuna chaguzi maarufu:</p>"},{"location":"resources/website/website/#1-leetcode","title":"1. LeetCode","text":"<p>LeetCode ni jukwaa linalotumiwa sana kwa kufanya mazoezi ya maswali ya mahojiano ya kuandika nambari katika lugha mbalimbali za programu, ikiwa ni pamoja na C++. Inatoa matatizo mengi yaliyopangwa kwa viwango tofauti vya ugumu, kutoka rahisi hadi vigumu. LeetCode ni nzuri kwa kuboresha uwezo wa kutatua matatizo na fikira za algoriti.</p>"},{"location":"resources/website/website/#2-hackerrank","title":"2. HackerRank","text":"<p>HackerRank ni jukwaa lingine maarufu linalotoa changamoto na mashindano ili kusaidia wabunifu wa programu kuboresha ujuzi wao wa kuandika nambari. Inatoa sehemu maalum kwa changamoto za C++, kuanzia mazoezi ya sintaksia ya msingi hadi algoriti na miundo ya data ngumu zaidi.</p>"},{"location":"resources/website/website/#3-codeforces","title":"3. Codeforces","text":"<p>Codeforces hutoa mashindano ya kawaida ya programu za mashindano ambapo washiriki wanaweza kutatua matatizo magumu kwa kutumia C++ na lugha zingine za programu. Pia ina hazina kubwa ya matatizo ya mashindano ya zamani, kuruhusu watumiaji kufanya mazoezi kwa kasi yao wenyewe.</p>"},{"location":"resources/website/website/#4-codewars","title":"4. Codewars","text":"<p>Codewars ni jukwaa linalotoa changamoto za kuandika nambari zinazoitwa \"kata\" katika lugha mbalimbali za programu, ikiwa ni pamoja na C++. Watumiaji wanaweza kufanya mazoezi ya kata zenye viwango tofauti vya ugumu, na jukwaa hutoa suluhisho za jumuiya na majadiliano kwa kila tatizo.</p>"},{"location":"resources/website/website/#5-exercism","title":"5. Exercism","text":"<p>Exercism hutoa mazoezi katika C++ na lugha zingine za programu ili kusaidia watumiaji kuboresha ujuzi wao wa kuandika nambari kupitia mazoezi na msaada wa wakufunzi. Inatoa njia ya kipekee ambapo watumiaji hutatua matatizo na kupokea maoni kutoka kwa wakufunzi ili kuboresha uelewa wao na ujuzi.</p>"},{"location":"resources/website/website/#6-codecademy","title":"6. Codecademy","text":"<p>Codecademy inatoa kozi za C++ za kuingiliana kwa waanziaji na waelimishaji wa kati. Inatoa mazoezi ya kuandika nambari, vipimo, na miradi ili kusaidia watumiaji kuelewa dhana muhimu na ujuzi wa vitendo katika programu ya C++.</p>"},{"location":"resources/website/website/#7-geeksforgeeks","title":"7. GeeksforGeeks","text":"<p>GeeksforGeeks ni rasilimali kamili ya kujifunza na kufanya mazoezi ya programu ya C++. Inatoa mafunzo, makala, na changamoto za kuandika nambari zinazojumuisha mada mbalimbali kama vile algoriti, miundo ya data, na programu za mashindano.</p>"},{"location":"resources/website/website/#8-c-shell","title":"8. C++ Shell","text":"<p>C++ Shell ni kompyuta mtandaoni na mtafsiri ambayo inaruhusu watumiaji kuandika na kutekeleza nambari ya C++ moja kwa moja kutoka kwa kivinjari chao cha wavuti. Ni chombo muhimu kwa haraka kujaribu vipande vidogo vya nambari au kufanya majaribio na vipengele vya C++.</p>"},{"location":"resources/website/website/#9-sololearn","title":"9. SoloLearn","text":"<p>SoloLearn hutoa kozi ya bure ya programu ya C++ na vipindi vya kuingiliana, vipimo, na jumuiya inayotoa msaada. Ni sahihi kwa waanziaji ambao wanataka kujifunza C++ kutoka mwanzoni au kuboresha ujuzi wao.</p>"},{"location":"resources/website/website/#10-project-euler","title":"10. Project Euler","text":"<p>Project Euler hutoa kozi ya bure ya programu ya C++ na vipindi vya kuingiliana, vipimo, na jumuiya inayotoa msaada. Ni sahihi kwa waanziaji ambao wanataka kujifunza C++ kutoka mwanzoni au kuboresha ujuzi wao.</p>"}]}